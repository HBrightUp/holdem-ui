/*! For license information please see raceMain.js.LICENSE.txt */
(() => {
  var e = {
      5507: (e, t) => {
        "use strict";
        function r(e) {
          if (Array.isArray(e)) {
            const t = [];
            let n = 0;
            for (let i = 0; i < e.length; i++) {
              const s = r(e[i]);
              t.push(s), (n += s.length);
            }
            return h(s(n, 192), ...t);
          }
          const t = y(e);
          return 1 === t.length && t[0] < 128 ? t : h(s(t.length, 128), t);
        }
        function n(e, t, r) {
          if (r > e.length)
            throw new Error(
              "invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds",
            );
          return e.slice(t, r);
        }
        function i(e) {
          if (0 === e[0]) throw new Error("invalid RLP: extra zeros");
          return u(d(e));
        }
        function s(e, t) {
          if (e < 56) return Uint8Array.from([e + t]);
          const r = p(e),
            n = p(t + 55 + r.length / 2);
          return Uint8Array.from(l(n + r));
        }
        function o(e, t = !1) {
          if (null == e || 0 === e.length) return Uint8Array.from([]);
          const r = a(y(e));
          if (t) return r;
          if (0 !== r.remainder.length)
            throw new Error("invalid RLP: remainder must be zero");
          return r.data;
        }
        function a(e) {
          let t, r, s, o, c;
          const d = [],
            u = e[0];
          if (u <= 127) return { data: e.slice(0, 1), remainder: e.slice(1) };
          if (u <= 183) {
            if (
              ((t = u - 127),
              (s = 128 === u ? Uint8Array.from([]) : n(e, 1, t)),
              2 === t && s[0] < 128)
            )
              throw new Error(
                "invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed",
              );
            return { data: s, remainder: e.slice(t) };
          }
          if (u <= 191) {
            if (((r = u - 182), e.length - 1 < r))
              throw new Error(
                "invalid RLP: not enough bytes for string length",
              );
            if (((t = i(n(e, 1, r))), t <= 55))
              throw new Error(
                "invalid RLP: expected string length to be greater than 55",
              );
            return (s = n(e, r, t + r)), { data: s, remainder: e.slice(t + r) };
          }
          if (u <= 247) {
            for (t = u - 191, o = n(e, 1, t); o.length; )
              (c = a(o)), d.push(c.data), (o = c.remainder);
            return { data: d, remainder: e.slice(t) };
          }
          {
            if (((r = u - 246), (t = i(n(e, 1, r))), t < 56))
              throw new Error("invalid RLP: encoded list too short");
            const s = r + t;
            if (s > e.length)
              throw new Error(
                "invalid RLP: total length is larger than the data",
              );
            for (o = n(e, r, s); o.length; )
              (c = a(o)), d.push(c.data), (o = c.remainder);
            return { data: d, remainder: e.slice(s) };
          }
        }
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.RLP = t.utils = t.decode = t.encode = void 0),
          (t.encode = r),
          (t.decode = o);
        const c = Array.from({ length: 256 }, (e, t) =>
          t.toString(16).padStart(2, "0"),
        );
        function d(e) {
          let t = "";
          for (let r = 0; r < e.length; r++) t += c[e[r]];
          return t;
        }
        function u(e) {
          const t = Number.parseInt(e, 16);
          if (Number.isNaN(t)) throw new Error("Invalid byte sequence");
          return t;
        }
        function l(e) {
          if ("string" != typeof e)
            throw new TypeError("hexToBytes: expected string, got " + typeof e);
          if (e.length % 2)
            throw new Error("hexToBytes: received invalid unpadded hex");
          const t = new Uint8Array(e.length / 2);
          for (let r = 0; r < t.length; r++) {
            const n = 2 * r;
            t[r] = u(e.slice(n, n + 2));
          }
          return t;
        }
        function h(...e) {
          if (1 === e.length) return e[0];
          const t = e.reduce((e, t) => e + t.length, 0),
            r = new Uint8Array(t);
          for (let t = 0, n = 0; t < e.length; t++) {
            const i = e[t];
            r.set(i, n), (n += i.length);
          }
          return r;
        }
        function f(e) {
          return new TextEncoder().encode(e);
        }
        function p(e) {
          if (e < 0)
            throw new Error("Invalid integer as argument, must be unsigned!");
          const t = e.toString(16);
          return t.length % 2 ? `0${t}` : t;
        }
        function m(e) {
          return e.length >= 2 && "0" === e[0] && "x" === e[1];
        }
        function y(e) {
          if (e instanceof Uint8Array) return e;
          if ("string" == typeof e)
            return m(e)
              ? l(
                  (t = "string" != typeof (r = e) ? r : m(r) ? r.slice(2) : r)
                    .length % 2
                    ? `0${t}`
                    : t,
                )
              : f(e);
          var t, r;
          if ("number" == typeof e || "bigint" == typeof e)
            return e ? l(p(e)) : Uint8Array.from([]);
          if (null == e) return Uint8Array.from([]);
          throw new Error("toBytes: received unsupported type " + typeof e);
        }
        (t.utils = {
          bytesToHex: d,
          concatBytes: h,
          hexToBytes: l,
          utf8ToBytes: f,
        }),
          (t.RLP = { encode: r, decode: o });
      },
      6602: (e, t, r) => {
        "use strict";
        r.r(t),
          r.d(t, {
            AbiCoder: () => rt,
            ConstructorFragment: () => oe,
            ErrorFragment: () => de,
            EventFragment: () => re,
            FormatTypes: () => Q,
            Fragment: () => te,
            FunctionFragment: () => ae,
            Indexed: () => dt,
            Interface: () => ht,
            LogDescription: () => ot,
            ParamType: () => Y,
            TransactionDescription: () => at,
            checkResultErrors: () => me,
            defaultAbiCoder: () => nt,
          });
        var n = r(3550),
          i = r.n(n);
        let s = !1,
          o = !1;
        const a = {
          debug: 1,
          default: 2,
          info: 2,
          warning: 3,
          error: 4,
          off: 5,
        };
        let c = a.default,
          d = null;
        const u = (function () {
          try {
            const e = [];
            if (
              (["NFD", "NFC", "NFKD", "NFKC"].forEach((t) => {
                try {
                  if ("test" !== "test".normalize(t))
                    throw new Error("bad normalize");
                } catch (r) {
                  e.push(t);
                }
              }),
              e.length)
            )
              throw new Error("missing " + e.join(", "));
            if (
              String.fromCharCode(233).normalize("NFD") !==
              String.fromCharCode(101, 769)
            )
              throw new Error("broken implementation");
          } catch (e) {
            return e.message;
          }
          return null;
        })();
        var l, h;
        !(function (e) {
          (e.DEBUG = "DEBUG"),
            (e.INFO = "INFO"),
            (e.WARNING = "WARNING"),
            (e.ERROR = "ERROR"),
            (e.OFF = "OFF");
        })(l || (l = {})),
          (function (e) {
            (e.UNKNOWN_ERROR = "UNKNOWN_ERROR"),
              (e.NOT_IMPLEMENTED = "NOT_IMPLEMENTED"),
              (e.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION"),
              (e.NETWORK_ERROR = "NETWORK_ERROR"),
              (e.SERVER_ERROR = "SERVER_ERROR"),
              (e.TIMEOUT = "TIMEOUT"),
              (e.BUFFER_OVERRUN = "BUFFER_OVERRUN"),
              (e.NUMERIC_FAULT = "NUMERIC_FAULT"),
              (e.MISSING_NEW = "MISSING_NEW"),
              (e.INVALID_ARGUMENT = "INVALID_ARGUMENT"),
              (e.MISSING_ARGUMENT = "MISSING_ARGUMENT"),
              (e.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT"),
              (e.CALL_EXCEPTION = "CALL_EXCEPTION"),
              (e.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS"),
              (e.NONCE_EXPIRED = "NONCE_EXPIRED"),
              (e.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED"),
              (e.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT"),
              (e.TRANSACTION_REPLACED = "TRANSACTION_REPLACED"),
              (e.ACTION_REJECTED = "ACTION_REJECTED");
          })(h || (h = {}));
        const f = "0123456789abcdef";
        class p {
          constructor(e) {
            Object.defineProperty(this, "version", {
              enumerable: !0,
              value: e,
              writable: !1,
            });
          }
          _log(e, t) {
            const r = e.toLowerCase();
            null == a[r] &&
              this.throwArgumentError("invalid log level name", "logLevel", e),
              c > a[r] || console.log.apply(console, t);
          }
          debug(...e) {
            this._log(p.levels.DEBUG, e);
          }
          info(...e) {
            this._log(p.levels.INFO, e);
          }
          warn(...e) {
            this._log(p.levels.WARNING, e);
          }
          makeError(e, t, r) {
            if (o) return this.makeError("censored error", t, {});
            t || (t = p.errors.UNKNOWN_ERROR), r || (r = {});
            const n = [];
            Object.keys(r).forEach((e) => {
              const t = r[e];
              try {
                if (t instanceof Uint8Array) {
                  let r = "";
                  for (let e = 0; e < t.length; e++)
                    (r += f[t[e] >> 4]), (r += f[15 & t[e]]);
                  n.push(e + "=Uint8Array(0x" + r + ")");
                } else n.push(e + "=" + JSON.stringify(t));
              } catch (t) {
                n.push(e + "=" + JSON.stringify(r[e].toString()));
              }
            }),
              n.push(`code=${t}`),
              n.push(`version=${this.version}`);
            const i = e;
            let s = "";
            switch (t) {
              case h.NUMERIC_FAULT: {
                s = "NUMERIC_FAULT";
                const t = e;
                switch (t) {
                  case "overflow":
                  case "underflow":
                  case "division-by-zero":
                    s += "-" + t;
                    break;
                  case "negative-power":
                  case "negative-width":
                    s += "-unsupported";
                    break;
                  case "unbound-bitwise-result":
                    s += "-unbound-result";
                }
                break;
              }
              case h.CALL_EXCEPTION:
              case h.INSUFFICIENT_FUNDS:
              case h.MISSING_NEW:
              case h.NONCE_EXPIRED:
              case h.REPLACEMENT_UNDERPRICED:
              case h.TRANSACTION_REPLACED:
              case h.UNPREDICTABLE_GAS_LIMIT:
                s = t;
            }
            s &&
              (e += " [ See: https://links.ethers.org/v5-errors-" + s + " ]"),
              n.length && (e += " (" + n.join(", ") + ")");
            const a = new Error(e);
            return (
              (a.reason = i),
              (a.code = t),
              Object.keys(r).forEach(function (e) {
                a[e] = r[e];
              }),
              a
            );
          }
          throwError(e, t, r) {
            throw this.makeError(e, t, r);
          }
          throwArgumentError(e, t, r) {
            return this.throwError(e, p.errors.INVALID_ARGUMENT, {
              argument: t,
              value: r,
            });
          }
          assert(e, t, r, n) {
            e || this.throwError(t, r, n);
          }
          assertArgument(e, t, r, n) {
            e || this.throwArgumentError(t, r, n);
          }
          checkNormalize(e) {
            null == e && (e = "platform missing String.prototype.normalize"),
              u &&
                this.throwError(
                  "platform missing String.prototype.normalize",
                  p.errors.UNSUPPORTED_OPERATION,
                  { operation: "String.prototype.normalize", form: u },
                );
          }
          checkSafeUint53(e, t) {
            "number" == typeof e &&
              (null == t && (t = "value not safe"),
              (e < 0 || e >= 9007199254740991) &&
                this.throwError(t, p.errors.NUMERIC_FAULT, {
                  operation: "checkSafeInteger",
                  fault: "out-of-safe-range",
                  value: e,
                }),
              e % 1 &&
                this.throwError(t, p.errors.NUMERIC_FAULT, {
                  operation: "checkSafeInteger",
                  fault: "non-integer",
                  value: e,
                }));
          }
          checkArgumentCount(e, t, r) {
            (r = r ? ": " + r : ""),
              e < t &&
                this.throwError(
                  "missing argument" + r,
                  p.errors.MISSING_ARGUMENT,
                  { count: e, expectedCount: t },
                ),
              e > t &&
                this.throwError(
                  "too many arguments" + r,
                  p.errors.UNEXPECTED_ARGUMENT,
                  { count: e, expectedCount: t },
                );
          }
          checkNew(e, t) {
            (e !== Object && null != e) ||
              this.throwError("missing new", p.errors.MISSING_NEW, {
                name: t.name,
              });
          }
          checkAbstract(e, t) {
            e === t
              ? this.throwError(
                  "cannot instantiate abstract class " +
                    JSON.stringify(t.name) +
                    " directly; use a sub-class",
                  p.errors.UNSUPPORTED_OPERATION,
                  { name: e.name, operation: "new" },
                )
              : (e !== Object && null != e) ||
                this.throwError("missing new", p.errors.MISSING_NEW, {
                  name: t.name,
                });
          }
          static globalLogger() {
            return d || (d = new p("logger/5.7.0")), d;
          }
          static setCensorship(e, t) {
            if (
              (!e &&
                t &&
                this.globalLogger().throwError(
                  "cannot permanently disable censorship",
                  p.errors.UNSUPPORTED_OPERATION,
                  { operation: "setCensorship" },
                ),
              s)
            ) {
              if (!e) return;
              this.globalLogger().throwError(
                "error censorship permanent",
                p.errors.UNSUPPORTED_OPERATION,
                { operation: "setCensorship" },
              );
            }
            (o = !!e), (s = !!t);
          }
          static setLogLevel(e) {
            const t = a[e.toLowerCase()];
            null != t
              ? (c = t)
              : p.globalLogger().warn("invalid log level - " + e);
          }
          static from(e) {
            return new p(e);
          }
        }
        (p.errors = h), (p.levels = l);
        const m = new p("bytes/5.7.0");
        function y(e) {
          return !!e.toHexString;
        }
        function g(e) {
          return (
            e.slice ||
              (e.slice = function () {
                const t = Array.prototype.slice.call(arguments);
                return g(new Uint8Array(Array.prototype.slice.apply(e, t)));
              }),
            e
          );
        }
        function v(e) {
          return "number" == typeof e && e == e && e % 1 == 0;
        }
        function b(e) {
          if (null == e) return !1;
          if (e.constructor === Uint8Array) return !0;
          if ("string" == typeof e) return !1;
          if (!v(e.length) || e.length < 0) return !1;
          for (let t = 0; t < e.length; t++) {
            const r = e[t];
            if (!v(r) || r < 0 || r >= 256) return !1;
          }
          return !0;
        }
        function w(e, t) {
          if ((t || (t = {}), "number" == typeof e)) {
            m.checkSafeUint53(e, "invalid arrayify value");
            const t = [];
            for (; e; ) t.unshift(255 & e), (e = parseInt(String(e / 256)));
            return 0 === t.length && t.push(0), g(new Uint8Array(t));
          }
          if (
            (t.allowMissingPrefix &&
              "string" == typeof e &&
              "0x" !== e.substring(0, 2) &&
              (e = "0x" + e),
            y(e) && (e = e.toHexString()),
            A(e))
          ) {
            let r = e.substring(2);
            r.length % 2 &&
              ("left" === t.hexPad
                ? (r = "0" + r)
                : "right" === t.hexPad
                ? (r += "0")
                : m.throwArgumentError("hex data is odd-length", "value", e));
            const n = [];
            for (let e = 0; e < r.length; e += 2)
              n.push(parseInt(r.substring(e, e + 2), 16));
            return g(new Uint8Array(n));
          }
          return b(e)
            ? g(new Uint8Array(e))
            : m.throwArgumentError("invalid arrayify value", "value", e);
        }
        function E(e) {
          const t = e.map((e) => w(e)),
            r = t.reduce((e, t) => e + t.length, 0),
            n = new Uint8Array(r);
          return t.reduce((e, t) => (n.set(t, e), e + t.length), 0), g(n);
        }
        function A(e, t) {
          return !(
            "string" != typeof e ||
            !e.match(/^0x[0-9A-Fa-f]*$/) ||
            (t && e.length !== 2 + 2 * t)
          );
        }
        const _ = "0123456789abcdef";
        function T(e, t) {
          if ((t || (t = {}), "number" == typeof e)) {
            m.checkSafeUint53(e, "invalid hexlify value");
            let t = "";
            for (; e; ) (t = _[15 & e] + t), (e = Math.floor(e / 16));
            return t.length
              ? (t.length % 2 && (t = "0" + t), "0x" + t)
              : "0x00";
          }
          if ("bigint" == typeof e)
            return (e = e.toString(16)).length % 2 ? "0x0" + e : "0x" + e;
          if (
            (t.allowMissingPrefix &&
              "string" == typeof e &&
              "0x" !== e.substring(0, 2) &&
              (e = "0x" + e),
            y(e))
          )
            return e.toHexString();
          if (A(e))
            return (
              e.length % 2 &&
                ("left" === t.hexPad
                  ? (e = "0x0" + e.substring(2))
                  : "right" === t.hexPad
                  ? (e += "0")
                  : m.throwArgumentError("hex data is odd-length", "value", e)),
              e.toLowerCase()
            );
          if (b(e)) {
            let t = "0x";
            for (let r = 0; r < e.length; r++) {
              let n = e[r];
              t += _[(240 & n) >> 4] + _[15 & n];
            }
            return t;
          }
          return m.throwArgumentError("invalid hexlify value", "value", e);
        }
        function R(e, t) {
          for (
            "string" != typeof e
              ? (e = T(e))
              : A(e) || m.throwArgumentError("invalid hex string", "value", e),
              e.length > 2 * t + 2 &&
                m.throwArgumentError(
                  "value out of range",
                  "value",
                  arguments[1],
                );
            e.length < 2 * t + 2;

          )
            e = "0x0" + e.substring(2);
          return e;
        }
        var I = i().BN;
        const S = new p("bignumber/5.7.0"),
          x = {},
          P = 9007199254740991;
        let O = !1;
        class C {
          constructor(e, t) {
            e !== x &&
              S.throwError(
                "cannot call constructor directly; use BigNumber.from",
                p.errors.UNSUPPORTED_OPERATION,
                { operation: "new (BigNumber)" },
              ),
              (this._hex = t),
              (this._isBigNumber = !0),
              Object.freeze(this);
          }
          fromTwos(e) {
            return M(N(this).fromTwos(e));
          }
          toTwos(e) {
            return M(N(this).toTwos(e));
          }
          abs() {
            return "-" === this._hex[0] ? C.from(this._hex.substring(1)) : this;
          }
          add(e) {
            return M(N(this).add(N(e)));
          }
          sub(e) {
            return M(N(this).sub(N(e)));
          }
          div(e) {
            return (
              C.from(e).isZero() && B("division-by-zero", "div"),
              M(N(this).div(N(e)))
            );
          }
          mul(e) {
            return M(N(this).mul(N(e)));
          }
          mod(e) {
            const t = N(e);
            return (
              t.isNeg() && B("division-by-zero", "mod"), M(N(this).umod(t))
            );
          }
          pow(e) {
            const t = N(e);
            return t.isNeg() && B("negative-power", "pow"), M(N(this).pow(t));
          }
          and(e) {
            const t = N(e);
            return (
              (this.isNegative() || t.isNeg()) &&
                B("unbound-bitwise-result", "and"),
              M(N(this).and(t))
            );
          }
          or(e) {
            const t = N(e);
            return (
              (this.isNegative() || t.isNeg()) &&
                B("unbound-bitwise-result", "or"),
              M(N(this).or(t))
            );
          }
          xor(e) {
            const t = N(e);
            return (
              (this.isNegative() || t.isNeg()) &&
                B("unbound-bitwise-result", "xor"),
              M(N(this).xor(t))
            );
          }
          mask(e) {
            return (
              (this.isNegative() || e < 0) && B("negative-width", "mask"),
              M(N(this).maskn(e))
            );
          }
          shl(e) {
            return (
              (this.isNegative() || e < 0) && B("negative-width", "shl"),
              M(N(this).shln(e))
            );
          }
          shr(e) {
            return (
              (this.isNegative() || e < 0) && B("negative-width", "shr"),
              M(N(this).shrn(e))
            );
          }
          eq(e) {
            return N(this).eq(N(e));
          }
          lt(e) {
            return N(this).lt(N(e));
          }
          lte(e) {
            return N(this).lte(N(e));
          }
          gt(e) {
            return N(this).gt(N(e));
          }
          gte(e) {
            return N(this).gte(N(e));
          }
          isNegative() {
            return "-" === this._hex[0];
          }
          isZero() {
            return N(this).isZero();
          }
          toNumber() {
            try {
              return N(this).toNumber();
            } catch (e) {
              B("overflow", "toNumber", this.toString());
            }
            return null;
          }
          toBigInt() {
            try {
              return BigInt(this.toString());
            } catch (e) {}
            return S.throwError(
              "this platform does not support BigInt",
              p.errors.UNSUPPORTED_OPERATION,
              { value: this.toString() },
            );
          }
          toString() {
            return (
              arguments.length > 0 &&
                (10 === arguments[0]
                  ? O ||
                    ((O = !0),
                    S.warn(
                      "BigNumber.toString does not accept any parameters; base-10 is assumed",
                    ))
                  : 16 === arguments[0]
                  ? S.throwError(
                      "BigNumber.toString does not accept any parameters; use bigNumber.toHexString()",
                      p.errors.UNEXPECTED_ARGUMENT,
                      {},
                    )
                  : S.throwError(
                      "BigNumber.toString does not accept parameters",
                      p.errors.UNEXPECTED_ARGUMENT,
                      {},
                    )),
              N(this).toString(10)
            );
          }
          toHexString() {
            return this._hex;
          }
          toJSON(e) {
            return { type: "BigNumber", hex: this.toHexString() };
          }
          static from(e) {
            if (e instanceof C) return e;
            if ("string" == typeof e)
              return e.match(/^-?0x[0-9a-f]+$/i)
                ? new C(x, k(e))
                : e.match(/^-?[0-9]+$/)
                ? new C(x, k(new I(e)))
                : S.throwArgumentError("invalid BigNumber string", "value", e);
            if ("number" == typeof e)
              return (
                e % 1 && B("underflow", "BigNumber.from", e),
                (e >= P || e <= -P) && B("overflow", "BigNumber.from", e),
                C.from(String(e))
              );
            const t = e;
            if ("bigint" == typeof t) return C.from(t.toString());
            if (b(t)) return C.from(T(t));
            if (t)
              if (t.toHexString) {
                const e = t.toHexString();
                if ("string" == typeof e) return C.from(e);
              } else {
                let e = t._hex;
                if (
                  (null == e && "BigNumber" === t.type && (e = t.hex),
                  "string" == typeof e &&
                    (A(e) || ("-" === e[0] && A(e.substring(1)))))
                )
                  return C.from(e);
              }
            return S.throwArgumentError("invalid BigNumber value", "value", e);
          }
          static isBigNumber(e) {
            return !(!e || !e._isBigNumber);
          }
        }
        function k(e) {
          if ("string" != typeof e) return k(e.toString(16));
          if ("-" === e[0])
            return (
              "-" === (e = e.substring(1))[0] &&
                S.throwArgumentError("invalid hex", "value", e),
              "0x00" === (e = k(e)) ? e : "-" + e
            );
          if (("0x" !== e.substring(0, 2) && (e = "0x" + e), "0x" === e))
            return "0x00";
          for (
            e.length % 2 && (e = "0x0" + e.substring(2));
            e.length > 4 && "0x00" === e.substring(0, 4);

          )
            e = "0x" + e.substring(4);
          return e;
        }
        function M(e) {
          return C.from(k(e));
        }
        function N(e) {
          const t = C.from(e).toHexString();
          return "-" === t[0]
            ? new I("-" + t.substring(3), 16)
            : new I(t.substring(2), 16);
        }
        function B(e, t, r) {
          const n = { fault: e, operation: t };
          return (
            null != r && (n.value = r),
            S.throwError(e, p.errors.NUMERIC_FAULT, n)
          );
        }
        const D = new p("properties/5.7.0");
        function j(e, t, r) {
          Object.defineProperty(e, t, {
            enumerable: !0,
            value: r,
            writable: !1,
          });
        }
        function L(e, t) {
          for (let r = 0; r < 32; r++) {
            if (e[t]) return e[t];
            if (!e.prototype || "object" != typeof e.prototype) break;
            e = Object.getPrototypeOf(e.prototype).constructor;
          }
          return null;
        }
        const U = {
          bigint: !0,
          boolean: !0,
          function: !0,
          number: !0,
          string: !0,
        };
        function F(e) {
          if (null == e || U[typeof e]) return !0;
          if (Array.isArray(e) || "object" == typeof e) {
            if (!Object.isFrozen(e)) return !1;
            const t = Object.keys(e);
            for (let r = 0; r < t.length; r++) {
              let n = null;
              try {
                n = e[t[r]];
              } catch (e) {
                continue;
              }
              if (!F(n)) return !1;
            }
            return !0;
          }
          return D.throwArgumentError(
            "Cannot deepCopy " + typeof e,
            "object",
            e,
          );
        }
        function H(e) {
          if (F(e)) return e;
          if (Array.isArray(e)) return Object.freeze(e.map((e) => G(e)));
          if ("object" == typeof e) {
            const t = {};
            for (const r in e) {
              const n = e[r];
              void 0 !== n && j(t, r, G(n));
            }
            return t;
          }
          return D.throwArgumentError(
            "Cannot deepCopy " + typeof e,
            "object",
            e,
          );
        }
        function G(e) {
          return H(e);
        }
        class V {
          constructor(e) {
            for (const t in e) this[t] = G(e[t]);
          }
        }
        const W = "abi/5.7.0",
          q = new p(W),
          Z = {};
        let z = { calldata: !0, memory: !0, storage: !0 },
          K = { calldata: !0, memory: !0 };
        function J(e, t) {
          if ("bytes" === e || "string" === e) {
            if (z[t]) return !0;
          } else if ("address" === e) {
            if ("payable" === t) return !0;
          } else if ((e.indexOf("[") >= 0 || "tuple" === e) && K[t]) return !0;
          return (
            (z[t] || "payable" === t) &&
              q.throwArgumentError("invalid modifier", "name", t),
            !1
          );
        }
        function X(e, t) {
          for (let r in t) j(e, r, t[r]);
        }
        const Q = Object.freeze({
            sighash: "sighash",
            minimal: "minimal",
            full: "full",
            json: "json",
          }),
          $ = new RegExp(/^(.*)\[([0-9]*)\]$/);
        class Y {
          constructor(e, t) {
            e !== Z &&
              q.throwError("use fromString", p.errors.UNSUPPORTED_OPERATION, {
                operation: "new ParamType()",
              }),
              X(this, t);
            let r = this.type.match($);
            X(
              this,
              r
                ? {
                    arrayLength: parseInt(r[2] || "-1"),
                    arrayChildren: Y.fromObject({
                      type: r[1],
                      components: this.components,
                    }),
                    baseType: "array",
                  }
                : {
                    arrayLength: null,
                    arrayChildren: null,
                    baseType: null != this.components ? "tuple" : this.type,
                  },
            ),
              (this._isParamType = !0),
              Object.freeze(this);
          }
          format(e) {
            if (
              (e || (e = Q.sighash),
              Q[e] || q.throwArgumentError("invalid format type", "format", e),
              e === Q.json)
            ) {
              let t = {
                type: "tuple" === this.baseType ? "tuple" : this.type,
                name: this.name || void 0,
              };
              return (
                "boolean" == typeof this.indexed && (t.indexed = this.indexed),
                this.components &&
                  (t.components = this.components.map((t) =>
                    JSON.parse(t.format(e)),
                  )),
                JSON.stringify(t)
              );
            }
            let t = "";
            return (
              "array" === this.baseType
                ? ((t += this.arrayChildren.format(e)),
                  (t +=
                    "[" +
                    (this.arrayLength < 0 ? "" : String(this.arrayLength)) +
                    "]"))
                : "tuple" === this.baseType
                ? (e !== Q.sighash && (t += this.type),
                  (t +=
                    "(" +
                    this.components
                      .map((t) => t.format(e))
                      .join(e === Q.full ? ", " : ",") +
                    ")"))
                : (t += this.type),
              e !== Q.sighash &&
                (!0 === this.indexed && (t += " indexed"),
                e === Q.full && this.name && (t += " " + this.name)),
              t
            );
          }
          static from(e, t) {
            return "string" == typeof e ? Y.fromString(e, t) : Y.fromObject(e);
          }
          static fromObject(e) {
            return Y.isParamType(e)
              ? e
              : new Y(Z, {
                  name: e.name || null,
                  type: ue(e.type),
                  indexed: null == e.indexed ? null : !!e.indexed,
                  components: e.components
                    ? e.components.map(Y.fromObject)
                    : null,
                });
          }
          static fromString(e, t) {
            return (
              (r = (function (e, t) {
                let r = e;
                function n(t) {
                  q.throwArgumentError(
                    `unexpected character at position ${t}`,
                    "param",
                    e,
                  );
                }
                function i(e) {
                  let r = {
                    type: "",
                    name: "",
                    parent: e,
                    state: { allowType: !0 },
                  };
                  return t && (r.indexed = !1), r;
                }
                e = e.replace(/\s/g, " ");
                let s = { type: "", name: "", state: { allowType: !0 } },
                  o = s;
                for (let r = 0; r < e.length; r++) {
                  let s = e[r];
                  switch (s) {
                    case "(":
                      o.state.allowType && "" === o.type
                        ? (o.type = "tuple")
                        : o.state.allowParams || n(r),
                        (o.state.allowType = !1),
                        (o.type = ue(o.type)),
                        (o.components = [i(o)]),
                        (o = o.components[0]);
                      break;
                    case ")":
                      delete o.state,
                        "indexed" === o.name &&
                          (t || n(r), (o.indexed = !0), (o.name = "")),
                        J(o.type, o.name) && (o.name = ""),
                        (o.type = ue(o.type));
                      let e = o;
                      (o = o.parent),
                        o || n(r),
                        delete e.parent,
                        (o.state.allowParams = !1),
                        (o.state.allowName = !0),
                        (o.state.allowArray = !0);
                      break;
                    case ",":
                      delete o.state,
                        "indexed" === o.name &&
                          (t || n(r), (o.indexed = !0), (o.name = "")),
                        J(o.type, o.name) && (o.name = ""),
                        (o.type = ue(o.type));
                      let a = i(o.parent);
                      o.parent.components.push(a), delete o.parent, (o = a);
                      break;
                    case " ":
                      o.state.allowType &&
                        "" !== o.type &&
                        ((o.type = ue(o.type)),
                        delete o.state.allowType,
                        (o.state.allowName = !0),
                        (o.state.allowParams = !0)),
                        o.state.allowName &&
                          "" !== o.name &&
                          ("indexed" === o.name
                            ? (t || n(r),
                              o.indexed && n(r),
                              (o.indexed = !0),
                              (o.name = ""))
                            : J(o.type, o.name)
                            ? (o.name = "")
                            : (o.state.allowName = !1));
                      break;
                    case "[":
                      o.state.allowArray || n(r),
                        (o.type += s),
                        (o.state.allowArray = !1),
                        (o.state.allowName = !1),
                        (o.state.readArray = !0);
                      break;
                    case "]":
                      o.state.readArray || n(r),
                        (o.type += s),
                        (o.state.readArray = !1),
                        (o.state.allowArray = !0),
                        (o.state.allowName = !0);
                      break;
                    default:
                      o.state.allowType
                        ? ((o.type += s),
                          (o.state.allowParams = !0),
                          (o.state.allowArray = !0))
                        : o.state.allowName
                        ? ((o.name += s), delete o.state.allowArray)
                        : o.state.readArray
                        ? (o.type += s)
                        : n(r);
                  }
                }
                return (
                  o.parent &&
                    q.throwArgumentError("unexpected eof", "param", e),
                  delete s.state,
                  "indexed" === o.name
                    ? (t || n(r.length - 7),
                      o.indexed && n(r.length - 7),
                      (o.indexed = !0),
                      (o.name = ""))
                    : J(o.type, o.name) && (o.name = ""),
                  (s.type = ue(s.type)),
                  s
                );
              })(e, !!t)),
              Y.fromObject({
                name: r.name,
                type: r.type,
                indexed: r.indexed,
                components: r.components,
              })
            );
            var r;
          }
          static isParamType(e) {
            return !(null == e || !e._isParamType);
          }
        }
        function ee(e, t) {
          return (function (e) {
            e = e.trim();
            let t = [],
              r = "",
              n = 0;
            for (let i = 0; i < e.length; i++) {
              let s = e[i];
              "," === s && 0 === n
                ? (t.push(r), (r = ""))
                : ((r += s),
                  "(" === s
                    ? n++
                    : ")" === s &&
                      (n--,
                      -1 === n &&
                        q.throwArgumentError(
                          "unbalanced parenthesis",
                          "value",
                          e,
                        )));
            }
            return r && t.push(r), t;
          })(e).map((e) => Y.fromString(e, t));
        }
        class te {
          constructor(e, t) {
            e !== Z &&
              q.throwError(
                "use a static from method",
                p.errors.UNSUPPORTED_OPERATION,
                { operation: "new Fragment()" },
              ),
              X(this, t),
              (this._isFragment = !0),
              Object.freeze(this);
          }
          static from(e) {
            return te.isFragment(e)
              ? e
              : "string" == typeof e
              ? te.fromString(e)
              : te.fromObject(e);
          }
          static fromObject(e) {
            if (te.isFragment(e)) return e;
            switch (e.type) {
              case "function":
                return ae.fromObject(e);
              case "event":
                return re.fromObject(e);
              case "constructor":
                return oe.fromObject(e);
              case "error":
                return de.fromObject(e);
              case "fallback":
              case "receive":
                return null;
            }
            return q.throwArgumentError("invalid fragment object", "value", e);
          }
          static fromString(e) {
            return "event" ===
              (e = (e = (e = e.replace(/\s/g, " "))
                .replace(/\(/g, " (")
                .replace(/\)/g, ") ")
                .replace(/\s+/g, " ")).trim()).split(" ")[0]
              ? re.fromString(e.substring(5).trim())
              : "function" === e.split(" ")[0]
              ? ae.fromString(e.substring(8).trim())
              : "constructor" === e.split("(")[0].trim()
              ? oe.fromString(e.trim())
              : "error" === e.split(" ")[0]
              ? de.fromString(e.substring(5).trim())
              : q.throwArgumentError("unsupported fragment", "value", e);
          }
          static isFragment(e) {
            return !(!e || !e._isFragment);
          }
        }
        class re extends te {
          format(e) {
            if (
              (e || (e = Q.sighash),
              Q[e] || q.throwArgumentError("invalid format type", "format", e),
              e === Q.json)
            )
              return JSON.stringify({
                type: "event",
                anonymous: this.anonymous,
                name: this.name,
                inputs: this.inputs.map((t) => JSON.parse(t.format(e))),
              });
            let t = "";
            return (
              e !== Q.sighash && (t += "event "),
              (t +=
                this.name +
                "(" +
                this.inputs
                  .map((t) => t.format(e))
                  .join(e === Q.full ? ", " : ",") +
                ") "),
              e !== Q.sighash && this.anonymous && (t += "anonymous "),
              t.trim()
            );
          }
          static from(e) {
            return "string" == typeof e ? re.fromString(e) : re.fromObject(e);
          }
          static fromObject(e) {
            if (re.isEventFragment(e)) return e;
            "event" !== e.type &&
              q.throwArgumentError("invalid event object", "value", e);
            const t = {
              name: he(e.name),
              anonymous: e.anonymous,
              inputs: e.inputs ? e.inputs.map(Y.fromObject) : [],
              type: "event",
            };
            return new re(Z, t);
          }
          static fromString(e) {
            let t = e.match(fe);
            t || q.throwArgumentError("invalid event string", "value", e);
            let r = !1;
            return (
              t[3].split(" ").forEach((e) => {
                switch (e.trim()) {
                  case "anonymous":
                    r = !0;
                    break;
                  case "":
                    break;
                  default:
                    q.warn("unknown modifier: " + e);
                }
              }),
              re.fromObject({
                name: t[1].trim(),
                anonymous: r,
                inputs: ee(t[2], !0),
                type: "event",
              })
            );
          }
          static isEventFragment(e) {
            return e && e._isFragment && "event" === e.type;
          }
        }
        function ne(e, t) {
          t.gas = null;
          let r = e.split("@");
          return 1 !== r.length
            ? (r.length > 2 &&
                q.throwArgumentError(
                  "invalid human-readable ABI signature",
                  "value",
                  e,
                ),
              r[1].match(/^[0-9]+$/) ||
                q.throwArgumentError(
                  "invalid human-readable ABI signature gas",
                  "value",
                  e,
                ),
              (t.gas = C.from(r[1])),
              r[0])
            : e;
        }
        function ie(e, t) {
          (t.constant = !1),
            (t.payable = !1),
            (t.stateMutability = "nonpayable"),
            e.split(" ").forEach((e) => {
              switch (e.trim()) {
                case "constant":
                  t.constant = !0;
                  break;
                case "payable":
                  (t.payable = !0), (t.stateMutability = "payable");
                  break;
                case "nonpayable":
                  (t.payable = !1), (t.stateMutability = "nonpayable");
                  break;
                case "pure":
                  (t.constant = !0), (t.stateMutability = "pure");
                  break;
                case "view":
                  (t.constant = !0), (t.stateMutability = "view");
                  break;
                case "external":
                case "public":
                case "":
                  break;
                default:
                  console.log("unknown modifier: " + e);
              }
            });
        }
        function se(e) {
          let t = { constant: !1, payable: !0, stateMutability: "payable" };
          return (
            null != e.stateMutability
              ? ((t.stateMutability = e.stateMutability),
                (t.constant =
                  "view" === t.stateMutability || "pure" === t.stateMutability),
                null != e.constant &&
                  !!e.constant !== t.constant &&
                  q.throwArgumentError(
                    "cannot have constant function with mutability " +
                      t.stateMutability,
                    "value",
                    e,
                  ),
                (t.payable = "payable" === t.stateMutability),
                null != e.payable &&
                  !!e.payable !== t.payable &&
                  q.throwArgumentError(
                    "cannot have payable function with mutability " +
                      t.stateMutability,
                    "value",
                    e,
                  ))
              : null != e.payable
              ? ((t.payable = !!e.payable),
                null != e.constant ||
                  t.payable ||
                  "constructor" === e.type ||
                  q.throwArgumentError(
                    "unable to determine stateMutability",
                    "value",
                    e,
                  ),
                (t.constant = !!e.constant),
                t.constant
                  ? (t.stateMutability = "view")
                  : (t.stateMutability = t.payable ? "payable" : "nonpayable"),
                t.payable &&
                  t.constant &&
                  q.throwArgumentError(
                    "cannot have constant payable function",
                    "value",
                    e,
                  ))
              : null != e.constant
              ? ((t.constant = !!e.constant),
                (t.payable = !t.constant),
                (t.stateMutability = t.constant ? "view" : "payable"))
              : "constructor" !== e.type &&
                q.throwArgumentError(
                  "unable to determine stateMutability",
                  "value",
                  e,
                ),
            t
          );
        }
        class oe extends te {
          format(e) {
            if (
              (e || (e = Q.sighash),
              Q[e] || q.throwArgumentError("invalid format type", "format", e),
              e === Q.json)
            )
              return JSON.stringify({
                type: "constructor",
                stateMutability:
                  "nonpayable" !== this.stateMutability
                    ? this.stateMutability
                    : void 0,
                payable: this.payable,
                gas: this.gas ? this.gas.toNumber() : void 0,
                inputs: this.inputs.map((t) => JSON.parse(t.format(e))),
              });
            e === Q.sighash &&
              q.throwError(
                "cannot format a constructor for sighash",
                p.errors.UNSUPPORTED_OPERATION,
                { operation: "format(sighash)" },
              );
            let t =
              "constructor(" +
              this.inputs
                .map((t) => t.format(e))
                .join(e === Q.full ? ", " : ",") +
              ") ";
            return (
              this.stateMutability &&
                "nonpayable" !== this.stateMutability &&
                (t += this.stateMutability + " "),
              t.trim()
            );
          }
          static from(e) {
            return "string" == typeof e ? oe.fromString(e) : oe.fromObject(e);
          }
          static fromObject(e) {
            if (oe.isConstructorFragment(e)) return e;
            "constructor" !== e.type &&
              q.throwArgumentError("invalid constructor object", "value", e);
            let t = se(e);
            t.constant &&
              q.throwArgumentError(
                "constructor cannot be constant",
                "value",
                e,
              );
            const r = {
              name: null,
              type: e.type,
              inputs: e.inputs ? e.inputs.map(Y.fromObject) : [],
              payable: t.payable,
              stateMutability: t.stateMutability,
              gas: e.gas ? C.from(e.gas) : null,
            };
            return new oe(Z, r);
          }
          static fromString(e) {
            let t = { type: "constructor" },
              r = (e = ne(e, t)).match(fe);
            return (
              (r && "constructor" === r[1].trim()) ||
                q.throwArgumentError("invalid constructor string", "value", e),
              (t.inputs = ee(r[2].trim(), !1)),
              ie(r[3].trim(), t),
              oe.fromObject(t)
            );
          }
          static isConstructorFragment(e) {
            return e && e._isFragment && "constructor" === e.type;
          }
        }
        class ae extends oe {
          format(e) {
            if (
              (e || (e = Q.sighash),
              Q[e] || q.throwArgumentError("invalid format type", "format", e),
              e === Q.json)
            )
              return JSON.stringify({
                type: "function",
                name: this.name,
                constant: this.constant,
                stateMutability:
                  "nonpayable" !== this.stateMutability
                    ? this.stateMutability
                    : void 0,
                payable: this.payable,
                gas: this.gas ? this.gas.toNumber() : void 0,
                inputs: this.inputs.map((t) => JSON.parse(t.format(e))),
                outputs: this.outputs.map((t) => JSON.parse(t.format(e))),
              });
            let t = "";
            return (
              e !== Q.sighash && (t += "function "),
              (t +=
                this.name +
                "(" +
                this.inputs
                  .map((t) => t.format(e))
                  .join(e === Q.full ? ", " : ",") +
                ") "),
              e !== Q.sighash &&
                (this.stateMutability
                  ? "nonpayable" !== this.stateMutability &&
                    (t += this.stateMutability + " ")
                  : this.constant && (t += "view "),
                this.outputs &&
                  this.outputs.length &&
                  (t +=
                    "returns (" +
                    this.outputs.map((t) => t.format(e)).join(", ") +
                    ") "),
                null != this.gas && (t += "@" + this.gas.toString() + " ")),
              t.trim()
            );
          }
          static from(e) {
            return "string" == typeof e ? ae.fromString(e) : ae.fromObject(e);
          }
          static fromObject(e) {
            if (ae.isFunctionFragment(e)) return e;
            "function" !== e.type &&
              q.throwArgumentError("invalid function object", "value", e);
            let t = se(e);
            const r = {
              type: e.type,
              name: he(e.name),
              constant: t.constant,
              inputs: e.inputs ? e.inputs.map(Y.fromObject) : [],
              outputs: e.outputs ? e.outputs.map(Y.fromObject) : [],
              payable: t.payable,
              stateMutability: t.stateMutability,
              gas: e.gas ? C.from(e.gas) : null,
            };
            return new ae(Z, r);
          }
          static fromString(e) {
            let t = { type: "function" },
              r = (e = ne(e, t)).split(" returns ");
            r.length > 2 &&
              q.throwArgumentError("invalid function string", "value", e);
            let n = r[0].match(fe);
            if (
              (n ||
                q.throwArgumentError("invalid function signature", "value", e),
              (t.name = n[1].trim()),
              t.name && he(t.name),
              (t.inputs = ee(n[2], !1)),
              ie(n[3].trim(), t),
              r.length > 1)
            ) {
              let n = r[1].match(fe);
              ("" == n[1].trim() && "" == n[3].trim()) ||
                q.throwArgumentError("unexpected tokens", "value", e),
                (t.outputs = ee(n[2], !1));
            } else t.outputs = [];
            return ae.fromObject(t);
          }
          static isFunctionFragment(e) {
            return e && e._isFragment && "function" === e.type;
          }
        }
        function ce(e) {
          const t = e.format();
          return (
            ("Error(string)" !== t && "Panic(uint256)" !== t) ||
              q.throwArgumentError(
                `cannot specify user defined ${t} error`,
                "fragment",
                e,
              ),
            e
          );
        }
        class de extends te {
          format(e) {
            if (
              (e || (e = Q.sighash),
              Q[e] || q.throwArgumentError("invalid format type", "format", e),
              e === Q.json)
            )
              return JSON.stringify({
                type: "error",
                name: this.name,
                inputs: this.inputs.map((t) => JSON.parse(t.format(e))),
              });
            let t = "";
            return (
              e !== Q.sighash && (t += "error "),
              (t +=
                this.name +
                "(" +
                this.inputs
                  .map((t) => t.format(e))
                  .join(e === Q.full ? ", " : ",") +
                ") "),
              t.trim()
            );
          }
          static from(e) {
            return "string" == typeof e ? de.fromString(e) : de.fromObject(e);
          }
          static fromObject(e) {
            if (de.isErrorFragment(e)) return e;
            "error" !== e.type &&
              q.throwArgumentError("invalid error object", "value", e);
            const t = {
              type: e.type,
              name: he(e.name),
              inputs: e.inputs ? e.inputs.map(Y.fromObject) : [],
            };
            return ce(new de(Z, t));
          }
          static fromString(e) {
            let t = { type: "error" },
              r = e.match(fe);
            return (
              r || q.throwArgumentError("invalid error signature", "value", e),
              (t.name = r[1].trim()),
              t.name && he(t.name),
              (t.inputs = ee(r[2], !1)),
              ce(de.fromObject(t))
            );
          }
          static isErrorFragment(e) {
            return e && e._isFragment && "error" === e.type;
          }
        }
        function ue(e) {
          return (
            e.match(/^uint($|[^1-9])/)
              ? (e = "uint256" + e.substring(4))
              : e.match(/^int($|[^1-9])/) && (e = "int256" + e.substring(3)),
            e
          );
        }
        const le = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
        function he(e) {
          return (
            (e && e.match(le)) ||
              q.throwArgumentError(`invalid identifier "${e}"`, "value", e),
            e
          );
        }
        const fe = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$"),
          pe = new p(W);
        function me(e) {
          const t = [],
            r = function (e, n) {
              if (Array.isArray(n))
                for (let i in n) {
                  const s = e.slice();
                  s.push(i);
                  try {
                    r(s, n[i]);
                  } catch (e) {
                    t.push({ path: s, error: e });
                  }
                }
            };
          return r([], e), t;
        }
        class ye {
          constructor(e, t, r, n) {
            (this.name = e),
              (this.type = t),
              (this.localName = r),
              (this.dynamic = n);
          }
          _throwError(e, t) {
            pe.throwArgumentError(e, this.localName, t);
          }
        }
        class ge {
          constructor(e) {
            j(this, "wordSize", e || 32),
              (this._data = []),
              (this._dataLength = 0),
              (this._padding = new Uint8Array(e));
          }
          get data() {
            return (function (e) {
              let t = "0x";
              return (
                e.forEach((e) => {
                  t += T(e).substring(2);
                }),
                t
              );
            })(this._data);
          }
          get length() {
            return this._dataLength;
          }
          _writeData(e) {
            return this._data.push(e), (this._dataLength += e.length), e.length;
          }
          appendWriter(e) {
            return this._writeData(E(e._data));
          }
          writeBytes(e) {
            let t = w(e);
            const r = t.length % this.wordSize;
            return (
              r && (t = E([t, this._padding.slice(r)])), this._writeData(t)
            );
          }
          _getValue(e) {
            let t = w(C.from(e));
            return (
              t.length > this.wordSize &&
                pe.throwError("value out-of-bounds", p.errors.BUFFER_OVERRUN, {
                  length: this.wordSize,
                  offset: t.length,
                }),
              t.length % this.wordSize &&
                (t = E([this._padding.slice(t.length % this.wordSize), t])),
              t
            );
          }
          writeValue(e) {
            return this._writeData(this._getValue(e));
          }
          writeUpdatableValue() {
            const e = this._data.length;
            return (
              this._data.push(this._padding),
              (this._dataLength += this.wordSize),
              (t) => {
                this._data[e] = this._getValue(t);
              }
            );
          }
        }
        class ve {
          constructor(e, t, r, n) {
            j(this, "_data", w(e)),
              j(this, "wordSize", t || 32),
              j(this, "_coerceFunc", r),
              j(this, "allowLoose", n),
              (this._offset = 0);
          }
          get data() {
            return T(this._data);
          }
          get consumed() {
            return this._offset;
          }
          static coerce(e, t) {
            let r = e.match("^u?int([0-9]+)$");
            return r && parseInt(r[1]) <= 48 && (t = t.toNumber()), t;
          }
          coerce(e, t) {
            return this._coerceFunc ? this._coerceFunc(e, t) : ve.coerce(e, t);
          }
          _peekBytes(e, t, r) {
            let n = Math.ceil(t / this.wordSize) * this.wordSize;
            return (
              this._offset + n > this._data.length &&
                (this.allowLoose && r && this._offset + t <= this._data.length
                  ? (n = t)
                  : pe.throwError(
                      "data out-of-bounds",
                      p.errors.BUFFER_OVERRUN,
                      { length: this._data.length, offset: this._offset + n },
                    )),
              this._data.slice(this._offset, this._offset + n)
            );
          }
          subReader(e) {
            return new ve(
              this._data.slice(this._offset + e),
              this.wordSize,
              this._coerceFunc,
              this.allowLoose,
            );
          }
          readBytes(e, t) {
            let r = this._peekBytes(0, e, !!t);
            return (this._offset += r.length), r.slice(0, e);
          }
          readValue() {
            return C.from(this.readBytes(this.wordSize));
          }
        }
        var be = r(1094),
          we = r.n(be);
        function Ee(e) {
          return "0x" + we().keccak_256(w(e));
        }
        const Ae = new p("address/5.7.0");
        function _e(e) {
          A(e, 20) || Ae.throwArgumentError("invalid address", "address", e);
          const t = (e = e.toLowerCase()).substring(2).split(""),
            r = new Uint8Array(40);
          for (let e = 0; e < 40; e++) r[e] = t[e].charCodeAt(0);
          const n = w(Ee(r));
          for (let e = 0; e < 40; e += 2)
            n[e >> 1] >> 4 >= 8 && (t[e] = t[e].toUpperCase()),
              (15 & n[e >> 1]) >= 8 && (t[e + 1] = t[e + 1].toUpperCase());
          return "0x" + t.join("");
        }
        const Te = {};
        for (let e = 0; e < 10; e++) Te[String(e)] = String(e);
        for (let e = 0; e < 26; e++)
          Te[String.fromCharCode(65 + e)] = String(10 + e);
        const Re = Math.floor(
          ((Ie = 9007199254740991),
          Math.log10 ? Math.log10(Ie) : Math.log(Ie) / Math.LN10),
        );
        var Ie;
        function Se(e) {
          let t = null;
          if (
            ("string" != typeof e &&
              Ae.throwArgumentError("invalid address", "address", e),
            e.match(/^(0x)?[0-9a-fA-F]{40}$/))
          )
            "0x" !== e.substring(0, 2) && (e = "0x" + e),
              (t = _e(e)),
              e.match(/([A-F].*[a-f])|([a-f].*[A-F])/) &&
                t !== e &&
                Ae.throwArgumentError("bad address checksum", "address", e);
          else if (e.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
            for (
              e.substring(2, 4) !==
                (function (e) {
                  let t = (e =
                    (e = e.toUpperCase()).substring(4) +
                    e.substring(0, 2) +
                    "00")
                    .split("")
                    .map((e) => Te[e])
                    .join("");
                  for (; t.length >= Re; ) {
                    let e = t.substring(0, Re);
                    t = (parseInt(e, 10) % 97) + t.substring(e.length);
                  }
                  let r = String(98 - (parseInt(t, 10) % 97));
                  for (; r.length < 2; ) r = "0" + r;
                  return r;
                })(e) &&
                Ae.throwArgumentError("bad icap checksum", "address", e),
                r = e.substring(4),
                t = new I(r, 36).toString(16);
              t.length < 40;

            )
              t = "0" + t;
            t = _e("0x" + t);
          } else Ae.throwArgumentError("invalid address", "address", e);
          var r;
          return t;
        }
        class xe extends ye {
          constructor(e) {
            super("address", "address", e, !1);
          }
          defaultValue() {
            return "0x0000000000000000000000000000000000000000";
          }
          encode(e, t) {
            try {
              t = Se(t);
            } catch (e) {
              this._throwError(e.message, t);
            }
            return e.writeValue(t);
          }
          decode(e) {
            return Se(R(e.readValue().toHexString(), 20));
          }
        }
        class Pe extends ye {
          constructor(e) {
            super(e.name, e.type, void 0, e.dynamic), (this.coder = e);
          }
          defaultValue() {
            return this.coder.defaultValue();
          }
          encode(e, t) {
            return this.coder.encode(e, t);
          }
          decode(e) {
            return this.coder.decode(e);
          }
        }
        const Oe = new p(W);
        function Ce(e, t, r) {
          let n = null;
          if (Array.isArray(r)) n = r;
          else if (r && "object" == typeof r) {
            let e = {};
            n = t.map((t) => {
              const n = t.localName;
              return (
                n ||
                  Oe.throwError(
                    "cannot encode object for signature with missing names",
                    p.errors.INVALID_ARGUMENT,
                    { argument: "values", coder: t, value: r },
                  ),
                e[n] &&
                  Oe.throwError(
                    "cannot encode object for signature with duplicate names",
                    p.errors.INVALID_ARGUMENT,
                    { argument: "values", coder: t, value: r },
                  ),
                (e[n] = !0),
                r[n]
              );
            });
          } else Oe.throwArgumentError("invalid tuple value", "tuple", r);
          t.length !== n.length &&
            Oe.throwArgumentError("types/value length mismatch", "tuple", r);
          let i = new ge(e.wordSize),
            s = new ge(e.wordSize),
            o = [];
          t.forEach((e, t) => {
            let r = n[t];
            if (e.dynamic) {
              let t = s.length;
              e.encode(s, r);
              let n = i.writeUpdatableValue();
              o.push((e) => {
                n(e + t);
              });
            } else e.encode(i, r);
          }),
            o.forEach((e) => {
              e(i.length);
            });
          let a = e.appendWriter(i);
          return (a += e.appendWriter(s)), a;
        }
        function ke(e, t) {
          let r = [],
            n = e.subReader(0);
          t.forEach((t) => {
            let i = null;
            if (t.dynamic) {
              let r = e.readValue(),
                s = n.subReader(r.toNumber());
              try {
                i = t.decode(s);
              } catch (e) {
                if (e.code === p.errors.BUFFER_OVERRUN) throw e;
                (i = e),
                  (i.baseType = t.name),
                  (i.name = t.localName),
                  (i.type = t.type);
              }
            } else
              try {
                i = t.decode(e);
              } catch (e) {
                if (e.code === p.errors.BUFFER_OVERRUN) throw e;
                (i = e),
                  (i.baseType = t.name),
                  (i.name = t.localName),
                  (i.type = t.type);
              }
            null != i && r.push(i);
          });
          const i = t.reduce((e, t) => {
            const r = t.localName;
            return r && (e[r] || (e[r] = 0), e[r]++), e;
          }, {});
          t.forEach((e, t) => {
            let n = e.localName;
            if (!n || 1 !== i[n]) return;
            if (("length" === n && (n = "_length"), null != r[n])) return;
            const s = r[t];
            s instanceof Error
              ? Object.defineProperty(r, n, {
                  enumerable: !0,
                  get: () => {
                    throw s;
                  },
                })
              : (r[n] = s);
          });
          for (let e = 0; e < r.length; e++) {
            const t = r[e];
            t instanceof Error &&
              Object.defineProperty(r, e, {
                enumerable: !0,
                get: () => {
                  throw t;
                },
              });
          }
          return Object.freeze(r);
        }
        class Me extends ye {
          constructor(e, t, r) {
            super(
              "array",
              e.type + "[" + (t >= 0 ? t : "") + "]",
              r,
              -1 === t || e.dynamic,
            ),
              (this.coder = e),
              (this.length = t);
          }
          defaultValue() {
            const e = this.coder.defaultValue(),
              t = [];
            for (let r = 0; r < this.length; r++) t.push(e);
            return t;
          }
          encode(e, t) {
            Array.isArray(t) || this._throwError("expected array value", t);
            let r = this.length;
            -1 === r && ((r = t.length), e.writeValue(t.length)),
              Oe.checkArgumentCount(
                t.length,
                r,
                "coder array" + (this.localName ? " " + this.localName : ""),
              );
            let n = [];
            for (let e = 0; e < t.length; e++) n.push(this.coder);
            return Ce(e, n, t);
          }
          decode(e) {
            let t = this.length;
            -1 === t &&
              ((t = e.readValue().toNumber()),
              32 * t > e._data.length &&
                Oe.throwError(
                  "insufficient data length",
                  p.errors.BUFFER_OVERRUN,
                  { length: e._data.length, count: t },
                ));
            let r = [];
            for (let e = 0; e < t; e++) r.push(new Pe(this.coder));
            return e.coerce(this.name, ke(e, r));
          }
        }
        class Ne extends ye {
          constructor(e) {
            super("bool", "bool", e, !1);
          }
          defaultValue() {
            return !1;
          }
          encode(e, t) {
            return e.writeValue(t ? 1 : 0);
          }
          decode(e) {
            return e.coerce(this.type, !e.readValue().isZero());
          }
        }
        class Be extends ye {
          constructor(e, t) {
            super(e, e, t, !0);
          }
          defaultValue() {
            return "0x";
          }
          encode(e, t) {
            t = w(t);
            let r = e.writeValue(t.length);
            return (r += e.writeBytes(t)), r;
          }
          decode(e) {
            return e.readBytes(e.readValue().toNumber(), !0);
          }
        }
        class De extends Be {
          constructor(e) {
            super("bytes", e);
          }
          decode(e) {
            return e.coerce(this.name, T(super.decode(e)));
          }
        }
        class je extends ye {
          constructor(e, t) {
            let r = "bytes" + String(e);
            super(r, r, t, !1), (this.size = e);
          }
          defaultValue() {
            return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(
              0,
              2 + 2 * this.size,
            );
          }
          encode(e, t) {
            let r = w(t);
            return (
              r.length !== this.size &&
                this._throwError("incorrect data length", t),
              e.writeBytes(r)
            );
          }
          decode(e) {
            return e.coerce(this.name, T(e.readBytes(this.size)));
          }
        }
        class Le extends ye {
          constructor(e) {
            super("null", "", e, !1);
          }
          defaultValue() {
            return null;
          }
          encode(e, t) {
            return (
              null != t && this._throwError("not null", t), e.writeBytes([])
            );
          }
          decode(e) {
            return e.readBytes(0), e.coerce(this.name, null);
          }
        }
        const Ue = C.from(-1),
          Fe = C.from(0),
          He = C.from(1),
          Ge = C.from(
            "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
          );
        class Ve extends ye {
          constructor(e, t, r) {
            const n = (t ? "int" : "uint") + 8 * e;
            super(n, n, r, !1), (this.size = e), (this.signed = t);
          }
          defaultValue() {
            return 0;
          }
          encode(e, t) {
            let r = C.from(t),
              n = Ge.mask(8 * e.wordSize);
            if (this.signed) {
              let e = n.mask(8 * this.size - 1);
              (r.gt(e) || r.lt(e.add(He).mul(Ue))) &&
                this._throwError("value out-of-bounds", t);
            } else
              (r.lt(Fe) || r.gt(n.mask(8 * this.size))) &&
                this._throwError("value out-of-bounds", t);
            return (
              (r = r.toTwos(8 * this.size).mask(8 * this.size)),
              this.signed &&
                (r = r.fromTwos(8 * this.size).toTwos(8 * e.wordSize)),
              e.writeValue(r)
            );
          }
          decode(e) {
            let t = e.readValue().mask(8 * this.size);
            return (
              this.signed && (t = t.fromTwos(8 * this.size)),
              e.coerce(this.name, t)
            );
          }
        }
        const We = new p("strings/5.7.0");
        var qe, Ze;
        function ze(e, t, r, n, i) {
          if (e === Ze.BAD_PREFIX || e === Ze.UNEXPECTED_CONTINUE) {
            let e = 0;
            for (let n = t + 1; n < r.length && r[n] >> 6 == 2; n++) e++;
            return e;
          }
          return e === Ze.OVERRUN ? r.length - t - 1 : 0;
        }
        !(function (e) {
          (e.current = ""),
            (e.NFC = "NFC"),
            (e.NFD = "NFD"),
            (e.NFKC = "NFKC"),
            (e.NFKD = "NFKD");
        })(qe || (qe = {})),
          (function (e) {
            (e.UNEXPECTED_CONTINUE = "unexpected continuation byte"),
              (e.BAD_PREFIX = "bad codepoint prefix"),
              (e.OVERRUN = "string overrun"),
              (e.MISSING_CONTINUE = "missing continuation byte"),
              (e.OUT_OF_RANGE = "out of UTF-8 range"),
              (e.UTF16_SURROGATE = "UTF-16 surrogate"),
              (e.OVERLONG = "overlong representation");
          })(Ze || (Ze = {}));
        const Ke = Object.freeze({
          error: function (e, t, r, n, i) {
            return We.throwArgumentError(
              `invalid codepoint at offset ${t}; ${e}`,
              "bytes",
              r,
            );
          },
          ignore: ze,
          replace: function (e, t, r, n, i) {
            return e === Ze.OVERLONG
              ? (n.push(i), 0)
              : (n.push(65533), ze(e, t, r));
          },
        });
        function Je(e, t = qe.current) {
          t != qe.current && (We.checkNormalize(), (e = e.normalize(t)));
          let r = [];
          for (let t = 0; t < e.length; t++) {
            const n = e.charCodeAt(t);
            if (n < 128) r.push(n);
            else if (n < 2048) r.push((n >> 6) | 192), r.push((63 & n) | 128);
            else if (55296 == (64512 & n)) {
              t++;
              const i = e.charCodeAt(t);
              if (t >= e.length || 56320 != (64512 & i))
                throw new Error("invalid utf-8 string");
              const s = 65536 + ((1023 & n) << 10) + (1023 & i);
              r.push((s >> 18) | 240),
                r.push(((s >> 12) & 63) | 128),
                r.push(((s >> 6) & 63) | 128),
                r.push((63 & s) | 128);
            } else
              r.push((n >> 12) | 224),
                r.push(((n >> 6) & 63) | 128),
                r.push((63 & n) | 128);
          }
          return w(r);
        }
        function Xe(e, t) {
          return (function (e, t) {
            null == t && (t = Ke.error), (e = w(e));
            const r = [];
            let n = 0;
            for (; n < e.length; ) {
              const i = e[n++];
              if (i >> 7 == 0) {
                r.push(i);
                continue;
              }
              let s = null,
                o = null;
              if (192 == (224 & i)) (s = 1), (o = 127);
              else if (224 == (240 & i)) (s = 2), (o = 2047);
              else {
                if (240 != (248 & i)) {
                  n += t(
                    128 == (192 & i) ? Ze.UNEXPECTED_CONTINUE : Ze.BAD_PREFIX,
                    n - 1,
                    e,
                    r,
                  );
                  continue;
                }
                (s = 3), (o = 65535);
              }
              if (n - 1 + s >= e.length) {
                n += t(Ze.OVERRUN, n - 1, e, r);
                continue;
              }
              let a = i & ((1 << (8 - s - 1)) - 1);
              for (let i = 0; i < s; i++) {
                let i = e[n];
                if (128 != (192 & i)) {
                  (n += t(Ze.MISSING_CONTINUE, n, e, r)), (a = null);
                  break;
                }
                (a = (a << 6) | (63 & i)), n++;
              }
              null !== a &&
                (a > 1114111
                  ? (n += t(Ze.OUT_OF_RANGE, n - 1 - s, e, r, a))
                  : a >= 55296 && a <= 57343
                  ? (n += t(Ze.UTF16_SURROGATE, n - 1 - s, e, r, a))
                  : a <= o
                  ? (n += t(Ze.OVERLONG, n - 1 - s, e, r, a))
                  : r.push(a));
            }
            return r;
          })(e, t)
            .map((e) =>
              e <= 65535
                ? String.fromCharCode(e)
                : ((e -= 65536),
                  String.fromCharCode(
                    55296 + ((e >> 10) & 1023),
                    56320 + (1023 & e),
                  )),
            )
            .join("");
        }
        class Qe extends Be {
          constructor(e) {
            super("string", e);
          }
          defaultValue() {
            return "";
          }
          encode(e, t) {
            return super.encode(e, Je(t));
          }
          decode(e) {
            return Xe(super.decode(e));
          }
        }
        class $e extends ye {
          constructor(e, t) {
            let r = !1;
            const n = [];
            e.forEach((e) => {
              e.dynamic && (r = !0), n.push(e.type);
            }),
              super("tuple", "tuple(" + n.join(",") + ")", t, r),
              (this.coders = e);
          }
          defaultValue() {
            const e = [];
            this.coders.forEach((t) => {
              e.push(t.defaultValue());
            });
            const t = this.coders.reduce((e, t) => {
              const r = t.localName;
              return r && (e[r] || (e[r] = 0), e[r]++), e;
            }, {});
            return (
              this.coders.forEach((r, n) => {
                let i = r.localName;
                i &&
                  1 === t[i] &&
                  ("length" === i && (i = "_length"),
                  null == e[i] && (e[i] = e[n]));
              }),
              Object.freeze(e)
            );
          }
          encode(e, t) {
            return Ce(e, this.coders, t);
          }
          decode(e) {
            return e.coerce(this.name, ke(e, this.coders));
          }
        }
        const Ye = new p(W),
          et = new RegExp(/^bytes([0-9]*)$/),
          tt = new RegExp(/^(u?int)([0-9]*)$/);
        class rt {
          constructor(e) {
            j(this, "coerceFunc", e || null);
          }
          _getCoder(e) {
            switch (e.baseType) {
              case "address":
                return new xe(e.name);
              case "bool":
                return new Ne(e.name);
              case "string":
                return new Qe(e.name);
              case "bytes":
                return new De(e.name);
              case "array":
                return new Me(
                  this._getCoder(e.arrayChildren),
                  e.arrayLength,
                  e.name,
                );
              case "tuple":
                return new $e(
                  (e.components || []).map((e) => this._getCoder(e)),
                  e.name,
                );
              case "":
                return new Le(e.name);
            }
            let t = e.type.match(tt);
            if (t) {
              let r = parseInt(t[2] || "256");
              return (
                (0 === r || r > 256 || r % 8 != 0) &&
                  Ye.throwArgumentError(
                    "invalid " + t[1] + " bit length",
                    "param",
                    e,
                  ),
                new Ve(r / 8, "int" === t[1], e.name)
              );
            }
            if (((t = e.type.match(et)), t)) {
              let r = parseInt(t[1]);
              return (
                (0 === r || r > 32) &&
                  Ye.throwArgumentError("invalid bytes length", "param", e),
                new je(r, e.name)
              );
            }
            return Ye.throwArgumentError("invalid type", "type", e.type);
          }
          _getWordSize() {
            return 32;
          }
          _getReader(e, t) {
            return new ve(e, this._getWordSize(), this.coerceFunc, t);
          }
          _getWriter() {
            return new ge(this._getWordSize());
          }
          getDefaultValue(e) {
            const t = e.map((e) => this._getCoder(Y.from(e)));
            return new $e(t, "_").defaultValue();
          }
          encode(e, t) {
            e.length !== t.length &&
              Ye.throwError(
                "types/values length mismatch",
                p.errors.INVALID_ARGUMENT,
                {
                  count: { types: e.length, values: t.length },
                  value: { types: e, values: t },
                },
              );
            const r = e.map((e) => this._getCoder(Y.from(e))),
              n = new $e(r, "_"),
              i = this._getWriter();
            return n.encode(i, t), i.data;
          }
          decode(e, t, r) {
            const n = e.map((e) => this._getCoder(Y.from(e)));
            return new $e(n, "_").decode(this._getReader(w(t), r));
          }
        }
        const nt = new rt();
        function it(e) {
          return Ee(Je(e));
        }
        const st = new p(W);
        class ot extends V {}
        class at extends V {}
        class ct extends V {}
        class dt extends V {
          static isIndexed(e) {
            return !(!e || !e._isIndexed);
          }
        }
        const ut = {
          "0x08c379a0": {
            signature: "Error(string)",
            name: "Error",
            inputs: ["string"],
            reason: !0,
          },
          "0x4e487b71": {
            signature: "Panic(uint256)",
            name: "Panic",
            inputs: ["uint256"],
          },
        };
        function lt(e, t) {
          const r = new Error(
            `deferred error during ABI decoding triggered accessing ${e}`,
          );
          return (r.error = t), r;
        }
        class ht {
          constructor(e) {
            let t = [];
            (t = "string" == typeof e ? JSON.parse(e) : e),
              j(
                this,
                "fragments",
                t.map((e) => te.from(e)).filter((e) => null != e),
              ),
              j(this, "_abiCoder", L(new.target, "getAbiCoder")()),
              j(this, "functions", {}),
              j(this, "errors", {}),
              j(this, "events", {}),
              j(this, "structs", {}),
              this.fragments.forEach((e) => {
                let t = null;
                switch (e.type) {
                  case "constructor":
                    return this.deploy
                      ? void st.warn("duplicate definition - constructor")
                      : void j(this, "deploy", e);
                  case "function":
                    t = this.functions;
                    break;
                  case "event":
                    t = this.events;
                    break;
                  case "error":
                    t = this.errors;
                    break;
                  default:
                    return;
                }
                let r = e.format();
                t[r] ? st.warn("duplicate definition - " + r) : (t[r] = e);
              }),
              this.deploy ||
                j(
                  this,
                  "deploy",
                  oe.from({ payable: !1, type: "constructor" }),
                ),
              j(this, "_isInterface", !0);
          }
          format(e) {
            e || (e = Q.full),
              e === Q.sighash &&
                st.throwArgumentError(
                  "interface does not support formatting sighash",
                  "format",
                  e,
                );
            const t = this.fragments.map((t) => t.format(e));
            return e === Q.json
              ? JSON.stringify(t.map((e) => JSON.parse(e)))
              : t;
          }
          static getAbiCoder() {
            return nt;
          }
          static getAddress(e) {
            return Se(e);
          }
          static getSighash(e) {
            return (
              (r = 0),
              4,
              "string" != typeof (t = it(e.format()))
                ? (t = T(t))
                : (!A(t) || t.length % 2) &&
                  m.throwArgumentError("invalid hexData", "value", t),
              (r = 2 + 2 * r),
              "0x" + t.substring(r, 10)
            );
            var t, r;
          }
          static getEventTopic(e) {
            return it(e.format());
          }
          getFunction(e) {
            if (A(e)) {
              for (const t in this.functions)
                if (e === this.getSighash(t)) return this.functions[t];
              st.throwArgumentError("no matching function", "sighash", e);
            }
            if (-1 === e.indexOf("(")) {
              const t = e.trim(),
                r = Object.keys(this.functions).filter(
                  (e) => e.split("(")[0] === t,
                );
              return (
                0 === r.length
                  ? st.throwArgumentError("no matching function", "name", t)
                  : r.length > 1 &&
                    st.throwArgumentError(
                      "multiple matching functions",
                      "name",
                      t,
                    ),
                this.functions[r[0]]
              );
            }
            const t = this.functions[ae.fromString(e).format()];
            return (
              t ||
                st.throwArgumentError("no matching function", "signature", e),
              t
            );
          }
          getEvent(e) {
            if (A(e)) {
              const t = e.toLowerCase();
              for (const e in this.events)
                if (t === this.getEventTopic(e)) return this.events[e];
              st.throwArgumentError("no matching event", "topichash", t);
            }
            if (-1 === e.indexOf("(")) {
              const t = e.trim(),
                r = Object.keys(this.events).filter(
                  (e) => e.split("(")[0] === t,
                );
              return (
                0 === r.length
                  ? st.throwArgumentError("no matching event", "name", t)
                  : r.length > 1 &&
                    st.throwArgumentError(
                      "multiple matching events",
                      "name",
                      t,
                    ),
                this.events[r[0]]
              );
            }
            const t = this.events[re.fromString(e).format()];
            return (
              t || st.throwArgumentError("no matching event", "signature", e), t
            );
          }
          getError(e) {
            if (A(e)) {
              const t = L(this.constructor, "getSighash");
              for (const r in this.errors)
                if (e === t(this.errors[r])) return this.errors[r];
              st.throwArgumentError("no matching error", "sighash", e);
            }
            if (-1 === e.indexOf("(")) {
              const t = e.trim(),
                r = Object.keys(this.errors).filter(
                  (e) => e.split("(")[0] === t,
                );
              return (
                0 === r.length
                  ? st.throwArgumentError("no matching error", "name", t)
                  : r.length > 1 &&
                    st.throwArgumentError(
                      "multiple matching errors",
                      "name",
                      t,
                    ),
                this.errors[r[0]]
              );
            }
            const t = this.errors[ae.fromString(e).format()];
            return (
              t || st.throwArgumentError("no matching error", "signature", e), t
            );
          }
          getSighash(e) {
            if ("string" == typeof e)
              try {
                e = this.getFunction(e);
              } catch (t) {
                try {
                  e = this.getError(e);
                } catch (e) {
                  throw t;
                }
              }
            return L(this.constructor, "getSighash")(e);
          }
          getEventTopic(e) {
            return (
              "string" == typeof e && (e = this.getEvent(e)),
              L(this.constructor, "getEventTopic")(e)
            );
          }
          _decodeParams(e, t) {
            return this._abiCoder.decode(e, t);
          }
          _encodeParams(e, t) {
            return this._abiCoder.encode(e, t);
          }
          encodeDeploy(e) {
            return this._encodeParams(this.deploy.inputs, e || []);
          }
          decodeErrorResult(e, t) {
            "string" == typeof e && (e = this.getError(e));
            const r = w(t);
            return (
              T(r.slice(0, 4)) !== this.getSighash(e) &&
                st.throwArgumentError(
                  `data signature does not match error ${e.name}.`,
                  "data",
                  T(r),
                ),
              this._decodeParams(e.inputs, r.slice(4))
            );
          }
          encodeErrorResult(e, t) {
            return (
              "string" == typeof e && (e = this.getError(e)),
              T(E([this.getSighash(e), this._encodeParams(e.inputs, t || [])]))
            );
          }
          decodeFunctionData(e, t) {
            "string" == typeof e && (e = this.getFunction(e));
            const r = w(t);
            return (
              T(r.slice(0, 4)) !== this.getSighash(e) &&
                st.throwArgumentError(
                  `data signature does not match function ${e.name}.`,
                  "data",
                  T(r),
                ),
              this._decodeParams(e.inputs, r.slice(4))
            );
          }
          encodeFunctionData(e, t) {
            return (
              "string" == typeof e && (e = this.getFunction(e)),
              T(E([this.getSighash(e), this._encodeParams(e.inputs, t || [])]))
            );
          }
          decodeFunctionResult(e, t) {
            "string" == typeof e && (e = this.getFunction(e));
            let r = w(t),
              n = null,
              i = "",
              s = null,
              o = null,
              a = null;
            switch (r.length % this._abiCoder._getWordSize()) {
              case 0:
                try {
                  return this._abiCoder.decode(e.outputs, r);
                } catch (e) {}
                break;
              case 4: {
                const e = T(r.slice(0, 4)),
                  t = ut[e];
                if (t)
                  (s = this._abiCoder.decode(t.inputs, r.slice(4))),
                    (o = t.name),
                    (a = t.signature),
                    t.reason && (n = s[0]),
                    "Error" === o
                      ? (i = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(
                          s[0],
                        )}`)
                      : "Panic" === o &&
                        (i = `; VM Exception while processing transaction: reverted with panic code ${s[0]}`);
                else
                  try {
                    const t = this.getError(e);
                    (s = this._abiCoder.decode(t.inputs, r.slice(4))),
                      (o = t.name),
                      (a = t.format());
                  } catch (e) {}
                break;
              }
            }
            return st.throwError(
              "call revert exception" + i,
              p.errors.CALL_EXCEPTION,
              {
                method: e.format(),
                data: T(t),
                errorArgs: s,
                errorName: o,
                errorSignature: a,
                reason: n,
              },
            );
          }
          encodeFunctionResult(e, t) {
            return (
              "string" == typeof e && (e = this.getFunction(e)),
              T(this._abiCoder.encode(e.outputs, t || []))
            );
          }
          encodeFilterTopics(e, t) {
            "string" == typeof e && (e = this.getEvent(e)),
              t.length > e.inputs.length &&
                st.throwError(
                  "too many arguments for " + e.format(),
                  p.errors.UNEXPECTED_ARGUMENT,
                  { argument: "values", value: t },
                );
            let r = [];
            e.anonymous || r.push(this.getEventTopic(e));
            const n = (e, t) =>
              "string" === e.type
                ? it(t)
                : "bytes" === e.type
                ? Ee(T(t))
                : ("bool" === e.type &&
                    "boolean" == typeof t &&
                    (t = t ? "0x01" : "0x00"),
                  e.type.match(/^u?int/) && (t = C.from(t).toHexString()),
                  "address" === e.type &&
                    this._abiCoder.encode(["address"], [t]),
                  R(T(t), 32));
            for (
              t.forEach((t, i) => {
                let s = e.inputs[i];
                s.indexed
                  ? null == t
                    ? r.push(null)
                    : "array" === s.baseType || "tuple" === s.baseType
                    ? st.throwArgumentError(
                        "filtering with tuples or arrays not supported",
                        "contract." + s.name,
                        t,
                      )
                    : Array.isArray(t)
                    ? r.push(t.map((e) => n(s, e)))
                    : r.push(n(s, t))
                  : null != t &&
                    st.throwArgumentError(
                      "cannot filter non-indexed parameters; must be null",
                      "contract." + s.name,
                      t,
                    );
              });
              r.length && null === r[r.length - 1];

            )
              r.pop();
            return r;
          }
          encodeEventLog(e, t) {
            "string" == typeof e && (e = this.getEvent(e));
            const r = [],
              n = [],
              i = [];
            return (
              e.anonymous || r.push(this.getEventTopic(e)),
              t.length !== e.inputs.length &&
                st.throwArgumentError(
                  "event arguments/values mismatch",
                  "values",
                  t,
                ),
              e.inputs.forEach((e, s) => {
                const o = t[s];
                if (e.indexed)
                  if ("string" === e.type) r.push(it(o));
                  else if ("bytes" === e.type) r.push(Ee(o));
                  else {
                    if ("tuple" === e.baseType || "array" === e.baseType)
                      throw new Error("not implemented");
                    r.push(this._abiCoder.encode([e.type], [o]));
                  }
                else n.push(e), i.push(o);
              }),
              { data: this._abiCoder.encode(n, i), topics: r }
            );
          }
          decodeEventLog(e, t, r) {
            if (
              ("string" == typeof e && (e = this.getEvent(e)),
              null != r && !e.anonymous)
            ) {
              let t = this.getEventTopic(e);
              (A(r[0], 32) && r[0].toLowerCase() === t) ||
                st.throwError(
                  "fragment/topic mismatch",
                  p.errors.INVALID_ARGUMENT,
                  { argument: "topics[0]", expected: t, value: r[0] },
                ),
                (r = r.slice(1));
            }
            let n = [],
              i = [],
              s = [];
            e.inputs.forEach((e, t) => {
              e.indexed
                ? "string" === e.type ||
                  "bytes" === e.type ||
                  "tuple" === e.baseType ||
                  "array" === e.baseType
                  ? (n.push(Y.fromObject({ type: "bytes32", name: e.name })),
                    s.push(!0))
                  : (n.push(e), s.push(!1))
                : (i.push(e), s.push(!1));
            });
            let o = null != r ? this._abiCoder.decode(n, E(r)) : null,
              a = this._abiCoder.decode(i, t, !0),
              c = [],
              d = 0,
              u = 0;
            e.inputs.forEach((e, t) => {
              if (e.indexed)
                if (null == o) c[t] = new dt({ _isIndexed: !0, hash: null });
                else if (s[t]) c[t] = new dt({ _isIndexed: !0, hash: o[u++] });
                else
                  try {
                    c[t] = o[u++];
                  } catch (e) {
                    c[t] = e;
                  }
              else
                try {
                  c[t] = a[d++];
                } catch (e) {
                  c[t] = e;
                }
              if (e.name && null == c[e.name]) {
                const r = c[t];
                r instanceof Error
                  ? Object.defineProperty(c, e.name, {
                      enumerable: !0,
                      get: () => {
                        throw lt(`property ${JSON.stringify(e.name)}`, r);
                      },
                    })
                  : (c[e.name] = r);
              }
            });
            for (let e = 0; e < c.length; e++) {
              const t = c[e];
              t instanceof Error &&
                Object.defineProperty(c, e, {
                  enumerable: !0,
                  get: () => {
                    throw lt(`index ${e}`, t);
                  },
                });
            }
            return Object.freeze(c);
          }
          parseTransaction(e) {
            let t = this.getFunction(e.data.substring(0, 10).toLowerCase());
            return t
              ? new at({
                  args: this._abiCoder.decode(
                    t.inputs,
                    "0x" + e.data.substring(10),
                  ),
                  functionFragment: t,
                  name: t.name,
                  signature: t.format(),
                  sighash: this.getSighash(t),
                  value: C.from(e.value || "0"),
                })
              : null;
          }
          parseLog(e) {
            let t = this.getEvent(e.topics[0]);
            return !t || t.anonymous
              ? null
              : new ot({
                  eventFragment: t,
                  name: t.name,
                  signature: t.format(),
                  topic: this.getEventTopic(t),
                  args: this.decodeEventLog(t, e.data, e.topics),
                });
          }
          parseError(e) {
            const t = T(e);
            let r = this.getError(t.substring(0, 10).toLowerCase());
            return r
              ? new ct({
                  args: this._abiCoder.decode(r.inputs, "0x" + t.substring(10)),
                  errorFragment: r,
                  name: r.name,
                  signature: r.format(),
                  sighash: this.getSighash(r),
                })
              : null;
          }
          static isInterface(e) {
            return !(!e || !e._isInterface);
          }
        }
      },
      9082: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.createCurve = t.getHash = void 0);
        const n = r(9569),
          i = r(8089),
          s = r(6551);
        function o(e) {
          return {
            hash: e,
            hmac: (t, ...r) => (0, n.hmac)(e, t, (0, i.concatBytes)(...r)),
            randomBytes: i.randomBytes,
          };
        }
        (t.getHash = o),
          (t.createCurve = function (e, t) {
            const r = (t) => (0, s.weierstrass)({ ...e, ...o(t) });
            return Object.freeze({ ...r(t), create: r });
          });
      },
      1525: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.validateBasic = t.wNAF = void 0);
        const n = r(4632),
          i = r(219),
          s = BigInt(0),
          o = BigInt(1);
        (t.wNAF = function (e, t) {
          const r = (e, t) => {
              const r = t.negate();
              return e ? r : t;
            },
            n = (e) => ({
              windows: Math.ceil(t / e) + 1,
              windowSize: 2 ** (e - 1),
            });
          return {
            constTimeNegate: r,
            unsafeLadder(t, r) {
              let n = e.ZERO,
                i = t;
              for (; r > s; )
                r & o && (n = n.add(i)), (i = i.double()), (r >>= o);
              return n;
            },
            precomputeWindow(e, t) {
              const { windows: r, windowSize: i } = n(t),
                s = [];
              let o = e,
                a = o;
              for (let e = 0; e < r; e++) {
                (a = o), s.push(a);
                for (let e = 1; e < i; e++) (a = a.add(o)), s.push(a);
                o = a.double();
              }
              return s;
            },
            wNAF(t, i, s) {
              const { windows: a, windowSize: c } = n(t);
              let d = e.ZERO,
                u = e.BASE;
              const l = BigInt(2 ** t - 1),
                h = 2 ** t,
                f = BigInt(t);
              for (let e = 0; e < a; e++) {
                const t = e * c;
                let n = Number(s & l);
                (s >>= f), n > c && ((n -= h), (s += o));
                const a = t,
                  p = t + Math.abs(n) - 1,
                  m = e % 2 != 0,
                  y = n < 0;
                0 === n ? (u = u.add(r(m, i[a]))) : (d = d.add(r(y, i[p])));
              }
              return { p: d, f: u };
            },
            wNAFCached(e, t, r, n) {
              const i = e._WINDOW_SIZE || 1;
              let s = t.get(e);
              return (
                s ||
                  ((s = this.precomputeWindow(e, i)),
                  1 !== i && t.set(e, n(s))),
                this.wNAF(i, s, r)
              );
            },
          };
        }),
          (t.validateBasic = function (e) {
            return (
              (0, n.validateField)(e.Fp),
              (0, i.validateObject)(
                e,
                { n: "bigint", h: "bigint", Gx: "field", Gy: "field" },
                { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" },
              ),
              Object.freeze({
                ...(0, n.nLength)(e.n, e.nBitLength),
                ...e,
                p: e.Fp.ORDER,
              })
            );
          });
      },
      5134: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.createHasher =
            t.isogenyMap =
            t.hash_to_field =
            t.expand_message_xof =
            t.expand_message_xmd =
              void 0);
        const n = r(4632),
          i = r(219),
          s = i.bytesToNumberBE;
        function o(e, t) {
          if (e < 0 || e >= 1 << (8 * t))
            throw new Error(`bad I2OSP call: value=${e} length=${t}`);
          const r = Array.from({ length: t }).fill(0);
          for (let n = t - 1; n >= 0; n--) (r[n] = 255 & e), (e >>>= 8);
          return new Uint8Array(r);
        }
        function a(e, t) {
          const r = new Uint8Array(e.length);
          for (let n = 0; n < e.length; n++) r[n] = e[n] ^ t[n];
          return r;
        }
        function c(e) {
          if (!(e instanceof Uint8Array))
            throw new Error("Uint8Array expected");
        }
        function d(e) {
          if (!Number.isSafeInteger(e)) throw new Error("number expected");
        }
        function u(e, t, r, n) {
          c(e),
            c(t),
            d(r),
            t.length > 255 &&
              (t = n(
                (0, i.concatBytes)((0, i.utf8ToBytes)("H2C-OVERSIZE-DST-"), t),
              ));
          const { outputLen: s, blockLen: u } = n,
            l = Math.ceil(r / s);
          if (l > 255) throw new Error("Invalid xmd length");
          const h = (0, i.concatBytes)(t, o(t.length, 1)),
            f = o(0, u),
            p = o(r, 2),
            m = new Array(l),
            y = n((0, i.concatBytes)(f, e, p, o(0, 1), h));
          m[0] = n((0, i.concatBytes)(y, o(1, 1), h));
          for (let e = 1; e <= l; e++) {
            const t = [a(y, m[e - 1]), o(e + 1, 1), h];
            m[e] = n((0, i.concatBytes)(...t));
          }
          return (0, i.concatBytes)(...m).slice(0, r);
        }
        function l(e, t, r, n, s) {
          if ((c(e), c(t), d(r), t.length > 255)) {
            const e = Math.ceil((2 * n) / 8);
            t = s
              .create({ dkLen: e })
              .update((0, i.utf8ToBytes)("H2C-OVERSIZE-DST-"))
              .update(t)
              .digest();
          }
          if (r > 65535 || t.length > 255)
            throw new Error("expand_message_xof: invalid lenInBytes");
          return s
            .create({ dkLen: r })
            .update(e)
            .update(o(r, 2))
            .update(t)
            .update(o(t.length, 1))
            .digest();
        }
        function h(e, t, r) {
          (0, i.validateObject)(r, {
            DST: "string",
            p: "bigint",
            m: "isSafeInteger",
            k: "isSafeInteger",
            hash: "hash",
          });
          const { p: o, k: a, m: h, hash: f, expand: p, DST: m } = r;
          c(e), d(t);
          const y = (function (e) {
              if (e instanceof Uint8Array) return e;
              if ("string" == typeof e) return (0, i.utf8ToBytes)(e);
              throw new Error("DST must be Uint8Array or string");
            })(m),
            g = o.toString(2).length,
            v = Math.ceil((g + a) / 8),
            b = t * h * v;
          let w;
          if ("xmd" === p) w = u(e, y, b, f);
          else if ("xof" === p) w = l(e, y, b, a, f);
          else {
            if ("_internal_pass" !== p)
              throw new Error('expand must be "xmd" or "xof"');
            w = e;
          }
          const E = new Array(t);
          for (let e = 0; e < t; e++) {
            const t = new Array(h);
            for (let r = 0; r < h; r++) {
              const i = v * (r + e * h),
                a = w.subarray(i, i + v);
              t[r] = (0, n.mod)(s(a), o);
            }
            E[e] = t;
          }
          return E;
        }
        (t.expand_message_xmd = u),
          (t.expand_message_xof = l),
          (t.hash_to_field = h),
          (t.isogenyMap = function (e, t) {
            const r = t.map((e) => Array.from(e).reverse());
            return (t, n) => {
              const [i, s, o, a] = r.map((r) =>
                r.reduce((r, n) => e.add(e.mul(r, t), n)),
              );
              return (
                (t = e.div(i, s)), (n = e.mul(n, e.div(o, a))), { x: t, y: n }
              );
            };
          }),
          (t.createHasher = function (e, t, r) {
            if ("function" != typeof t)
              throw new Error("mapToCurve() must be defined");
            return {
              hashToCurve(n, i) {
                const s = h(n, 2, { ...r, DST: r.DST, ...i }),
                  o = e.fromAffine(t(s[0])),
                  a = e.fromAffine(t(s[1])),
                  c = o.add(a).clearCofactor();
                return c.assertValidity(), c;
              },
              encodeToCurve(n, i) {
                const s = h(n, 1, { ...r, DST: r.encodeDST, ...i }),
                  o = e.fromAffine(t(s[0])).clearCofactor();
                return o.assertValidity(), o;
              },
            };
          });
      },
      4632: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.hashToPrivateScalar =
            t.FpSqrtEven =
            t.FpSqrtOdd =
            t.Field =
            t.nLength =
            t.FpIsSquare =
            t.FpDiv =
            t.FpInvertBatch =
            t.FpPow =
            t.validateField =
            t.isNegativeLE =
            t.FpSqrt =
            t.tonelliShanks =
            t.invert =
            t.pow2 =
            t.pow =
            t.mod =
              void 0);
        const n = r(219),
          i = BigInt(0),
          s = BigInt(1),
          o = BigInt(2),
          a = BigInt(3),
          c = BigInt(4),
          d = BigInt(5),
          u = BigInt(8);
        function l(e, t) {
          const r = e % t;
          return r >= i ? r : t + r;
        }
        function h(e, t, r) {
          if (r <= i || t < i) throw new Error("Expected power/modulo > 0");
          if (r === s) return i;
          let n = s;
          for (; t > i; )
            t & s && (n = (n * e) % r), (e = (e * e) % r), (t >>= s);
          return n;
        }
        function f(e, t) {
          if (e === i || t <= i)
            throw new Error(
              `invert: expected positive integers, got n=${e} mod=${t}`,
            );
          let r = l(e, t),
            n = t,
            o = i,
            a = s,
            c = s,
            d = i;
          for (; r !== i; ) {
            const e = n / r,
              t = n % r,
              i = o - c * e,
              s = a - d * e;
            (n = r), (r = t), (o = c), (a = d), (c = i), (d = s);
          }
          if (n !== s) throw new Error("invert: does not exist");
          return l(o, t);
        }
        function p(e) {
          const t = (e - s) / o;
          let r, n, a;
          for (r = e - s, n = 0; r % o === i; r /= o, n++);
          for (a = o; a < e && h(a, t, e) !== e - s; a++);
          if (1 === n) {
            const t = (e + s) / c;
            return function (e, r) {
              const n = e.pow(r, t);
              if (!e.eql(e.sqr(n), r))
                throw new Error("Cannot find square root");
              return n;
            };
          }
          const d = (r + s) / o;
          return function (e, i) {
            if (e.pow(i, t) === e.neg(e.ONE))
              throw new Error("Cannot find square root");
            let o = n,
              c = e.pow(e.mul(e.ONE, a), r),
              u = e.pow(i, d),
              l = e.pow(i, r);
            for (; !e.eql(l, e.ONE); ) {
              if (e.eql(l, e.ZERO)) return e.ZERO;
              let t = 1;
              for (let r = e.sqr(l); t < o && !e.eql(r, e.ONE); t++)
                r = e.sqr(r);
              const r = e.pow(c, s << BigInt(o - t - 1));
              (c = e.sqr(r)), (u = e.mul(u, r)), (l = e.mul(l, c)), (o = t);
            }
            return u;
          };
        }
        function m(e) {
          if (e % c === a) {
            const t = (e + s) / c;
            return function (e, r) {
              const n = e.pow(r, t);
              if (!e.eql(e.sqr(n), r))
                throw new Error("Cannot find square root");
              return n;
            };
          }
          if (e % u === d) {
            const t = (e - d) / u;
            return function (e, r) {
              const n = e.mul(r, o),
                i = e.pow(n, t),
                s = e.mul(r, i),
                a = e.mul(e.mul(s, o), i),
                c = e.mul(s, e.sub(a, e.ONE));
              if (!e.eql(e.sqr(c), r))
                throw new Error("Cannot find square root");
              return c;
            };
          }
          return p(e);
        }
        BigInt(9),
          BigInt(16),
          (t.mod = l),
          (t.pow = h),
          (t.pow2 = function (e, t, r) {
            let n = e;
            for (; t-- > i; ) (n *= n), (n %= r);
            return n;
          }),
          (t.invert = f),
          (t.tonelliShanks = p),
          (t.FpSqrt = m),
          (t.isNegativeLE = (e, t) => (l(e, t) & s) === s);
        const y = [
          "create",
          "isValid",
          "is0",
          "neg",
          "inv",
          "sqrt",
          "sqr",
          "eql",
          "add",
          "sub",
          "mul",
          "pow",
          "div",
          "addN",
          "subN",
          "mulN",
          "sqrN",
        ];
        function g(e, t, r) {
          if (r < i) throw new Error("Expected power > 0");
          if (r === i) return e.ONE;
          if (r === s) return t;
          let n = e.ONE,
            o = t;
          for (; r > i; ) r & s && (n = e.mul(n, o)), (o = e.sqr(o)), (r >>= s);
          return n;
        }
        function v(e, t) {
          const r = new Array(t.length),
            n = t.reduce(
              (t, n, i) => (e.is0(n) ? t : ((r[i] = t), e.mul(t, n))),
              e.ONE,
            ),
            i = e.inv(n);
          return (
            t.reduceRight(
              (t, n, i) =>
                e.is0(n) ? t : ((r[i] = e.mul(t, r[i])), e.mul(t, n)),
              i,
            ),
            r
          );
        }
        function b(e, t) {
          const r = void 0 !== t ? t : e.toString(2).length;
          return { nBitLength: r, nByteLength: Math.ceil(r / 8) };
        }
        (t.validateField = function (e) {
          const t = y.reduce((e, t) => ((e[t] = "function"), e), {
            ORDER: "bigint",
            MASK: "bigint",
            BYTES: "isSafeInteger",
            BITS: "isSafeInteger",
          });
          return (0, n.validateObject)(e, t);
        }),
          (t.FpPow = g),
          (t.FpInvertBatch = v),
          (t.FpDiv = function (e, t, r) {
            return e.mul(t, "bigint" == typeof r ? f(r, e.ORDER) : e.inv(r));
          }),
          (t.FpIsSquare = function (e) {
            const t = (e.ORDER - s) / o;
            return (r) => {
              const n = e.pow(r, t);
              return e.eql(n, e.ZERO) || e.eql(n, e.ONE);
            };
          }),
          (t.nLength = b),
          (t.Field = function (e, t, r = !1, o = {}) {
            if (e <= i) throw new Error(`Expected Fp ORDER > 0, got ${e}`);
            const { nBitLength: a, nByteLength: c } = b(e, t);
            if (c > 2048)
              throw new Error(
                "Field lengths over 2048 bytes are not supported",
              );
            const d = m(e),
              u = Object.freeze({
                ORDER: e,
                BITS: a,
                BYTES: c,
                MASK: (0, n.bitMask)(a),
                ZERO: i,
                ONE: s,
                create: (t) => l(t, e),
                isValid: (t) => {
                  if ("bigint" != typeof t)
                    throw new Error(
                      "Invalid field element: expected bigint, got " + typeof t,
                    );
                  return i <= t && t < e;
                },
                is0: (e) => e === i,
                isOdd: (e) => (e & s) === s,
                neg: (t) => l(-t, e),
                eql: (e, t) => e === t,
                sqr: (t) => l(t * t, e),
                add: (t, r) => l(t + r, e),
                sub: (t, r) => l(t - r, e),
                mul: (t, r) => l(t * r, e),
                pow: (e, t) => g(u, e, t),
                div: (t, r) => l(t * f(r, e), e),
                sqrN: (e) => e * e,
                addN: (e, t) => e + t,
                subN: (e, t) => e - t,
                mulN: (e, t) => e * t,
                inv: (t) => f(t, e),
                sqrt: o.sqrt || ((e) => d(u, e)),
                invertBatch: (e) => v(u, e),
                cmov: (e, t, r) => (r ? t : e),
                toBytes: (e) =>
                  r
                    ? (0, n.numberToBytesLE)(e, c)
                    : (0, n.numberToBytesBE)(e, c),
                fromBytes: (e) => {
                  if (e.length !== c)
                    throw new Error(
                      `Fp.fromBytes: expected ${c}, got ${e.length}`,
                    );
                  return r
                    ? (0, n.bytesToNumberLE)(e)
                    : (0, n.bytesToNumberBE)(e);
                },
              });
            return Object.freeze(u);
          }),
          (t.FpSqrtOdd = function (e, t) {
            if (!e.isOdd) throw new Error("Field doesn't have isOdd");
            const r = e.sqrt(t);
            return e.isOdd(r) ? r : e.neg(r);
          }),
          (t.FpSqrtEven = function (e, t) {
            if (!e.isOdd) throw new Error("Field doesn't have isOdd");
            const r = e.sqrt(t);
            return e.isOdd(r) ? e.neg(r) : r;
          }),
          (t.hashToPrivateScalar = function (e, t, r = !1) {
            const i = (e = (0, n.ensureBytes)("privateHash", e)).length,
              o = b(t).nByteLength + 8;
            if (o < 24 || i < o || i > 1024)
              throw new Error(
                `hashToPrivateScalar: expected ${o}-1024 bytes of input, got ${i}`,
              );
            return (
              l(
                r ? (0, n.bytesToNumberLE)(e) : (0, n.bytesToNumberBE)(e),
                t - s,
              ) + s
            );
          });
      },
      219: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.validateObject =
            t.createHmacDrbg =
            t.bitMask =
            t.bitSet =
            t.bitGet =
            t.bitLen =
            t.utf8ToBytes =
            t.equalBytes =
            t.concatBytes =
            t.ensureBytes =
            t.numberToVarBytesBE =
            t.numberToBytesLE =
            t.numberToBytesBE =
            t.bytesToNumberLE =
            t.bytesToNumberBE =
            t.hexToBytes =
            t.hexToNumber =
            t.numberToHexUnpadded =
            t.bytesToHex =
              void 0);
        const r = BigInt(0),
          n = BigInt(1),
          i = BigInt(2),
          s = (e) => e instanceof Uint8Array,
          o = Array.from({ length: 256 }, (e, t) =>
            t.toString(16).padStart(2, "0"),
          );
        function a(e) {
          if (!s(e)) throw new Error("Uint8Array expected");
          let t = "";
          for (let r = 0; r < e.length; r++) t += o[e[r]];
          return t;
        }
        function c(e) {
          const t = e.toString(16);
          return 1 & t.length ? `0${t}` : t;
        }
        function d(e) {
          if ("string" != typeof e)
            throw new Error("hex string expected, got " + typeof e);
          return BigInt("" === e ? "0" : `0x${e}`);
        }
        function u(e) {
          if ("string" != typeof e)
            throw new Error("hex string expected, got " + typeof e);
          const t = e.length;
          if (t % 2)
            throw new Error(
              "padded hex string expected, got unpadded hex of length " + t,
            );
          const r = new Uint8Array(t / 2);
          for (let t = 0; t < r.length; t++) {
            const n = 2 * t,
              i = e.slice(n, n + 2),
              s = Number.parseInt(i, 16);
            if (Number.isNaN(s) || s < 0)
              throw new Error("Invalid byte sequence");
            r[t] = s;
          }
          return r;
        }
        function l(e, t) {
          return u(e.toString(16).padStart(2 * t, "0"));
        }
        function h(...e) {
          const t = new Uint8Array(e.reduce((e, t) => e + t.length, 0));
          let r = 0;
          return (
            e.forEach((e) => {
              if (!s(e)) throw new Error("Uint8Array expected");
              t.set(e, r), (r += e.length);
            }),
            t
          );
        }
        (t.bytesToHex = a),
          (t.numberToHexUnpadded = c),
          (t.hexToNumber = d),
          (t.hexToBytes = u),
          (t.bytesToNumberBE = function (e) {
            return d(a(e));
          }),
          (t.bytesToNumberLE = function (e) {
            if (!s(e)) throw new Error("Uint8Array expected");
            return d(a(Uint8Array.from(e).reverse()));
          }),
          (t.numberToBytesBE = l),
          (t.numberToBytesLE = function (e, t) {
            return l(e, t).reverse();
          }),
          (t.numberToVarBytesBE = function (e) {
            return u(c(e));
          }),
          (t.ensureBytes = function (e, t, r) {
            let n;
            if ("string" == typeof t)
              try {
                n = u(t);
              } catch (r) {
                throw new Error(
                  `${e} must be valid hex string, got "${t}". Cause: ${r}`,
                );
              }
            else {
              if (!s(t))
                throw new Error(`${e} must be hex string or Uint8Array`);
              n = Uint8Array.from(t);
            }
            const i = n.length;
            if ("number" == typeof r && i !== r)
              throw new Error(`${e} expected ${r} bytes, got ${i}`);
            return n;
          }),
          (t.concatBytes = h),
          (t.equalBytes = function (e, t) {
            if (e.length !== t.length) return !1;
            for (let r = 0; r < e.length; r++) if (e[r] !== t[r]) return !1;
            return !0;
          }),
          (t.utf8ToBytes = function (e) {
            if ("string" != typeof e)
              throw new Error("utf8ToBytes expected string, got " + typeof e);
            return new Uint8Array(new TextEncoder().encode(e));
          }),
          (t.bitLen = function (e) {
            let t;
            for (t = 0; e > r; e >>= n, t += 1);
            return t;
          }),
          (t.bitGet = function (e, t) {
            return (e >> BigInt(t)) & n;
          }),
          (t.bitSet = (e, t, i) => e | ((i ? n : r) << BigInt(t))),
          (t.bitMask = (e) => (i << BigInt(e - 1)) - n);
        const f = (e) => new Uint8Array(e),
          p = (e) => Uint8Array.from(e);
        t.createHmacDrbg = function (e, t, r) {
          if ("number" != typeof e || e < 2)
            throw new Error("hashLen must be a number");
          if ("number" != typeof t || t < 2)
            throw new Error("qByteLen must be a number");
          if ("function" != typeof r)
            throw new Error("hmacFn must be a function");
          let n = f(e),
            i = f(e),
            s = 0;
          const o = () => {
              n.fill(1), i.fill(0), (s = 0);
            },
            a = (...e) => r(i, n, ...e),
            c = (e = f()) => {
              (i = a(p([0]), e)),
                (n = a()),
                0 !== e.length && ((i = a(p([1]), e)), (n = a()));
            },
            d = () => {
              if (s++ >= 1e3) throw new Error("drbg: tried 1000 values");
              let e = 0;
              const r = [];
              for (; e < t; ) {
                n = a();
                const t = n.slice();
                r.push(t), (e += n.length);
              }
              return h(...r);
            };
          return (e, t) => {
            let r;
            for (o(), c(e); !(r = t(d())); ) c();
            return o(), r;
          };
        };
        const m = {
          bigint: (e) => "bigint" == typeof e,
          function: (e) => "function" == typeof e,
          boolean: (e) => "boolean" == typeof e,
          string: (e) => "string" == typeof e,
          isSafeInteger: (e) => Number.isSafeInteger(e),
          array: (e) => Array.isArray(e),
          field: (e, t) => t.Fp.isValid(e),
          hash: (e) =>
            "function" == typeof e && Number.isSafeInteger(e.outputLen),
        };
        t.validateObject = function (e, t, r = {}) {
          const n = (t, r, n) => {
            const i = m[r];
            if ("function" != typeof i)
              throw new Error(`Invalid validator "${r}", expected function`);
            const s = e[t];
            if (!((n && void 0 === s) || i(s, e)))
              throw new Error(
                `Invalid param ${String(t)}=${s} (${typeof s}), expected ${r}`,
              );
          };
          for (const [e, r] of Object.entries(t)) n(e, r, !1);
          for (const [e, t] of Object.entries(r)) n(e, t, !0);
          return e;
        };
      },
      6551: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.mapToCurveSimpleSWU =
            t.SWUFpSqrtRatio =
            t.weierstrass =
            t.weierstrassPoints =
            t.DER =
              void 0);
        const n = r(4632),
          i = r(219),
          s = r(219),
          o = r(1525),
          { bytesToNumberBE: a, hexToBytes: c } = i;
        t.DER = {
          Err: class extends Error {
            constructor(e = "") {
              super(e);
            }
          },
          _parseInt(e) {
            const { Err: r } = t.DER;
            if (e.length < 2 || 2 !== e[0])
              throw new r("Invalid signature integer tag");
            const n = e[1],
              i = e.subarray(2, n + 2);
            if (!n || i.length !== n)
              throw new r("Invalid signature integer: wrong length");
            if (128 & i[0]) throw new r("Invalid signature integer: negative");
            if (0 === i[0] && !(128 & i[1]))
              throw new r(
                "Invalid signature integer: unnecessary leading zero",
              );
            return { d: a(i), l: e.subarray(n + 2) };
          },
          toSig(e) {
            const { Err: r } = t.DER,
              n = "string" == typeof e ? c(e) : e;
            if (!(n instanceof Uint8Array)) throw new Error("ui8a expected");
            let i = n.length;
            if (i < 2 || 48 != n[0]) throw new r("Invalid signature tag");
            if (n[1] !== i - 2)
              throw new r("Invalid signature: incorrect length");
            const { d: s, l: o } = t.DER._parseInt(n.subarray(2)),
              { d: a, l: d } = t.DER._parseInt(o);
            if (d.length)
              throw new r("Invalid signature: left bytes after parsing");
            return { r: s, s: a };
          },
          hexFromSig(e) {
            const t = (e) => (8 & Number.parseInt(e[0], 16) ? "00" + e : e),
              r = (e) => {
                const t = e.toString(16);
                return 1 & t.length ? `0${t}` : t;
              },
              n = t(r(e.s)),
              i = t(r(e.r)),
              s = n.length / 2,
              o = i.length / 2,
              a = r(s),
              c = r(o);
            return `30${r(o + s + 4)}02${c}${i}02${a}${n}`;
          },
        };
        const d = BigInt(0),
          u = BigInt(1),
          l = BigInt(2),
          h = BigInt(3),
          f = BigInt(4);
        function p(e) {
          const t = (function (e) {
              const t = (0, o.validateBasic)(e);
              i.validateObject(
                t,
                { a: "field", b: "field" },
                {
                  allowedPrivateKeyLengths: "array",
                  wrapPrivateKey: "boolean",
                  isTorsionFree: "function",
                  clearCofactor: "function",
                  allowInfinityPoint: "boolean",
                  fromBytes: "function",
                  toBytes: "function",
                },
              );
              const { endo: r, Fp: n, a: s } = t;
              if (r) {
                if (!n.eql(s, n.ZERO))
                  throw new Error(
                    "Endomorphism can only be defined for Koblitz curves that have a=0",
                  );
                if (
                  "object" != typeof r ||
                  "bigint" != typeof r.beta ||
                  "function" != typeof r.splitScalar
                )
                  throw new Error(
                    "Expected endomorphism with beta: bigint and splitScalar: function",
                  );
              }
              return Object.freeze({ ...t });
            })(e),
            { Fp: r } = t,
            a =
              t.toBytes ||
              ((e, t, n) => {
                const s = t.toAffine();
                return i.concatBytes(
                  Uint8Array.from([4]),
                  r.toBytes(s.x),
                  r.toBytes(s.y),
                );
              }),
            c =
              t.fromBytes ||
              ((e) => {
                const t = e.subarray(1);
                return {
                  x: r.fromBytes(t.subarray(0, r.BYTES)),
                  y: r.fromBytes(t.subarray(r.BYTES, 2 * r.BYTES)),
                };
              });
          function l(e) {
            const { a: n, b: i } = t,
              s = r.sqr(e),
              o = r.mul(s, e);
            return r.add(r.add(o, r.mul(e, n)), i);
          }
          if (!r.eql(r.sqr(t.Gy), l(t.Gx)))
            throw new Error("bad generator point: equation left != right");
          function f(e) {
            return "bigint" == typeof e && d < e && e < t.n;
          }
          function p(e) {
            if (!f(e))
              throw new Error("Expected valid bigint: 0 < bigint < curve.n");
          }
          function m(e) {
            const {
              allowedPrivateKeyLengths: r,
              nByteLength: o,
              wrapPrivateKey: a,
              n: c,
            } = t;
            if (r && "bigint" != typeof e) {
              if (
                (e instanceof Uint8Array && (e = i.bytesToHex(e)),
                "string" != typeof e || !r.includes(e.length))
              )
                throw new Error("Invalid key");
              e = e.padStart(2 * o, "0");
            }
            let d;
            try {
              d =
                "bigint" == typeof e
                  ? e
                  : i.bytesToNumberBE((0, s.ensureBytes)("private key", e, o));
            } catch (t) {
              throw new Error(
                `private key must be ${o} bytes, hex or bigint, not ${typeof e}`,
              );
            }
            return a && (d = n.mod(d, c)), p(d), d;
          }
          const y = new Map();
          function g(e) {
            if (!(e instanceof v)) throw new Error("ProjectivePoint expected");
          }
          class v {
            constructor(e, t, n) {
              if (
                ((this.px = e),
                (this.py = t),
                (this.pz = n),
                null == e || !r.isValid(e))
              )
                throw new Error("x required");
              if (null == t || !r.isValid(t)) throw new Error("y required");
              if (null == n || !r.isValid(n)) throw new Error("z required");
            }
            static fromAffine(e) {
              const { x: t, y: n } = e || {};
              if (!e || !r.isValid(t) || !r.isValid(n))
                throw new Error("invalid affine point");
              if (e instanceof v)
                throw new Error("projective point not allowed");
              const i = (e) => r.eql(e, r.ZERO);
              return i(t) && i(n) ? v.ZERO : new v(t, n, r.ONE);
            }
            get x() {
              return this.toAffine().x;
            }
            get y() {
              return this.toAffine().y;
            }
            static normalizeZ(e) {
              const t = r.invertBatch(e.map((e) => e.pz));
              return e.map((e, r) => e.toAffine(t[r])).map(v.fromAffine);
            }
            static fromHex(e) {
              const t = v.fromAffine(c((0, s.ensureBytes)("pointHex", e)));
              return t.assertValidity(), t;
            }
            static fromPrivateKey(e) {
              return v.BASE.multiply(m(e));
            }
            _setWindowSize(e) {
              (this._WINDOW_SIZE = e), y.delete(this);
            }
            assertValidity() {
              if (this.is0()) {
                if (t.allowInfinityPoint) return;
                throw new Error("bad point: ZERO");
              }
              const { x: e, y: n } = this.toAffine();
              if (!r.isValid(e) || !r.isValid(n))
                throw new Error("bad point: x or y not FE");
              const i = r.sqr(n),
                s = l(e);
              if (!r.eql(i, s))
                throw new Error("bad point: equation left != right");
              if (!this.isTorsionFree())
                throw new Error("bad point: not in prime-order subgroup");
            }
            hasEvenY() {
              const { y: e } = this.toAffine();
              if (r.isOdd) return !r.isOdd(e);
              throw new Error("Field doesn't support isOdd");
            }
            equals(e) {
              g(e);
              const { px: t, py: n, pz: i } = this,
                { px: s, py: o, pz: a } = e,
                c = r.eql(r.mul(t, a), r.mul(s, i)),
                d = r.eql(r.mul(n, a), r.mul(o, i));
              return c && d;
            }
            negate() {
              return new v(this.px, r.neg(this.py), this.pz);
            }
            double() {
              const { a: e, b: n } = t,
                i = r.mul(n, h),
                { px: s, py: o, pz: a } = this;
              let c = r.ZERO,
                d = r.ZERO,
                u = r.ZERO,
                l = r.mul(s, s),
                f = r.mul(o, o),
                p = r.mul(a, a),
                m = r.mul(s, o);
              return (
                (m = r.add(m, m)),
                (u = r.mul(s, a)),
                (u = r.add(u, u)),
                (c = r.mul(e, u)),
                (d = r.mul(i, p)),
                (d = r.add(c, d)),
                (c = r.sub(f, d)),
                (d = r.add(f, d)),
                (d = r.mul(c, d)),
                (c = r.mul(m, c)),
                (u = r.mul(i, u)),
                (p = r.mul(e, p)),
                (m = r.sub(l, p)),
                (m = r.mul(e, m)),
                (m = r.add(m, u)),
                (u = r.add(l, l)),
                (l = r.add(u, l)),
                (l = r.add(l, p)),
                (l = r.mul(l, m)),
                (d = r.add(d, l)),
                (p = r.mul(o, a)),
                (p = r.add(p, p)),
                (l = r.mul(p, m)),
                (c = r.sub(c, l)),
                (u = r.mul(p, f)),
                (u = r.add(u, u)),
                (u = r.add(u, u)),
                new v(c, d, u)
              );
            }
            add(e) {
              g(e);
              const { px: n, py: i, pz: s } = this,
                { px: o, py: a, pz: c } = e;
              let d = r.ZERO,
                u = r.ZERO,
                l = r.ZERO;
              const f = t.a,
                p = r.mul(t.b, h);
              let m = r.mul(n, o),
                y = r.mul(i, a),
                b = r.mul(s, c),
                w = r.add(n, i),
                E = r.add(o, a);
              (w = r.mul(w, E)),
                (E = r.add(m, y)),
                (w = r.sub(w, E)),
                (E = r.add(n, s));
              let A = r.add(o, c);
              return (
                (E = r.mul(E, A)),
                (A = r.add(m, b)),
                (E = r.sub(E, A)),
                (A = r.add(i, s)),
                (d = r.add(a, c)),
                (A = r.mul(A, d)),
                (d = r.add(y, b)),
                (A = r.sub(A, d)),
                (l = r.mul(f, E)),
                (d = r.mul(p, b)),
                (l = r.add(d, l)),
                (d = r.sub(y, l)),
                (l = r.add(y, l)),
                (u = r.mul(d, l)),
                (y = r.add(m, m)),
                (y = r.add(y, m)),
                (b = r.mul(f, b)),
                (E = r.mul(p, E)),
                (y = r.add(y, b)),
                (b = r.sub(m, b)),
                (b = r.mul(f, b)),
                (E = r.add(E, b)),
                (m = r.mul(y, E)),
                (u = r.add(u, m)),
                (m = r.mul(A, E)),
                (d = r.mul(w, d)),
                (d = r.sub(d, m)),
                (m = r.mul(w, y)),
                (l = r.mul(A, l)),
                (l = r.add(l, m)),
                new v(d, u, l)
              );
            }
            subtract(e) {
              return this.add(e.negate());
            }
            is0() {
              return this.equals(v.ZERO);
            }
            wNAF(e) {
              return w.wNAFCached(this, y, e, (e) => {
                const t = r.invertBatch(e.map((e) => e.pz));
                return e.map((e, r) => e.toAffine(t[r])).map(v.fromAffine);
              });
            }
            multiplyUnsafe(e) {
              const n = v.ZERO;
              if (e === d) return n;
              if ((p(e), e === u)) return this;
              const { endo: i } = t;
              if (!i) return w.unsafeLadder(this, e);
              let { k1neg: s, k1: o, k2neg: a, k2: c } = i.splitScalar(e),
                l = n,
                h = n,
                f = this;
              for (; o > d || c > d; )
                o & u && (l = l.add(f)),
                  c & u && (h = h.add(f)),
                  (f = f.double()),
                  (o >>= u),
                  (c >>= u);
              return (
                s && (l = l.negate()),
                a && (h = h.negate()),
                (h = new v(r.mul(h.px, i.beta), h.py, h.pz)),
                l.add(h)
              );
            }
            multiply(e) {
              p(e);
              let n,
                i,
                s = e;
              const { endo: o } = t;
              if (o) {
                const { k1neg: e, k1: t, k2neg: a, k2: c } = o.splitScalar(s);
                let { p: d, f: u } = this.wNAF(t),
                  { p: l, f: h } = this.wNAF(c);
                (d = w.constTimeNegate(e, d)),
                  (l = w.constTimeNegate(a, l)),
                  (l = new v(r.mul(l.px, o.beta), l.py, l.pz)),
                  (n = d.add(l)),
                  (i = u.add(h));
              } else {
                const { p: e, f: t } = this.wNAF(s);
                (n = e), (i = t);
              }
              return v.normalizeZ([n, i])[0];
            }
            multiplyAndAddUnsafe(e, t, r) {
              const n = v.BASE,
                i = (e, t) =>
                  t !== d && t !== u && e.equals(n)
                    ? e.multiply(t)
                    : e.multiplyUnsafe(t),
                s = i(this, t).add(i(e, r));
              return s.is0() ? void 0 : s;
            }
            toAffine(e) {
              const { px: t, py: n, pz: i } = this,
                s = this.is0();
              null == e && (e = s ? r.ONE : r.inv(i));
              const o = r.mul(t, e),
                a = r.mul(n, e),
                c = r.mul(i, e);
              if (s) return { x: r.ZERO, y: r.ZERO };
              if (!r.eql(c, r.ONE)) throw new Error("invZ was invalid");
              return { x: o, y: a };
            }
            isTorsionFree() {
              const { h: e, isTorsionFree: r } = t;
              if (e === u) return !0;
              if (r) return r(v, this);
              throw new Error(
                "isTorsionFree() has not been declared for the elliptic curve",
              );
            }
            clearCofactor() {
              const { h: e, clearCofactor: r } = t;
              return e === u ? this : r ? r(v, this) : this.multiplyUnsafe(t.h);
            }
            toRawBytes(e = !0) {
              return this.assertValidity(), a(v, this, e);
            }
            toHex(e = !0) {
              return i.bytesToHex(this.toRawBytes(e));
            }
          }
          (v.BASE = new v(t.Gx, t.Gy, r.ONE)),
            (v.ZERO = new v(r.ZERO, r.ONE, r.ZERO));
          const b = t.nBitLength,
            w = (0, o.wNAF)(v, t.endo ? Math.ceil(b / 2) : b);
          return {
            CURVE: t,
            ProjectivePoint: v,
            normPrivateKeyToScalar: m,
            weierstrassEquation: l,
            isWithinCurveOrder: f,
          };
        }
        function m(e, t) {
          const r = e.ORDER;
          let n = d;
          for (let e = r - u; e % l === d; e /= l) n += u;
          const i = n,
            s = l << (i - u - u),
            o = s * l,
            a = (r - u) / o,
            c = (a - u) / l,
            p = o - u,
            m = s,
            y = e.pow(t, a),
            g = e.pow(t, (a + u) / l);
          let v = (t, r) => {
            let n = y,
              s = e.pow(r, p),
              o = e.sqr(s);
            o = e.mul(o, r);
            let a = e.mul(t, o);
            (a = e.pow(a, c)),
              (a = e.mul(a, s)),
              (s = e.mul(a, r)),
              (o = e.mul(a, t));
            let d = e.mul(o, s);
            a = e.pow(d, m);
            let h = e.eql(a, e.ONE);
            (s = e.mul(o, g)),
              (a = e.mul(d, n)),
              (o = e.cmov(s, o, h)),
              (d = e.cmov(a, d, h));
            for (let t = i; t > u; t--) {
              let r = t - l;
              r = l << (r - u);
              let i = e.pow(d, r);
              const a = e.eql(i, e.ONE);
              (s = e.mul(o, n)),
                (n = e.mul(n, n)),
                (i = e.mul(d, n)),
                (o = e.cmov(s, o, a)),
                (d = e.cmov(i, d, a));
            }
            return { isValid: h, value: o };
          };
          if (e.ORDER % f === h) {
            const r = (e.ORDER - h) / f,
              n = e.sqrt(e.neg(t));
            v = (t, i) => {
              let s = e.sqr(i);
              const o = e.mul(t, i);
              s = e.mul(s, o);
              let a = e.pow(s, r);
              a = e.mul(a, o);
              const c = e.mul(a, n),
                d = e.mul(e.sqr(a), i),
                u = e.eql(d, t);
              return { isValid: u, value: e.cmov(c, a, u) };
            };
          }
          return v;
        }
        (t.weierstrassPoints = p),
          (t.weierstrass = function (e) {
            const r = (function (e) {
                const t = (0, o.validateBasic)(e);
                return (
                  i.validateObject(
                    t,
                    { hash: "hash", hmac: "function", randomBytes: "function" },
                    {
                      bits2int: "function",
                      bits2int_modN: "function",
                      lowS: "boolean",
                    },
                  ),
                  Object.freeze({ lowS: !0, ...t })
                );
              })(e),
              { Fp: a, n: c } = r,
              l = a.BYTES + 1,
              h = 2 * a.BYTES + 1;
            function f(e) {
              return n.mod(e, c);
            }
            function m(e) {
              return n.invert(e, c);
            }
            const {
                ProjectivePoint: y,
                normPrivateKeyToScalar: g,
                weierstrassEquation: v,
                isWithinCurveOrder: b,
              } = p({
                ...r,
                toBytes(e, t, r) {
                  const n = t.toAffine(),
                    s = a.toBytes(n.x),
                    o = i.concatBytes;
                  return r
                    ? o(Uint8Array.from([t.hasEvenY() ? 2 : 3]), s)
                    : o(Uint8Array.from([4]), s, a.toBytes(n.y));
                },
                fromBytes(e) {
                  const t = e.length,
                    r = e[0],
                    n = e.subarray(1);
                  if (t !== l || (2 !== r && 3 !== r)) {
                    if (t === h && 4 === r)
                      return {
                        x: a.fromBytes(n.subarray(0, a.BYTES)),
                        y: a.fromBytes(n.subarray(a.BYTES, 2 * a.BYTES)),
                      };
                    throw new Error(
                      `Point of length ${t} was invalid. Expected ${l} compressed bytes or ${h} uncompressed bytes`,
                    );
                  }
                  {
                    const e = i.bytesToNumberBE(n);
                    if (!(d < (s = e) && s < a.ORDER))
                      throw new Error("Point is not on curve");
                    const t = v(e);
                    let o = a.sqrt(t);
                    return (
                      (1 == (1 & r)) != ((o & u) === u) && (o = a.neg(o)),
                      { x: e, y: o }
                    );
                  }
                  var s;
                },
              }),
              w = (e) => i.bytesToHex(i.numberToBytesBE(e, r.nByteLength));
            function E(e) {
              return e > c >> u;
            }
            const A = (e, t, r) => i.bytesToNumberBE(e.slice(t, r));
            class _ {
              constructor(e, t, r) {
                (this.r = e),
                  (this.s = t),
                  (this.recovery = r),
                  this.assertValidity();
              }
              static fromCompact(e) {
                const t = r.nByteLength;
                return (
                  (e = (0, s.ensureBytes)("compactSignature", e, 2 * t)),
                  new _(A(e, 0, t), A(e, t, 2 * t))
                );
              }
              static fromDER(e) {
                const { r, s: n } = t.DER.toSig((0, s.ensureBytes)("DER", e));
                return new _(r, n);
              }
              assertValidity() {
                if (!b(this.r)) throw new Error("r must be 0 < r < CURVE.n");
                if (!b(this.s)) throw new Error("s must be 0 < s < CURVE.n");
              }
              addRecoveryBit(e) {
                return new _(this.r, this.s, e);
              }
              recoverPublicKey(e) {
                const { r: t, s: n, recovery: i } = this,
                  o = S((0, s.ensureBytes)("msgHash", e));
                if (null == i || ![0, 1, 2, 3].includes(i))
                  throw new Error("recovery id invalid");
                const c = 2 === i || 3 === i ? t + r.n : t;
                if (c >= a.ORDER) throw new Error("recovery id 2 or 3 invalid");
                const d = 0 == (1 & i) ? "02" : "03",
                  u = y.fromHex(d + w(c)),
                  l = m(c),
                  h = f(-o * l),
                  p = f(n * l),
                  g = y.BASE.multiplyAndAddUnsafe(u, h, p);
                if (!g) throw new Error("point at infinify");
                return g.assertValidity(), g;
              }
              hasHighS() {
                return E(this.s);
              }
              normalizeS() {
                return this.hasHighS()
                  ? new _(this.r, f(-this.s), this.recovery)
                  : this;
              }
              toDERRawBytes() {
                return i.hexToBytes(this.toDERHex());
              }
              toDERHex() {
                return t.DER.hexFromSig({ r: this.r, s: this.s });
              }
              toCompactRawBytes() {
                return i.hexToBytes(this.toCompactHex());
              }
              toCompactHex() {
                return w(this.r) + w(this.s);
              }
            }
            const T = {
              isValidPrivateKey(e) {
                try {
                  return g(e), !0;
                } catch (e) {
                  return !1;
                }
              },
              normPrivateKeyToScalar: g,
              randomPrivateKey: () => {
                const e = r.randomBytes(a.BYTES + 8),
                  t = n.hashToPrivateScalar(e, c);
                return i.numberToBytesBE(t, r.nByteLength);
              },
              precompute: (e = 8, t = y.BASE) => (
                t._setWindowSize(e), t.multiply(BigInt(3)), t
              ),
            };
            function R(e) {
              const t = e instanceof Uint8Array,
                r = "string" == typeof e,
                n = (t || r) && e.length;
              return t
                ? n === l || n === h
                : r
                ? n === 2 * l || n === 2 * h
                : e instanceof y;
            }
            const I =
                r.bits2int ||
                function (e) {
                  const t = i.bytesToNumberBE(e),
                    n = 8 * e.length - r.nBitLength;
                  return n > 0 ? t >> BigInt(n) : t;
                },
              S =
                r.bits2int_modN ||
                function (e) {
                  return f(I(e));
                },
              x = i.bitMask(r.nBitLength);
            function P(e) {
              if ("bigint" != typeof e) throw new Error("bigint expected");
              if (!(d <= e && e < x))
                throw new Error(`bigint expected < 2^${r.nBitLength}`);
              return i.numberToBytesBE(e, r.nByteLength);
            }
            const O = { lowS: r.lowS, prehash: !1 },
              C = { lowS: r.lowS, prehash: !1 };
            return (
              y.BASE._setWindowSize(8),
              {
                CURVE: r,
                getPublicKey: function (e, t = !0) {
                  return y.fromPrivateKey(e).toRawBytes(t);
                },
                getSharedSecret: function (e, t, r = !0) {
                  if (R(e)) throw new Error("first arg must be private key");
                  if (!R(t)) throw new Error("second arg must be public key");
                  return y.fromHex(t).multiply(g(e)).toRawBytes(r);
                },
                sign: function (e, t, n = O) {
                  const { seed: o, k2sig: c } = (function (e, t, n = O) {
                      if (["recovered", "canonical"].some((e) => e in n))
                        throw new Error("sign() legacy options not supported");
                      const { hash: o, randomBytes: c } = r;
                      let { lowS: l, prehash: h, extraEntropy: p } = n;
                      null == l && (l = !0),
                        (e = (0, s.ensureBytes)("msgHash", e)),
                        h &&
                          (e = (0, s.ensureBytes)("prehashed msgHash", o(e)));
                      const v = S(e),
                        w = g(t),
                        A = [P(w), P(v)];
                      if (null != p) {
                        const e = !0 === p ? c(a.BYTES) : p;
                        A.push((0, s.ensureBytes)("extraEntropy", e, a.BYTES));
                      }
                      const T = i.concatBytes(...A),
                        R = v;
                      return {
                        seed: T,
                        k2sig: function (e) {
                          const t = I(e);
                          if (!b(t)) return;
                          const r = m(t),
                            n = y.BASE.multiply(t).toAffine(),
                            i = f(n.x);
                          if (i === d) return;
                          const s = f(r * f(R + i * w));
                          if (s === d) return;
                          let o = (n.x === i ? 0 : 2) | Number(n.y & u),
                            a = s;
                          return (
                            l &&
                              E(s) &&
                              ((a = (function (e) {
                                return E(e) ? f(-e) : e;
                              })(s)),
                              (o ^= 1)),
                            new _(i, a, o)
                          );
                        },
                      };
                    })(e, t, n),
                    l = r;
                  return i.createHmacDrbg(
                    l.hash.outputLen,
                    l.nByteLength,
                    l.hmac,
                  )(o, c);
                },
                verify: function (e, n, i, o = C) {
                  const a = e;
                  if (
                    ((n = (0, s.ensureBytes)("msgHash", n)),
                    (i = (0, s.ensureBytes)("publicKey", i)),
                    "strict" in o)
                  )
                    throw new Error("options.strict was renamed to lowS");
                  const { lowS: c, prehash: d } = o;
                  let u, l;
                  try {
                    if ("string" == typeof a || a instanceof Uint8Array)
                      try {
                        u = _.fromDER(a);
                      } catch (e) {
                        if (!(e instanceof t.DER.Err)) throw e;
                        u = _.fromCompact(a);
                      }
                    else {
                      if (
                        "object" != typeof a ||
                        "bigint" != typeof a.r ||
                        "bigint" != typeof a.s
                      )
                        throw new Error("PARSE");
                      {
                        const { r: e, s: t } = a;
                        u = new _(e, t);
                      }
                    }
                    l = y.fromHex(i);
                  } catch (e) {
                    if ("PARSE" === e.message)
                      throw new Error(
                        "signature must be Signature instance, Uint8Array or hex string",
                      );
                    return !1;
                  }
                  if (c && u.hasHighS()) return !1;
                  d && (n = r.hash(n));
                  const { r: h, s: p } = u,
                    g = S(n),
                    v = m(p),
                    b = f(g * v),
                    w = f(h * v);
                    // E = y.BASE.multiplyAndAddUnsafe(l, b, w)?.toAffine();
                    let E;

                    const multiplyResult = y.BASE.multiplyAndAddUnsafe(l, b, w);
                    if (multiplyResult) {
                      E = multiplyResult.toAffine();
                    }
                  return !!E && f(E.x) === h;
                },
                ProjectivePoint: y,
                Signature: _,
                utils: T,
              }
            );
          }),
          (t.SWUFpSqrtRatio = m),
          (t.mapToCurveSimpleSWU = function (e, t) {
            if (
              (n.validateField(e),
              !e.isValid(t.A) || !e.isValid(t.B) || !e.isValid(t.Z))
            )
              throw new Error("mapToCurveSimpleSWU: invalid opts");
            const r = m(e, t.Z);
            if (!e.isOdd) throw new Error("Fp.isOdd is not implemented!");
            return (n) => {
              let i, s, o, a, c, d, u, l;
              (i = e.sqr(n)),
                (i = e.mul(i, t.Z)),
                (s = e.sqr(i)),
                (s = e.add(s, i)),
                (o = e.add(s, e.ONE)),
                (o = e.mul(o, t.B)),
                (a = e.cmov(t.Z, e.neg(s), !e.eql(s, e.ZERO))),
                (a = e.mul(a, t.A)),
                (s = e.sqr(o)),
                (d = e.sqr(a)),
                (c = e.mul(d, t.A)),
                (s = e.add(s, c)),
                (s = e.mul(s, o)),
                (d = e.mul(d, a)),
                (c = e.mul(d, t.B)),
                (s = e.add(s, c)),
                (u = e.mul(i, o));
              const { isValid: h, value: f } = r(s, d);
              (l = e.mul(i, n)),
                (l = e.mul(l, f)),
                (u = e.cmov(u, o, h)),
                (l = e.cmov(l, f, h));
              const p = e.isOdd(n) === e.isOdd(l);
              return (
                (l = e.cmov(e.neg(l), l, p)), (u = e.div(u, a)), { x: u, y: l }
              );
            };
          });
      },
      3497: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.encodeToCurve = t.hashToCurve = t.schnorr = t.secp256k1 = void 0);
        const n = r(3061),
          i = r(8089),
          s = r(4632),
          o = r(6551),
          a = r(219),
          c = r(5134),
          d = r(9082),
          u = BigInt(
            "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
          ),
          l = BigInt(
            "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141",
          ),
          h = BigInt(1),
          f = BigInt(2),
          p = (e, t) => (e + t / f) / t;
        function m(e) {
          const t = u,
            r = BigInt(3),
            n = BigInt(6),
            i = BigInt(11),
            o = BigInt(22),
            a = BigInt(23),
            c = BigInt(44),
            d = BigInt(88),
            l = (e * e * e) % t,
            h = (l * l * e) % t,
            p = ((0, s.pow2)(h, r, t) * h) % t,
            m = ((0, s.pow2)(p, r, t) * h) % t,
            g = ((0, s.pow2)(m, f, t) * l) % t,
            v = ((0, s.pow2)(g, i, t) * g) % t,
            b = ((0, s.pow2)(v, o, t) * v) % t,
            w = ((0, s.pow2)(b, c, t) * b) % t,
            E = ((0, s.pow2)(w, d, t) * w) % t,
            A = ((0, s.pow2)(E, c, t) * b) % t,
            _ = ((0, s.pow2)(A, r, t) * h) % t,
            T = ((0, s.pow2)(_, a, t) * v) % t,
            R = ((0, s.pow2)(T, n, t) * l) % t,
            I = (0, s.pow2)(R, f, t);
          if (!y.eql(y.sqr(I), e)) throw new Error("Cannot find square root");
          return I;
        }
        const y = (0, s.Field)(u, void 0, void 0, { sqrt: m });
        t.secp256k1 = (0, d.createCurve)(
          {
            a: BigInt(0),
            b: BigInt(7),
            Fp: y,
            n: l,
            Gx: BigInt(
              "55066263022277343669578718895168534326250603453777594175500187360389116729240",
            ),
            Gy: BigInt(
              "32670510020758816978083085130507043184471273380659243275938904335757337482424",
            ),
            h: BigInt(1),
            lowS: !0,
            endo: {
              beta: BigInt(
                "0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
              ),
              splitScalar: (e) => {
                const t = l,
                  r = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
                  n = -h * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
                  i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
                  o = r,
                  a = BigInt("0x100000000000000000000000000000000"),
                  c = p(o * e, t),
                  d = p(-n * e, t);
                let u = (0, s.mod)(e - c * r - d * i, t),
                  f = (0, s.mod)(-c * n - d * o, t);
                const m = u > a,
                  y = f > a;
                if ((m && (u = t - u), y && (f = t - f), u > a || f > a))
                  throw new Error("splitScalar: Endomorphism failed, k=" + e);
                return { k1neg: m, k1: u, k2neg: y, k2: f };
              },
            },
          },
          n.sha256,
        );
        const g = BigInt(0),
          v = (e) => "bigint" == typeof e && g < e && e < u,
          b = (e) => "bigint" == typeof e && g < e && e < l,
          w = {};
        function E(e, ...t) {
          let r = w[e];
          if (void 0 === r) {
            const t = (0, n.sha256)(Uint8Array.from(e, (e) => e.charCodeAt(0)));
            (r = (0, a.concatBytes)(t, t)), (w[e] = r);
          }
          return (0, n.sha256)((0, a.concatBytes)(r, ...t));
        }
        const A = (e) => e.toRawBytes(!0).slice(1),
          _ = (e) => (0, a.numberToBytesBE)(e, 32),
          T = (e) => (0, s.mod)(e, u),
          R = (e) => (0, s.mod)(e, l),
          I = t.secp256k1.ProjectivePoint,
          S = (e, t, r) => I.BASE.multiplyAndAddUnsafe(e, t, r);
        function x(e) {
          let r = t.secp256k1.utils.normPrivateKeyToScalar(e),
            n = I.fromPrivateKey(r);
          return { scalar: n.hasEvenY() ? r : R(-r), bytes: A(n) };
        }
        function P(e) {
          if (!v(e)) throw new Error("bad x: need 0 < x < p");
          const t = T(e * e);
          let r = m(T(t * e + BigInt(7)));
          r % f !== g && (r = T(-r));
          const n = new I(e, r, h);
          return n.assertValidity(), n;
        }
        function O(...e) {
          return R((0, a.bytesToNumberBE)(E("BIP0340/challenge", ...e)));
        }
        function C(e, t, r) {
          const n = (0, a.ensureBytes)("signature", e, 64),
            i = (0, a.ensureBytes)("message", t),
            s = (0, a.ensureBytes)("publicKey", r, 32);
          try {
            const e = P((0, a.bytesToNumberBE)(s)),
              t = (0, a.bytesToNumberBE)(n.subarray(0, 32));
            if (!v(t)) return !1;
            const r = (0, a.bytesToNumberBE)(n.subarray(32, 64));
            if (!b(r)) return !1;
            const o = O(_(t), A(e), i),
              c = S(e, r, R(-o));
            return !(!c || !c.hasEvenY() || c.toAffine().x !== t);
          } catch (e) {
            return !1;
          }
        }
        t.schnorr = {
          getPublicKey: function (e) {
            return x(e).bytes;
          },
          sign: function (e, t, r = (0, i.randomBytes)(32)) {
            const n = (0, a.ensureBytes)("message", e),
              { bytes: s, scalar: o } = x(t),
              c = (0, a.ensureBytes)("auxRand", r, 32),
              d = _(o ^ (0, a.bytesToNumberBE)(E("BIP0340/aux", c))),
              u = E("BIP0340/nonce", d, s, n),
              l = R((0, a.bytesToNumberBE)(u));
            if (l === g) throw new Error("sign failed: k is zero");
            const { bytes: h, scalar: f } = x(l),
              p = O(h, s, n),
              m = new Uint8Array(64);
            if ((m.set(h, 0), m.set(_(R(f + p * o)), 32), !C(m, n, s)))
              throw new Error("sign: Invalid signature produced");
            return m;
          },
          verify: C,
          utils: {
            randomPrivateKey: t.secp256k1.utils.randomPrivateKey,
            lift_x: P,
            pointToBytes: A,
            numberToBytesBE: a.numberToBytesBE,
            bytesToNumberBE: a.bytesToNumberBE,
            taggedHash: E,
            mod: s.mod,
          },
        };
        const k = (() =>
            (0, c.isogenyMap)(
              y,
              [
                [
                  "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
                  "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
                  "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
                  "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c",
                ],
                [
                  "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
                  "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
                  "0x0000000000000000000000000000000000000000000000000000000000000001",
                ],
                [
                  "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
                  "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
                  "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
                  "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84",
                ],
                [
                  "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
                  "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
                  "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
                  "0x0000000000000000000000000000000000000000000000000000000000000001",
                ],
              ].map((e) => e.map((e) => BigInt(e))),
            ))(),
          M = (() =>
            (0, o.mapToCurveSimpleSWU)(y, {
              A: BigInt(
                "0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533",
              ),
              B: BigInt("1771"),
              Z: y.create(BigInt("-11")),
            }))(),
          N = (() =>
            (0, c.createHasher)(
              t.secp256k1.ProjectivePoint,
              (e) => {
                const { x: t, y: r } = M(y.create(e[0]));
                return k(t, r);
              },
              {
                DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
                encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
                p: y.ORDER,
                m: 1,
                k: 128,
                expand: "xmd",
                hash: n.sha256,
              },
            ))();
        (t.hashToCurve = N.hashToCurve), (t.encodeToCurve = N.encodeToCurve);
      },
      7320: (e, t) => {
        "use strict";
        function r(e) {
          if (!Number.isSafeInteger(e) || e < 0)
            throw new Error(`Wrong positive integer: ${e}`);
        }
        function n(e) {
          if ("boolean" != typeof e)
            throw new Error(`Expected boolean, not ${e}`);
        }
        function i(e, ...t) {
          if (!(e instanceof Uint8Array))
            throw new Error("Expected Uint8Array");
          if (t.length > 0 && !t.includes(e.length))
            throw new Error(
              `Expected Uint8Array of length ${t}, not of length=${e.length}`,
            );
        }
        function s(e) {
          if ("function" != typeof e || "function" != typeof e.create)
            throw new Error("Hash should be wrapped by utils.wrapConstructor");
          r(e.outputLen), r(e.blockLen);
        }
        function o(e, t = !0) {
          if (e.destroyed) throw new Error("Hash instance has been destroyed");
          if (t && e.finished)
            throw new Error("Hash#digest() has already been called");
        }
        function a(e, t) {
          i(e);
          const r = t.outputLen;
          if (e.length < r)
            throw new Error(
              `digestInto() expects output buffer of length at least ${r}`,
            );
        }
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.output = t.exists = t.hash = t.bytes = t.bool = t.number = void 0),
          (t.number = r),
          (t.bool = n),
          (t.bytes = i),
          (t.hash = s),
          (t.exists = o),
          (t.output = a);
        const c = {
          number: r,
          bool: n,
          bytes: i,
          hash: s,
          exists: o,
          output: a,
        };
        t.default = c;
      },
      7505: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SHA2 = void 0);
        const n = r(7320),
          i = r(8089);
        class s extends i.Hash {
          constructor(e, t, r, n) {
            super(),
              (this.blockLen = e),
              (this.outputLen = t),
              (this.padOffset = r),
              (this.isLE = n),
              (this.finished = !1),
              (this.length = 0),
              (this.pos = 0),
              (this.destroyed = !1),
              (this.buffer = new Uint8Array(e)),
              (this.view = (0, i.createView)(this.buffer));
          }
          update(e) {
            n.default.exists(this);
            const { view: t, buffer: r, blockLen: s } = this,
              o = (e = (0, i.toBytes)(e)).length;
            for (let n = 0; n < o; ) {
              const a = Math.min(s - this.pos, o - n);
              if (a !== s)
                r.set(e.subarray(n, n + a), this.pos),
                  (this.pos += a),
                  (n += a),
                  this.pos === s && (this.process(t, 0), (this.pos = 0));
              else {
                const t = (0, i.createView)(e);
                for (; s <= o - n; n += s) this.process(t, n);
              }
            }
            return (this.length += e.length), this.roundClean(), this;
          }
          digestInto(e) {
            n.default.exists(this),
              n.default.output(e, this),
              (this.finished = !0);
            const { buffer: t, view: r, blockLen: s, isLE: o } = this;
            let { pos: a } = this;
            (t[a++] = 128),
              this.buffer.subarray(a).fill(0),
              this.padOffset > s - a && (this.process(r, 0), (a = 0));
            for (let e = a; e < s; e++) t[e] = 0;
            !(function (e, t, r, n) {
              if ("function" == typeof e.setBigUint64)
                return e.setBigUint64(t, r, n);
              const i = BigInt(32),
                s = BigInt(4294967295),
                o = Number((r >> i) & s),
                a = Number(r & s),
                c = n ? 4 : 0,
                d = n ? 0 : 4;
              e.setUint32(t + c, o, n), e.setUint32(t + d, a, n);
            })(r, s - 8, BigInt(8 * this.length), o),
              this.process(r, 0);
            const c = (0, i.createView)(e),
              d = this.outputLen;
            if (d % 4)
              throw new Error("_sha2: outputLen should be aligned to 32bit");
            const u = d / 4,
              l = this.get();
            if (u > l.length)
              throw new Error("_sha2: outputLen bigger than state");
            for (let e = 0; e < u; e++) c.setUint32(4 * e, l[e], o);
          }
          digest() {
            const { buffer: e, outputLen: t } = this;
            this.digestInto(e);
            const r = e.slice(0, t);
            return this.destroy(), r;
          }
          _cloneInto(e) {
            e || (e = new this.constructor()), e.set(...this.get());
            const {
              blockLen: t,
              buffer: r,
              length: n,
              finished: i,
              destroyed: s,
              pos: o,
            } = this;
            return (
              (e.length = n),
              (e.pos = o),
              (e.finished = i),
              (e.destroyed = s),
              n % t && e.buffer.set(r),
              e
            );
          }
        }
        t.SHA2 = s;
      },
      6873: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.add = t.toBig = t.split = t.fromBig = void 0);
        const r = BigInt(2 ** 32 - 1),
          n = BigInt(32);
        function i(e, t = !1) {
          return t
            ? { h: Number(e & r), l: Number((e >> n) & r) }
            : { h: 0 | Number((e >> n) & r), l: 0 | Number(e & r) };
        }
        function s(e, t = !1) {
          let r = new Uint32Array(e.length),
            n = new Uint32Array(e.length);
          for (let s = 0; s < e.length; s++) {
            const { h: o, l: a } = i(e[s], t);
            [r[s], n[s]] = [o, a];
          }
          return [r, n];
        }
        function o(e, t, r, n) {
          const i = (t >>> 0) + (n >>> 0);
          return { h: (e + r + ((i / 2 ** 32) | 0)) | 0, l: 0 | i };
        }
        (t.fromBig = i),
          (t.split = s),
          (t.toBig = (e, t) => (BigInt(e >>> 0) << n) | BigInt(t >>> 0)),
          (t.add = o);
        const a = {
          fromBig: i,
          split: s,
          toBig: t.toBig,
          shrSH: (e, t, r) => e >>> r,
          shrSL: (e, t, r) => (e << (32 - r)) | (t >>> r),
          rotrSH: (e, t, r) => (e >>> r) | (t << (32 - r)),
          rotrSL: (e, t, r) => (e << (32 - r)) | (t >>> r),
          rotrBH: (e, t, r) => (e << (64 - r)) | (t >>> (r - 32)),
          rotrBL: (e, t, r) => (e >>> (r - 32)) | (t << (64 - r)),
          rotr32H: (e, t) => t,
          rotr32L: (e, t) => e,
          rotlSH: (e, t, r) => (e << r) | (t >>> (32 - r)),
          rotlSL: (e, t, r) => (t << r) | (e >>> (32 - r)),
          rotlBH: (e, t, r) => (t << (r - 32)) | (e >>> (64 - r)),
          rotlBL: (e, t, r) => (e << (r - 32)) | (t >>> (64 - r)),
          add: o,
          add3L: (e, t, r) => (e >>> 0) + (t >>> 0) + (r >>> 0),
          add3H: (e, t, r, n) => (t + r + n + ((e / 2 ** 32) | 0)) | 0,
          add4L: (e, t, r, n) => (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0),
          add4H: (e, t, r, n, i) => (t + r + n + i + ((e / 2 ** 32) | 0)) | 0,
          add5H: (e, t, r, n, i, s) =>
            (t + r + n + i + s + ((e / 2 ** 32) | 0)) | 0,
          add5L: (e, t, r, n, i) =>
            (e >>> 0) + (t >>> 0) + (r >>> 0) + (n >>> 0) + (i >>> 0),
        };
        t.default = a;
      },
      1945: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.crypto = void 0),
          (t.crypto =
            "object" == typeof globalThis && "crypto" in globalThis
              ? globalThis.crypto
              : void 0);
      },
      9569: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.hmac = t.HMAC = void 0);
        const n = r(7320),
          i = r(8089);
        class s extends i.Hash {
          constructor(e, t) {
            super(),
              (this.finished = !1),
              (this.destroyed = !1),
              n.default.hash(e);
            const r = (0, i.toBytes)(t);
            if (
              ((this.iHash = e.create()),
              "function" != typeof this.iHash.update)
            )
              throw new Error(
                "Expected instance of class which extends utils.Hash",
              );
            (this.blockLen = this.iHash.blockLen),
              (this.outputLen = this.iHash.outputLen);
            const s = this.blockLen,
              o = new Uint8Array(s);
            o.set(r.length > s ? e.create().update(r).digest() : r);
            for (let e = 0; e < o.length; e++) o[e] ^= 54;
            this.iHash.update(o), (this.oHash = e.create());
            for (let e = 0; e < o.length; e++) o[e] ^= 106;
            this.oHash.update(o), o.fill(0);
          }
          update(e) {
            return n.default.exists(this), this.iHash.update(e), this;
          }
          digestInto(e) {
            n.default.exists(this),
              n.default.bytes(e, this.outputLen),
              (this.finished = !0),
              this.iHash.digestInto(e),
              this.oHash.update(e),
              this.oHash.digestInto(e),
              this.destroy();
          }
          digest() {
            const e = new Uint8Array(this.oHash.outputLen);
            return this.digestInto(e), e;
          }
          _cloneInto(e) {
            e || (e = Object.create(Object.getPrototypeOf(this), {}));
            const {
              oHash: t,
              iHash: r,
              finished: n,
              destroyed: i,
              blockLen: s,
              outputLen: o,
            } = this;
            return (
              (e.finished = n),
              (e.destroyed = i),
              (e.blockLen = s),
              (e.outputLen = o),
              (e.oHash = t._cloneInto(e.oHash)),
              (e.iHash = r._cloneInto(e.iHash)),
              e
            );
          }
          destroy() {
            (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
          }
        }
        (t.HMAC = s),
          (t.hmac = (e, t, r) => new s(e, t).update(r).digest()),
          (t.hmac.create = (e, t) => new s(e, t));
      },
      9023: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.pbkdf2Async = t.pbkdf2 = void 0);
        const n = r(7320),
          i = r(9569),
          s = r(8089);
        function o(e, t, r, o) {
          n.default.hash(e);
          const a = (0, s.checkOpts)({ dkLen: 32, asyncTick: 10 }, o),
            { c, dkLen: d, asyncTick: u } = a;
          if (
            (n.default.number(c),
            n.default.number(d),
            n.default.number(u),
            c < 1)
          )
            throw new Error("PBKDF2: iterations (c) should be >= 1");
          const l = (0, s.toBytes)(t),
            h = (0, s.toBytes)(r),
            f = new Uint8Array(d),
            p = i.hmac.create(e, l),
            m = p._cloneInto().update(h);
          return { c, dkLen: d, asyncTick: u, DK: f, PRF: p, PRFSalt: m };
        }
        function a(e, t, r, n, i) {
          return e.destroy(), t.destroy(), n && n.destroy(), i.fill(0), r;
        }
        (t.pbkdf2 = function (e, t, r, n) {
          const { c: i, dkLen: c, DK: d, PRF: u, PRFSalt: l } = o(e, t, r, n);
          let h;
          const f = new Uint8Array(4),
            p = (0, s.createView)(f),
            m = new Uint8Array(u.outputLen);
          for (let e = 1, t = 0; t < c; e++, t += u.outputLen) {
            const r = d.subarray(t, t + u.outputLen);
            p.setInt32(0, e, !1),
              (h = l._cloneInto(h)).update(f).digestInto(m),
              r.set(m.subarray(0, r.length));
            for (let e = 1; e < i; e++) {
              u._cloneInto(h).update(m).digestInto(m);
              for (let e = 0; e < r.length; e++) r[e] ^= m[e];
            }
          }
          return a(u, l, d, h, m);
        }),
          (t.pbkdf2Async = async function (e, t, r, n) {
            const {
              c: i,
              dkLen: c,
              asyncTick: d,
              DK: u,
              PRF: l,
              PRFSalt: h,
            } = o(e, t, r, n);
            let f;
            const p = new Uint8Array(4),
              m = (0, s.createView)(p),
              y = new Uint8Array(l.outputLen);
            for (let e = 1, t = 0; t < c; e++, t += l.outputLen) {
              const r = u.subarray(t, t + l.outputLen);
              m.setInt32(0, e, !1),
                (f = h._cloneInto(f)).update(p).digestInto(y),
                r.set(y.subarray(0, r.length)),
                await (0, s.asyncLoop)(i - 1, d, (e) => {
                  l._cloneInto(f).update(y).digestInto(y);
                  for (let e = 0; e < r.length; e++) r[e] ^= y[e];
                });
            }
            return a(l, h, u, f, y);
          });
      },
      9514: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.scryptAsync = t.scrypt = void 0);
        const n = r(7320),
          i = r(3061),
          s = r(9023),
          o = r(8089),
          a = (e, t) => (e << t) | (e >>> (32 - t));
        function c(e, t, r, n, i, s) {
          let o = e[t++] ^ r[n++],
            c = e[t++] ^ r[n++],
            d = e[t++] ^ r[n++],
            u = e[t++] ^ r[n++],
            l = e[t++] ^ r[n++],
            h = e[t++] ^ r[n++],
            f = e[t++] ^ r[n++],
            p = e[t++] ^ r[n++],
            m = e[t++] ^ r[n++],
            y = e[t++] ^ r[n++],
            g = e[t++] ^ r[n++],
            v = e[t++] ^ r[n++],
            b = e[t++] ^ r[n++],
            w = e[t++] ^ r[n++],
            E = e[t++] ^ r[n++],
            A = e[t++] ^ r[n++],
            _ = o,
            T = c,
            R = d,
            I = u,
            S = l,
            x = h,
            P = f,
            O = p,
            C = m,
            k = y,
            M = g,
            N = v,
            B = b,
            D = w,
            j = E,
            L = A;
          for (let e = 0; e < 8; e += 2)
            (S ^= a((_ + B) | 0, 7)),
              (C ^= a((S + _) | 0, 9)),
              (B ^= a((C + S) | 0, 13)),
              (_ ^= a((B + C) | 0, 18)),
              (k ^= a((x + T) | 0, 7)),
              (D ^= a((k + x) | 0, 9)),
              (T ^= a((D + k) | 0, 13)),
              (x ^= a((T + D) | 0, 18)),
              (j ^= a((M + P) | 0, 7)),
              (R ^= a((j + M) | 0, 9)),
              (P ^= a((R + j) | 0, 13)),
              (M ^= a((P + R) | 0, 18)),
              (I ^= a((L + N) | 0, 7)),
              (O ^= a((I + L) | 0, 9)),
              (N ^= a((O + I) | 0, 13)),
              (L ^= a((N + O) | 0, 18)),
              (T ^= a((_ + I) | 0, 7)),
              (R ^= a((T + _) | 0, 9)),
              (I ^= a((R + T) | 0, 13)),
              (_ ^= a((I + R) | 0, 18)),
              (P ^= a((x + S) | 0, 7)),
              (O ^= a((P + x) | 0, 9)),
              (S ^= a((O + P) | 0, 13)),
              (x ^= a((S + O) | 0, 18)),
              (N ^= a((M + k) | 0, 7)),
              (C ^= a((N + M) | 0, 9)),
              (k ^= a((C + N) | 0, 13)),
              (M ^= a((k + C) | 0, 18)),
              (B ^= a((L + j) | 0, 7)),
              (D ^= a((B + L) | 0, 9)),
              (j ^= a((D + B) | 0, 13)),
              (L ^= a((j + D) | 0, 18));
          (i[s++] = (o + _) | 0),
            (i[s++] = (c + T) | 0),
            (i[s++] = (d + R) | 0),
            (i[s++] = (u + I) | 0),
            (i[s++] = (l + S) | 0),
            (i[s++] = (h + x) | 0),
            (i[s++] = (f + P) | 0),
            (i[s++] = (p + O) | 0),
            (i[s++] = (m + C) | 0),
            (i[s++] = (y + k) | 0),
            (i[s++] = (g + M) | 0),
            (i[s++] = (v + N) | 0),
            (i[s++] = (b + B) | 0),
            (i[s++] = (w + D) | 0),
            (i[s++] = (E + j) | 0),
            (i[s++] = (A + L) | 0);
        }
        function d(e, t, r, n, i) {
          let s = n + 0,
            o = n + 16 * i;
          for (let n = 0; n < 16; n++) r[o + n] = e[t + 16 * (2 * i - 1) + n];
          for (let n = 0; n < i; n++, s += 16, t += 16)
            c(r, o, e, t, r, s),
              n > 0 && (o += 16),
              c(r, s, e, (t += 16), r, o);
        }
        function u(e, t, r) {
          const a = (0, o.checkOpts)(
              { dkLen: 32, asyncTick: 10, maxmem: 1073742848 },
              r,
            ),
            {
              N: c,
              r: d,
              p: u,
              dkLen: l,
              asyncTick: h,
              maxmem: f,
              onProgress: p,
            } = a;
          if (
            (n.default.number(c),
            n.default.number(d),
            n.default.number(u),
            n.default.number(l),
            n.default.number(h),
            n.default.number(f),
            void 0 !== p && "function" != typeof p)
          )
            throw new Error("progressCb should be function");
          const m = 128 * d,
            y = m / 4;
          if (c <= 1 || 0 != (c & (c - 1)) || c >= 2 ** (m / 8) || c > 2 ** 32)
            throw new Error(
              "Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32",
            );
          if (u < 0 || u > 137438953440 / m)
            throw new Error(
              "Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)",
            );
          if (l < 0 || l > 137438953440)
            throw new Error(
              "Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32",
            );
          const g = m * (c + u);
          if (g > f)
            throw new Error(
              `Scrypt: parameters too large, ${g} (128 * r * (N + p)) > ${f} (maxmem)`,
            );
          const v = (0, s.pbkdf2)(i.sha256, e, t, { c: 1, dkLen: m * u }),
            b = (0, o.u32)(v),
            w = (0, o.u32)(new Uint8Array(m * c)),
            E = (0, o.u32)(new Uint8Array(m));
          let A = () => {};
          if (p) {
            const e = 2 * c * u,
              t = Math.max(Math.floor(e / 1e4), 1);
            let r = 0;
            A = () => {
              r++, !p || (r % t && r !== e) || p(r / e);
            };
          }
          return {
            N: c,
            r: d,
            p: u,
            dkLen: l,
            blockSize32: y,
            V: w,
            B32: b,
            B: v,
            tmp: E,
            blockMixCb: A,
            asyncTick: h,
          };
        }
        function l(e, t, r, n, o) {
          const a = (0, s.pbkdf2)(i.sha256, e, r, { c: 1, dkLen: t });
          return r.fill(0), n.fill(0), o.fill(0), a;
        }
        (t.scrypt = function (e, t, r) {
          const {
            N: n,
            r: i,
            p: s,
            dkLen: o,
            blockSize32: a,
            V: c,
            B32: h,
            B: f,
            tmp: p,
            blockMixCb: m,
          } = u(e, t, r);
          for (let e = 0; e < s; e++) {
            const t = a * e;
            for (let e = 0; e < a; e++) c[e] = h[t + e];
            for (let e = 0, t = 0; e < n - 1; e++) d(c, t, c, (t += a), i), m();
            d(c, (n - 1) * a, h, t, i), m();
            for (let e = 0; e < n; e++) {
              const e = h[t + a - 16] % n;
              for (let r = 0; r < a; r++) p[r] = h[t + r] ^ c[e * a + r];
              d(p, 0, h, t, i), m();
            }
          }
          return l(e, o, f, c, p);
        }),
          (t.scryptAsync = async function (e, t, r) {
            const {
              N: n,
              r: i,
              p: s,
              dkLen: a,
              blockSize32: c,
              V: h,
              B32: f,
              B: p,
              tmp: m,
              blockMixCb: y,
              asyncTick: g,
            } = u(e, t, r);
            for (let e = 0; e < s; e++) {
              const t = c * e;
              for (let e = 0; e < c; e++) h[e] = f[t + e];
              let r = 0;
              await (0, o.asyncLoop)(n - 1, g, (e) => {
                d(h, r, h, (r += c), i), y();
              }),
                d(h, (n - 1) * c, f, t, i),
                y(),
                await (0, o.asyncLoop)(n, g, (e) => {
                  const r = f[t + c - 16] % n;
                  for (let e = 0; e < c; e++) m[e] = f[t + e] ^ h[r * c + e];
                  d(m, 0, f, t, i), y();
                });
            }
            return l(e, a, p, h, m);
          });
      },
      3061: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.sha224 = t.sha256 = void 0);
        const n = r(7505),
          i = r(8089),
          s = (e, t, r) => (e & t) ^ (e & r) ^ (t & r),
          o = new Uint32Array([
            1116352408, 1899447441, 3049323471, 3921009573, 961987163,
            1508970993, 2453635748, 2870763221, 3624381080, 310598401,
            607225278, 1426881987, 1925078388, 2162078206, 2614888103,
            3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983,
            1249150122, 1555081692, 1996064986, 2554220882, 2821834349,
            2952996808, 3210313671, 3336571891, 3584528711, 113926993,
            338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700,
            1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
            3259730800, 3345764771, 3516065817, 3600352804, 4094571909,
            275423344, 430227734, 506948616, 659060556, 883997877, 958139571,
            1322822218, 1537002063, 1747873779, 1955562222, 2024104815,
            2227730452, 2361852424, 2428436474, 2756734187, 3204031479,
            3329325298,
          ]),
          a = new Uint32Array([
            1779033703, 3144134277, 1013904242, 2773480762, 1359893119,
            2600822924, 528734635, 1541459225,
          ]),
          c = new Uint32Array(64);
        class d extends n.SHA2 {
          constructor() {
            super(64, 32, 8, !1),
              (this.A = 0 | a[0]),
              (this.B = 0 | a[1]),
              (this.C = 0 | a[2]),
              (this.D = 0 | a[3]),
              (this.E = 0 | a[4]),
              (this.F = 0 | a[5]),
              (this.G = 0 | a[6]),
              (this.H = 0 | a[7]);
          }
          get() {
            const { A: e, B: t, C: r, D: n, E: i, F: s, G: o, H: a } = this;
            return [e, t, r, n, i, s, o, a];
          }
          set(e, t, r, n, i, s, o, a) {
            (this.A = 0 | e),
              (this.B = 0 | t),
              (this.C = 0 | r),
              (this.D = 0 | n),
              (this.E = 0 | i),
              (this.F = 0 | s),
              (this.G = 0 | o),
              (this.H = 0 | a);
          }
          process(e, t) {
            for (let r = 0; r < 16; r++, t += 4) c[r] = e.getUint32(t, !1);
            for (let e = 16; e < 64; e++) {
              const t = c[e - 15],
                r = c[e - 2],
                n = (0, i.rotr)(t, 7) ^ (0, i.rotr)(t, 18) ^ (t >>> 3),
                s = (0, i.rotr)(r, 17) ^ (0, i.rotr)(r, 19) ^ (r >>> 10);
              c[e] = (s + c[e - 7] + n + c[e - 16]) | 0;
            }
            let { A: r, B: n, C: a, D: d, E: u, F: l, G: h, H: f } = this;
            for (let e = 0; e < 64; e++) {
              const t =
                  (f +
                    ((0, i.rotr)(u, 6) ^
                      (0, i.rotr)(u, 11) ^
                      (0, i.rotr)(u, 25)) +
                    (((p = u) & l) ^ (~p & h)) +
                    o[e] +
                    c[e]) |
                  0,
                m =
                  (((0, i.rotr)(r, 2) ^
                    (0, i.rotr)(r, 13) ^
                    (0, i.rotr)(r, 22)) +
                    s(r, n, a)) |
                  0;
              (f = h),
                (h = l),
                (l = u),
                (u = (d + t) | 0),
                (d = a),
                (a = n),
                (n = r),
                (r = (t + m) | 0);
            }
            var p;
            (r = (r + this.A) | 0),
              (n = (n + this.B) | 0),
              (a = (a + this.C) | 0),
              (d = (d + this.D) | 0),
              (u = (u + this.E) | 0),
              (l = (l + this.F) | 0),
              (h = (h + this.G) | 0),
              (f = (f + this.H) | 0),
              this.set(r, n, a, d, u, l, h, f);
          }
          roundClean() {
            c.fill(0);
          }
          destroy() {
            this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
          }
        }
        class u extends d {
          constructor() {
            super(),
              (this.A = -1056596264),
              (this.B = 914150663),
              (this.C = 812702999),
              (this.D = -150054599),
              (this.E = -4191439),
              (this.F = 1750603025),
              (this.G = 1694076839),
              (this.H = -1090891868),
              (this.outputLen = 28);
          }
        }
        (t.sha256 = (0, i.wrapConstructor)(() => new d())),
          (t.sha224 = (0, i.wrapConstructor)(() => new u()));
      },
      5426: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.shake256 =
            t.shake128 =
            t.keccak_512 =
            t.keccak_384 =
            t.keccak_256 =
            t.keccak_224 =
            t.sha3_512 =
            t.sha3_384 =
            t.sha3_256 =
            t.sha3_224 =
            t.Keccak =
            t.keccakP =
              void 0);
        const n = r(7320),
          i = r(6873),
          s = r(8089),
          [o, a, c] = [[], [], []],
          d = BigInt(0),
          u = BigInt(1),
          l = BigInt(2),
          h = BigInt(7),
          f = BigInt(256),
          p = BigInt(113);
        for (let e = 0, t = u, r = 1, n = 0; e < 24; e++) {
          ([r, n] = [n, (2 * r + 3 * n) % 5]),
            o.push(2 * (5 * n + r)),
            a.push((((e + 1) * (e + 2)) / 2) % 64);
          let i = d;
          for (let e = 0; e < 7; e++)
            (t = ((t << u) ^ ((t >> h) * p)) % f),
              t & l && (i ^= u << ((u << BigInt(e)) - u));
          c.push(i);
        }
        const [m, y] = i.default.split(c, !0),
          g = (e, t, r) =>
            r > 32 ? i.default.rotlBH(e, t, r) : i.default.rotlSH(e, t, r),
          v = (e, t, r) =>
            r > 32 ? i.default.rotlBL(e, t, r) : i.default.rotlSL(e, t, r);
        function b(e, t = 24) {
          const r = new Uint32Array(10);
          for (let n = 24 - t; n < 24; n++) {
            for (let t = 0; t < 10; t++)
              r[t] = e[t] ^ e[t + 10] ^ e[t + 20] ^ e[t + 30] ^ e[t + 40];
            for (let t = 0; t < 10; t += 2) {
              const n = (t + 8) % 10,
                i = (t + 2) % 10,
                s = r[i],
                o = r[i + 1],
                a = g(s, o, 1) ^ r[n],
                c = v(s, o, 1) ^ r[n + 1];
              for (let r = 0; r < 50; r += 10)
                (e[t + r] ^= a), (e[t + r + 1] ^= c);
            }
            let t = e[2],
              i = e[3];
            for (let r = 0; r < 24; r++) {
              const n = a[r],
                s = g(t, i, n),
                c = v(t, i, n),
                d = o[r];
              (t = e[d]), (i = e[d + 1]), (e[d] = s), (e[d + 1] = c);
            }
            for (let t = 0; t < 50; t += 10) {
              for (let n = 0; n < 10; n++) r[n] = e[t + n];
              for (let n = 0; n < 10; n++)
                e[t + n] ^= ~r[(n + 2) % 10] & r[(n + 4) % 10];
            }
            (e[0] ^= m[n]), (e[1] ^= y[n]);
          }
          r.fill(0);
        }
        t.keccakP = b;
        class w extends s.Hash {
          constructor(e, t, r, i = !1, o = 24) {
            if (
              (super(),
              (this.blockLen = e),
              (this.suffix = t),
              (this.outputLen = r),
              (this.enableXOF = i),
              (this.rounds = o),
              (this.pos = 0),
              (this.posOut = 0),
              (this.finished = !1),
              (this.destroyed = !1),
              n.default.number(r),
              0 >= this.blockLen || this.blockLen >= 200)
            )
              throw new Error("Sha3 supports only keccak-f1600 function");
            (this.state = new Uint8Array(200)),
              (this.state32 = (0, s.u32)(this.state));
          }
          keccak() {
            b(this.state32, this.rounds), (this.posOut = 0), (this.pos = 0);
          }
          update(e) {
            n.default.exists(this);
            const { blockLen: t, state: r } = this,
              i = (e = (0, s.toBytes)(e)).length;
            for (let n = 0; n < i; ) {
              const s = Math.min(t - this.pos, i - n);
              for (let t = 0; t < s; t++) r[this.pos++] ^= e[n++];
              this.pos === t && this.keccak();
            }
            return this;
          }
          finish() {
            if (this.finished) return;
            this.finished = !0;
            const { state: e, suffix: t, pos: r, blockLen: n } = this;
            (e[r] ^= t),
              0 != (128 & t) && r === n - 1 && this.keccak(),
              (e[n - 1] ^= 128),
              this.keccak();
          }
          writeInto(e) {
            n.default.exists(this, !1), n.default.bytes(e), this.finish();
            const t = this.state,
              { blockLen: r } = this;
            for (let n = 0, i = e.length; n < i; ) {
              this.posOut >= r && this.keccak();
              const s = Math.min(r - this.posOut, i - n);
              e.set(t.subarray(this.posOut, this.posOut + s), n),
                (this.posOut += s),
                (n += s);
            }
            return e;
          }
          xofInto(e) {
            if (!this.enableXOF)
              throw new Error("XOF is not possible for this instance");
            return this.writeInto(e);
          }
          xof(e) {
            return n.default.number(e), this.xofInto(new Uint8Array(e));
          }
          digestInto(e) {
            if ((n.default.output(e, this), this.finished))
              throw new Error("digest() was already called");
            return this.writeInto(e), this.destroy(), e;
          }
          digest() {
            return this.digestInto(new Uint8Array(this.outputLen));
          }
          destroy() {
            (this.destroyed = !0), this.state.fill(0);
          }
          _cloneInto(e) {
            const {
              blockLen: t,
              suffix: r,
              outputLen: n,
              rounds: i,
              enableXOF: s,
            } = this;
            return (
              e || (e = new w(t, r, n, s, i)),
              e.state32.set(this.state32),
              (e.pos = this.pos),
              (e.posOut = this.posOut),
              (e.finished = this.finished),
              (e.rounds = i),
              (e.suffix = r),
              (e.outputLen = n),
              (e.enableXOF = s),
              (e.destroyed = this.destroyed),
              e
            );
          }
        }
        t.Keccak = w;
        const E = (e, t, r) => (0, s.wrapConstructor)(() => new w(t, e, r));
        (t.sha3_224 = E(6, 144, 28)),
          (t.sha3_256 = E(6, 136, 32)),
          (t.sha3_384 = E(6, 104, 48)),
          (t.sha3_512 = E(6, 72, 64)),
          (t.keccak_224 = E(1, 144, 28)),
          (t.keccak_256 = E(1, 136, 32)),
          (t.keccak_384 = E(1, 104, 48)),
          (t.keccak_512 = E(1, 72, 64));
        const A = (e, t, r) =>
          (0, s.wrapXOFConstructorWithOpts)(
            (n = {}) => new w(t, e, void 0 === n.dkLen ? r : n.dkLen, !0),
          );
        (t.shake128 = A(31, 168, 16)), (t.shake256 = A(31, 136, 32));
      },
      6262: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.sha384 =
            t.sha512_256 =
            t.sha512_224 =
            t.sha512 =
            t.SHA512 =
              void 0);
        const n = r(7505),
          i = r(6873),
          s = r(8089),
          [o, a] = i.default.split(
            [
              "0x428a2f98d728ae22",
              "0x7137449123ef65cd",
              "0xb5c0fbcfec4d3b2f",
              "0xe9b5dba58189dbbc",
              "0x3956c25bf348b538",
              "0x59f111f1b605d019",
              "0x923f82a4af194f9b",
              "0xab1c5ed5da6d8118",
              "0xd807aa98a3030242",
              "0x12835b0145706fbe",
              "0x243185be4ee4b28c",
              "0x550c7dc3d5ffb4e2",
              "0x72be5d74f27b896f",
              "0x80deb1fe3b1696b1",
              "0x9bdc06a725c71235",
              "0xc19bf174cf692694",
              "0xe49b69c19ef14ad2",
              "0xefbe4786384f25e3",
              "0x0fc19dc68b8cd5b5",
              "0x240ca1cc77ac9c65",
              "0x2de92c6f592b0275",
              "0x4a7484aa6ea6e483",
              "0x5cb0a9dcbd41fbd4",
              "0x76f988da831153b5",
              "0x983e5152ee66dfab",
              "0xa831c66d2db43210",
              "0xb00327c898fb213f",
              "0xbf597fc7beef0ee4",
              "0xc6e00bf33da88fc2",
              "0xd5a79147930aa725",
              "0x06ca6351e003826f",
              "0x142929670a0e6e70",
              "0x27b70a8546d22ffc",
              "0x2e1b21385c26c926",
              "0x4d2c6dfc5ac42aed",
              "0x53380d139d95b3df",
              "0x650a73548baf63de",
              "0x766a0abb3c77b2a8",
              "0x81c2c92e47edaee6",
              "0x92722c851482353b",
              "0xa2bfe8a14cf10364",
              "0xa81a664bbc423001",
              "0xc24b8b70d0f89791",
              "0xc76c51a30654be30",
              "0xd192e819d6ef5218",
              "0xd69906245565a910",
              "0xf40e35855771202a",
              "0x106aa07032bbd1b8",
              "0x19a4c116b8d2d0c8",
              "0x1e376c085141ab53",
              "0x2748774cdf8eeb99",
              "0x34b0bcb5e19b48a8",
              "0x391c0cb3c5c95a63",
              "0x4ed8aa4ae3418acb",
              "0x5b9cca4f7763e373",
              "0x682e6ff3d6b2b8a3",
              "0x748f82ee5defb2fc",
              "0x78a5636f43172f60",
              "0x84c87814a1f0ab72",
              "0x8cc702081a6439ec",
              "0x90befffa23631e28",
              "0xa4506cebde82bde9",
              "0xbef9a3f7b2c67915",
              "0xc67178f2e372532b",
              "0xca273eceea26619c",
              "0xd186b8c721c0c207",
              "0xeada7dd6cde0eb1e",
              "0xf57d4f7fee6ed178",
              "0x06f067aa72176fba",
              "0x0a637dc5a2c898a6",
              "0x113f9804bef90dae",
              "0x1b710b35131c471b",
              "0x28db77f523047d84",
              "0x32caab7b40c72493",
              "0x3c9ebe0a15c9bebc",
              "0x431d67c49c100d4c",
              "0x4cc5d4becb3e42b6",
              "0x597f299cfc657e2a",
              "0x5fcb6fab3ad6faec",
              "0x6c44198c4a475817",
            ].map((e) => BigInt(e)),
          ),
          c = new Uint32Array(80),
          d = new Uint32Array(80);
        class u extends n.SHA2 {
          constructor() {
            super(128, 64, 16, !1),
              (this.Ah = 1779033703),
              (this.Al = -205731576),
              (this.Bh = -1150833019),
              (this.Bl = -2067093701),
              (this.Ch = 1013904242),
              (this.Cl = -23791573),
              (this.Dh = -1521486534),
              (this.Dl = 1595750129),
              (this.Eh = 1359893119),
              (this.El = -1377402159),
              (this.Fh = -1694144372),
              (this.Fl = 725511199),
              (this.Gh = 528734635),
              (this.Gl = -79577749),
              (this.Hh = 1541459225),
              (this.Hl = 327033209);
          }
          get() {
            const {
              Ah: e,
              Al: t,
              Bh: r,
              Bl: n,
              Ch: i,
              Cl: s,
              Dh: o,
              Dl: a,
              Eh: c,
              El: d,
              Fh: u,
              Fl: l,
              Gh: h,
              Gl: f,
              Hh: p,
              Hl: m,
            } = this;
            return [e, t, r, n, i, s, o, a, c, d, u, l, h, f, p, m];
          }
          set(e, t, r, n, i, s, o, a, c, d, u, l, h, f, p, m) {
            (this.Ah = 0 | e),
              (this.Al = 0 | t),
              (this.Bh = 0 | r),
              (this.Bl = 0 | n),
              (this.Ch = 0 | i),
              (this.Cl = 0 | s),
              (this.Dh = 0 | o),
              (this.Dl = 0 | a),
              (this.Eh = 0 | c),
              (this.El = 0 | d),
              (this.Fh = 0 | u),
              (this.Fl = 0 | l),
              (this.Gh = 0 | h),
              (this.Gl = 0 | f),
              (this.Hh = 0 | p),
              (this.Hl = 0 | m);
          }
          process(e, t) {
            for (let r = 0; r < 16; r++, t += 4)
              (c[r] = e.getUint32(t)), (d[r] = e.getUint32((t += 4)));
            for (let e = 16; e < 80; e++) {
              const t = 0 | c[e - 15],
                r = 0 | d[e - 15],
                n =
                  i.default.rotrSH(t, r, 1) ^
                  i.default.rotrSH(t, r, 8) ^
                  i.default.shrSH(t, r, 7),
                s =
                  i.default.rotrSL(t, r, 1) ^
                  i.default.rotrSL(t, r, 8) ^
                  i.default.shrSL(t, r, 7),
                o = 0 | c[e - 2],
                a = 0 | d[e - 2],
                u =
                  i.default.rotrSH(o, a, 19) ^
                  i.default.rotrBH(o, a, 61) ^
                  i.default.shrSH(o, a, 6),
                l =
                  i.default.rotrSL(o, a, 19) ^
                  i.default.rotrBL(o, a, 61) ^
                  i.default.shrSL(o, a, 6),
                h = i.default.add4L(s, l, d[e - 7], d[e - 16]),
                f = i.default.add4H(h, n, u, c[e - 7], c[e - 16]);
              (c[e] = 0 | f), (d[e] = 0 | h);
            }
            let {
              Ah: r,
              Al: n,
              Bh: s,
              Bl: u,
              Ch: l,
              Cl: h,
              Dh: f,
              Dl: p,
              Eh: m,
              El: y,
              Fh: g,
              Fl: v,
              Gh: b,
              Gl: w,
              Hh: E,
              Hl: A,
            } = this;
            for (let e = 0; e < 80; e++) {
              const t =
                  i.default.rotrSH(m, y, 14) ^
                  i.default.rotrSH(m, y, 18) ^
                  i.default.rotrBH(m, y, 41),
                _ =
                  i.default.rotrSL(m, y, 14) ^
                  i.default.rotrSL(m, y, 18) ^
                  i.default.rotrBL(m, y, 41),
                T = (m & g) ^ (~m & b),
                R = (y & v) ^ (~y & w),
                I = i.default.add5L(A, _, R, a[e], d[e]),
                S = i.default.add5H(I, E, t, T, o[e], c[e]),
                x = 0 | I,
                P =
                  i.default.rotrSH(r, n, 28) ^
                  i.default.rotrBH(r, n, 34) ^
                  i.default.rotrBH(r, n, 39),
                O =
                  i.default.rotrSL(r, n, 28) ^
                  i.default.rotrBL(r, n, 34) ^
                  i.default.rotrBL(r, n, 39),
                C = (r & s) ^ (r & l) ^ (s & l),
                k = (n & u) ^ (n & h) ^ (u & h);
              (E = 0 | b),
                (A = 0 | w),
                (b = 0 | g),
                (w = 0 | v),
                (g = 0 | m),
                (v = 0 | y),
                ({ h: m, l: y } = i.default.add(0 | f, 0 | p, 0 | S, 0 | x)),
                (f = 0 | l),
                (p = 0 | h),
                (l = 0 | s),
                (h = 0 | u),
                (s = 0 | r),
                (u = 0 | n);
              const M = i.default.add3L(x, O, k);
              (r = i.default.add3H(M, S, P, C)), (n = 0 | M);
            }
            ({ h: r, l: n } = i.default.add(
              0 | this.Ah,
              0 | this.Al,
              0 | r,
              0 | n,
            )),
              ({ h: s, l: u } = i.default.add(
                0 | this.Bh,
                0 | this.Bl,
                0 | s,
                0 | u,
              )),
              ({ h: l, l: h } = i.default.add(
                0 | this.Ch,
                0 | this.Cl,
                0 | l,
                0 | h,
              )),
              ({ h: f, l: p } = i.default.add(
                0 | this.Dh,
                0 | this.Dl,
                0 | f,
                0 | p,
              )),
              ({ h: m, l: y } = i.default.add(
                0 | this.Eh,
                0 | this.El,
                0 | m,
                0 | y,
              )),
              ({ h: g, l: v } = i.default.add(
                0 | this.Fh,
                0 | this.Fl,
                0 | g,
                0 | v,
              )),
              ({ h: b, l: w } = i.default.add(
                0 | this.Gh,
                0 | this.Gl,
                0 | b,
                0 | w,
              )),
              ({ h: E, l: A } = i.default.add(
                0 | this.Hh,
                0 | this.Hl,
                0 | E,
                0 | A,
              )),
              this.set(r, n, s, u, l, h, f, p, m, y, g, v, b, w, E, A);
          }
          roundClean() {
            c.fill(0), d.fill(0);
          }
          destroy() {
            this.buffer.fill(0),
              this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          }
        }
        t.SHA512 = u;
        class l extends u {
          constructor() {
            super(),
              (this.Ah = -1942145080),
              (this.Al = 424955298),
              (this.Bh = 1944164710),
              (this.Bl = -1982016298),
              (this.Ch = 502970286),
              (this.Cl = 855612546),
              (this.Dh = 1738396948),
              (this.Dl = 1479516111),
              (this.Eh = 258812777),
              (this.El = 2077511080),
              (this.Fh = 2011393907),
              (this.Fl = 79989058),
              (this.Gh = 1067287976),
              (this.Gl = 1780299464),
              (this.Hh = 286451373),
              (this.Hl = -1848208735),
              (this.outputLen = 28);
          }
        }
        class h extends u {
          constructor() {
            super(),
              (this.Ah = 573645204),
              (this.Al = -64227540),
              (this.Bh = -1621794909),
              (this.Bl = -934517566),
              (this.Ch = 596883563),
              (this.Cl = 1867755857),
              (this.Dh = -1774684391),
              (this.Dl = 1497426621),
              (this.Eh = -1775747358),
              (this.El = -1467023389),
              (this.Fh = -1101128155),
              (this.Fl = 1401305490),
              (this.Gh = 721525244),
              (this.Gl = 746961066),
              (this.Hh = 246885852),
              (this.Hl = -2117784414),
              (this.outputLen = 32);
          }
        }
        class f extends u {
          constructor() {
            super(),
              (this.Ah = -876896931),
              (this.Al = -1056596264),
              (this.Bh = 1654270250),
              (this.Bl = 914150663),
              (this.Ch = -1856437926),
              (this.Cl = 812702999),
              (this.Dh = 355462360),
              (this.Dl = -150054599),
              (this.Eh = 1731405415),
              (this.El = -4191439),
              (this.Fh = -1900787065),
              (this.Fl = 1750603025),
              (this.Gh = -619958771),
              (this.Gl = 1694076839),
              (this.Hh = 1203062813),
              (this.Hl = -1090891868),
              (this.outputLen = 48);
          }
        }
        (t.sha512 = (0, s.wrapConstructor)(() => new u())),
          (t.sha512_224 = (0, s.wrapConstructor)(() => new l())),
          (t.sha512_256 = (0, s.wrapConstructor)(() => new h())),
          (t.sha384 = (0, s.wrapConstructor)(() => new f()));
      },
      8089: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.randomBytes =
            t.wrapXOFConstructorWithOpts =
            t.wrapConstructorWithOpts =
            t.wrapConstructor =
            t.checkOpts =
            t.Hash =
            t.concatBytes =
            t.toBytes =
            t.utf8ToBytes =
            t.asyncLoop =
            t.nextTick =
            t.hexToBytes =
            t.bytesToHex =
            t.isLE =
            t.rotr =
            t.createView =
            t.u32 =
            t.u8 =
              void 0);
        const n = r(1945),
          i = (e) => e instanceof Uint8Array;
        if (
          ((t.u8 = (e) => new Uint8Array(e.buffer, e.byteOffset, e.byteLength)),
          (t.u32 = (e) =>
            new Uint32Array(
              e.buffer,
              e.byteOffset,
              Math.floor(e.byteLength / 4),
            )),
          (t.createView = (e) =>
            new DataView(e.buffer, e.byteOffset, e.byteLength)),
          (t.rotr = (e, t) => (e << (32 - t)) | (e >>> t)),
          (t.isLE =
            68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0]),
          !t.isLE)
        )
          throw new Error("Non little-endian hardware is not supported");
        const s = Array.from({ length: 256 }, (e, t) =>
          t.toString(16).padStart(2, "0"),
        );
        function o(e) {
          if ("string" != typeof e)
            throw new Error("utf8ToBytes expected string, got " + typeof e);
          return new Uint8Array(new TextEncoder().encode(e));
        }
        function a(e) {
          if (("string" == typeof e && (e = o(e)), !i(e)))
            throw new Error("expected Uint8Array, got " + typeof e);
          return e;
        }
        (t.bytesToHex = function (e) {
          if (!i(e)) throw new Error("Uint8Array expected");
          let t = "";
          for (let r = 0; r < e.length; r++) t += s[e[r]];
          return t;
        }),
          (t.hexToBytes = function (e) {
            if ("string" != typeof e)
              throw new Error("hex string expected, got " + typeof e);
            const t = e.length;
            if (t % 2)
              throw new Error(
                "padded hex string expected, got unpadded hex of length " + t,
              );
            const r = new Uint8Array(t / 2);
            for (let t = 0; t < r.length; t++) {
              const n = 2 * t,
                i = e.slice(n, n + 2),
                s = Number.parseInt(i, 16);
              if (Number.isNaN(s) || s < 0)
                throw new Error("Invalid byte sequence");
              r[t] = s;
            }
            return r;
          }),
          (t.nextTick = async () => {}),
          (t.asyncLoop = async function (e, r, n) {
            let i = Date.now();
            for (let s = 0; s < e; s++) {
              n(s);
              const e = Date.now() - i;
              (e >= 0 && e < r) || (await (0, t.nextTick)(), (i += e));
            }
          }),
          (t.utf8ToBytes = o),
          (t.toBytes = a),
          (t.concatBytes = function (...e) {
            const t = new Uint8Array(e.reduce((e, t) => e + t.length, 0));
            let r = 0;
            return (
              e.forEach((e) => {
                if (!i(e)) throw new Error("Uint8Array expected");
                t.set(e, r), (r += e.length);
              }),
              t
            );
          }),
          (t.Hash = class {
            clone() {
              return this._cloneInto();
            }
          }),
          (t.checkOpts = function (e, t) {
            if (
              void 0 !== t &&
              ("object" != typeof t ||
                ((r = t),
                "[object Object]" !== Object.prototype.toString.call(r) ||
                  r.constructor !== Object))
            )
              throw new Error("Options should be object or undefined");
            var r;
            return Object.assign(e, t);
          }),
          (t.wrapConstructor = function (e) {
            const t = (t) => e().update(a(t)).digest(),
              r = e();
            return (
              (t.outputLen = r.outputLen),
              (t.blockLen = r.blockLen),
              (t.create = () => e()),
              t
            );
          }),
          (t.wrapConstructorWithOpts = function (e) {
            const t = (t, r) => e(r).update(a(t)).digest(),
              r = e({});
            return (
              (t.outputLen = r.outputLen),
              (t.blockLen = r.blockLen),
              (t.create = (t) => e(t)),
              t
            );
          }),
          (t.wrapXOFConstructorWithOpts = function (e) {
            const t = (t, r) => e(r).update(a(t)).digest(),
              r = e({});
            return (
              (t.outputLen = r.outputLen),
              (t.blockLen = r.blockLen),
              (t.create = (t) => e(t)),
              t
            );
          }),
          (t.randomBytes = function (e = 32) {
            if (n.crypto && "function" == typeof n.crypto.getRandomValues)
              return n.crypto.getRandomValues(new Uint8Array(e));
            throw new Error("crypto.getRandomValues must be defined");
          });
      },
      5704: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.invalidEnumField =
            t.noSuperClassForVariant =
            t.extendedReaderNotFound =
            t.extendedWriterNotFound =
            t.unexpectedFieldSchema =
            t.invalidByteArrayLength =
              void 0),
          (t.invalidByteArrayLength = function (e, t, r) {
            throw new Error(
              `Borsh: Invalid byte array length at: ${e.join(
                ",",
              )}, expected: ${t}, actual: ${r}`,
            );
          }),
          (t.unexpectedFieldSchema = function (e, t, r) {
            throw new Error(
              `Borsh: Found an unexpected schema at: ${e.join(
                ",",
              )}, expected: ${t}, actual: ${r}`,
            );
          }),
          (t.extendedWriterNotFound = function (e) {
            throw new Error(
              `Borsh: Extended writer not found at: ${e.join(",")}`,
            );
          }),
          (t.extendedReaderNotFound = function (e) {
            throw new Error(
              `Borsh: Extended reader not found at: ${e.join(",")}`,
            );
          }),
          (t.noSuperClassForVariant = function (e) {
            throw new Error(
              `Borsh: No super class available for class ${e} which is decorated as variant`,
            );
          }),
          (t.invalidEnumField = function (e) {
            throw new Error(
              `Borsh: Invalid enum field type at: ${e.join(",")}`,
            );
          });
      },
      1786: function (e, t, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (e, t, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(t, r);
                  (i &&
                    !("get" in i
                      ? !t.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return t[r];
                      },
                    }),
                    Object.defineProperty(e, n, i);
                }
              : function (e, t, r, n) {
                  void 0 === n && (n = r), (e[n] = t[r]);
                }),
          i =
            (this && this.__exportStar) ||
            function (e, t) {
              for (var r in e)
                "default" === r ||
                  Object.prototype.hasOwnProperty.call(t, r) ||
                  n(t, e, r);
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.deserialize =
            t.serialize =
            t.enums =
            t.struct =
            t.option =
            t.map =
            t.array =
            t.extend =
            t.variant =
            t.field =
              void 0);
        const s = r(9055),
          o = r(4398),
          a = r(2716),
          c = r(5704);
        function d(e) {
          return e.__schema_fields || [];
        }
        function u(e) {
          return e.__schema_variant;
        }
        function l(e) {
          return e.__schema_enum_variants;
        }
        function h(e, t, r, n) {
          if ((0, s.isPrimitiveType)(r)) {
            if ("u8" === r) n.writeU8(t);
            else if ("u16" === r) n.writeU16(t);
            else if ("u32" === r) n.writeU32(t);
            else if ("u64" === r) n.writeU64(t);
            else if ("usize" === r) n.writeU64(BigInt(t));
            else if ("bool" === r) n.writeBool(t);
            else if ("string" === r) n.writeString(t);
            else if ("u8-array" === r) {
              n.writeU32(t.length);
              for (let e = 0; e < t.length; e++) n.writeU8(t[e]);
            }
          } else if ("number" == typeof r)
            t.length !== r && (0, c.invalidByteArrayLength)(e, r, t.length),
              n.writeByteArray(t);
          else {
            const { kind: i, value: o } = r;
            if ("option" === i)
              null == t
                ? n.writeU8(0)
                : (n.writeU8(1), h([...e, "<OptionValue>"], t, o, n));
            else if ("array" === i) {
              n.writeU32(t.length);
              for (let r = 0; r < t.length; r++)
                h([...e, `<Array[${r}]>`], t[r], o, n);
            } else if ("struct" === i) g(e, t, n);
            else if ("enum" === i) y(e, t, n);
            else if ("map" === i) {
              n.writeU32(t.size);
              const [r, i] = o;
              for (const [s, o] of t)
                h([...e, "<Map[key]>"], s, r, n),
                  h([...e, "<Map[value]>"], o, i, n);
            } else
              "extend" === i &&
                ((0, s.hasExtendWriter)(o)
                  ? n.writeExtended(t, o)
                  : (0, c.extendedWriterNotFound)(e));
          }
        }
        function f(e, t, r) {
          if ((0, s.isPrimitiveType)(t)) {
            if ("u8" === t) return r.readU8();
            if ("u16" === t) return r.readU16();
            if ("u32" === t) return r.readU32();
            if ("u64" === t) return r.readU64();
            if ("bool" === t) return r.readBool();
            if ("usize" === t) return Number(r.readU64());
            if ("string" === t) return r.readString();
            if ("u8-array" === t) {
              let e = [];
              const t = r.readU32();
              for (let n = 0; n < t; n++) {
                let t = r.readU8();
                e.push(t);
              }
              return Uint8Array.from(e);
            }
          } else {
            if ("number" == typeof t) return r.readByteArray(t);
            {
              const { kind: n, value: i } = t;
              if ("array" === n) {
                let t = [];
                const n = r.readU32();
                for (let s = 0; s < n; s++) {
                  let n = f([...e, `<Array[${s}]>`], i, r);
                  t.push(n);
                }
                return t;
              }
              if ("option" === n)
                return r.readBool() ? f([...e, "<OptionValue>"], i, r) : void 0;
              if ("struct" === n) return b(e, i, r);
              if ("enum" === n) return v(e, i, r);
              if ("map" === n) {
                const t = r.readU32(),
                  [n, s] = i,
                  o = new Map();
                for (let i = 0; i < t; i++) {
                  let t = f([...e, "<Map[key]>"], n, r),
                    i = f([...e, "<Map[value]>"], s, r);
                  o.set(t, i);
                }
                return o;
              }
              if ("extend" === n) {
                if ((0, s.hasExtendReader)(i)) return r.readExtended(i);
                (0, c.extendedReaderNotFound)(e);
              }
            }
          }
        }
        function p(e, t, r, n) {
          const [i, s] = r,
            o = i.toString();
          h([...e, o], t[o], s, n);
        }
        function m(e, t, r, n) {
          const [i, s] = r,
            o = i.toString(),
            a = f([...e, o], s, n);
          return (t[o] = a), t;
        }
        function y(e, t, r) {
          const n = u(Object.getPrototypeOf(t));
          void 0 !== n
            ? (r.writeU8(n), g([...e, `<Variant[${n}]>`], t, r))
            : (0, c.invalidEnumField)(e);
        }
        function g(e, t, r) {
          const n = d(Object.getPrototypeOf(t));
          for (const i of n) p(e, t, i, r);
        }
        function v(e, t, r) {
          const n = l(t.prototype);
          if (n instanceof Array) {
            const t = r.readU8(),
              i = n[t];
            return b([...e, `<Variant[${t}]>`], i, r);
          }
          (0, c.invalidEnumField)(e);
        }
        function b(e, t, r) {
          const n = d(t.prototype);
          let i = {};
          for (const t of n) i = m(e, i, t, r);
          return new t(i);
        }
        (t.field = function (e) {
          return function (t, r) {
            !(function (e, t, r) {
              let n = e.__schema_fields || [];
              n.push([t, r]), (e.__schema_fields = n);
            })(t.constructor.prototype, r, e);
          };
        }),
          (t.variant = function (e) {
            return function (t) {
              !(function (e, t) {
                e.prototype.__schema_variant = t;
                const r = Object.getPrototypeOf(e.prototype).constructor;
                let n = r.prototype.__schema_enum_variants || [];
                n.push(e), (r.prototype.__schema_enum_variants = n);
              })(t, e);
            };
          }),
          (t.extend = function (e) {
            return { kind: "extend", value: e };
          }),
          (t.array = function (e) {
            return { kind: "array", value: e };
          }),
          (t.map = function (e, t) {
            return { kind: "map", value: [e, t] };
          }),
          (t.option = function (e) {
            return { kind: "option", value: e };
          }),
          (t.struct = function (e) {
            return { kind: "struct", value: e };
          }),
          (t.enums = function (e) {
            return { kind: "enum", value: e };
          }),
          (t.serialize = function (e) {
            const t = new o.BinaryWriter();
            return (
              (function (e) {
                return void 0 !== u(Object.getPrototypeOf(e));
              })(e)
                ? y([], e, t)
                : g([], e, t),
              t.toArray()
            );
          }),
          (t.deserialize = function (e, t) {
            const r = new a.BinaryReader(t);
            return void 0 !== l(e.prototype) ? v([], e, r) : b([], e, r);
          }),
          i(r(9055), t);
      },
      2716: function (e, t) {
        "use strict";
        var r,
          n,
          i =
            (this && this.__classPrivateFieldSet) ||
            function (e, t, r, n, i) {
              if ("m" === n)
                throw new TypeError("Private method is not writable");
              if ("a" === n && !i)
                throw new TypeError(
                  "Private accessor was defined without a setter",
                );
              if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError(
                  "Cannot write private member to an object whose class did not declare it",
                );
              return (
                "a" === n ? i.call(e, r) : i ? (i.value = r) : t.set(e, r), r
              );
            },
          s =
            (this && this.__classPrivateFieldGet) ||
            function (e, t, r, n) {
              if ("a" === r && !n)
                throw new TypeError(
                  "Private accessor was defined without a getter",
                );
              if ("function" == typeof t ? e !== t || !n : !t.has(e))
                throw new TypeError(
                  "Cannot read private member from an object whose class did not declare it",
                );
              return "m" === r
                ? n
                : "a" === r
                ? n.call(e)
                : n
                ? n.value
                : t.get(e);
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BinaryReader = t.readU64 = void 0);
        const o = new TextDecoder("utf8");
        function a(e, t) {
          const r =
            BigInt(e[t]) |
            (BigInt(e[t + 1]) << BigInt(8))|
            (BigInt(e[t + 2]) << BigInt(16)) |
            (BigInt(e[t + 3]) << BigInt(24)) |
            (BigInt(e[t + 4]) << BigInt(32)) |
            (BigInt(e[t + 5]) << BigInt(40)) |
            (BigInt(e[t + 6]) << BigInt(48)) |
            (BigInt(e[t + 7]) << BigInt(56));
          return (t += 8), r;
        }
        (t.readU64 = a),
          (t.BinaryReader = class {
            constructor(e) {
              r.set(this, void 0),
                n.set(this, void 0),
                i(this, r, e, "f"),
                i(this, n, 0, "f");
            }
            readBool() {
              const e = 1 == s(this, r, "f")[s(this, n, "f")];
              return i(this, n, s(this, n, "f") + 1, "f"), e;
            }
            readU8() {
              const e = s(this, r, "f")[s(this, n, "f")];
              return i(this, n, s(this, n, "f") + 1, "f"), e;
            }
            readU16() {
              const e =
                s(this, r, "f")[s(this, n, "f")] |
                (s(this, r, "f")[s(this, n, "f") + 1] << 8);
              return i(this, n, s(this, n, "f") + 2, "f"), e;
            }
            readU32() {
              const e =
                s(this, r, "f")[s(this, n, "f")] |
                (s(this, r, "f")[s(this, n, "f") + 1] << 8) |
                (s(this, r, "f")[s(this, n, "f") + 2] << 16) |
                (s(this, r, "f")[s(this, n, "f") + 3] << 24);
              return i(this, n, s(this, n, "f") + 4, "f"), e;
            }
            readU64() {
              const e = a(s(this, r, "f"), s(this, n, "f"));
              return i(this, n, s(this, n, "f") + 8, "f"), e;
            }
            readString() {
              const e = this.readU32(),
                t = s(this, r, "f").slice(s(this, n, "f"), s(this, n, "f") + e);
              return i(this, n, s(this, n, "f") + e, "f"), o.decode(t);
            }
            readByteArray(e) {
              const t = s(this, r, "f").slice(
                s(this, n, "f"),
                s(this, n, "f") + e,
              );
              return i(this, n, s(this, n, "f") + e, "f"), t;
            }
            readExtended(e) {
              const t = e.reader.read(s(this, r, "f"), s(this, n, "f"));
              return i(this, n, s(this, n, "f") + e.size, "f"), t;
            }
          }),
          (r = new WeakMap()),
          (n = new WeakMap());
      },
      9055: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.hasExtendReader = t.hasExtendWriter = t.isPrimitiveType = void 0),
          (t.isPrimitiveType = function (e) {
            return "string" == typeof e;
          }),
          (t.hasExtendWriter = function (e) {
            return void 0 !== e.writer;
          }),
          (t.hasExtendReader = function (e) {
            return void 0 !== e.reader;
          });
      },
      4398: function (e, t) {
        "use strict";
        var r,
          n,
          i,
          s,
          o,
          a,
          c,
          d,
          u,
          l,
          h,
          f,
          p,
          m =
            (this && this.__classPrivateFieldSet) ||
            function (e, t, r, n, i) {
              if ("m" === n)
                throw new TypeError("Private method is not writable");
              if ("a" === n && !i)
                throw new TypeError(
                  "Private accessor was defined without a setter",
                );
              if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError(
                  "Cannot write private member to an object whose class did not declare it",
                );
              return (
                "a" === n ? i.call(e, r) : i ? (i.value = r) : t.set(e, r), r
              );
            },
          y =
            (this && this.__classPrivateFieldGet) ||
            function (e, t, r, n) {
              if ("a" === r && !n)
                throw new TypeError(
                  "Private accessor was defined without a getter",
                );
              if ("function" == typeof t ? e !== t || !n : !t.has(e))
                throw new TypeError(
                  "Cannot read private member from an object whose class did not declare it",
                );
              return "m" === r
                ? n
                : "a" === r
                ? n.call(e)
                : n
                ? n.value
                : t.get(e);
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BinaryWriter =
            t.WriteExtended =
            t.WriteString =
            t.WriteUint8Array =
            t.WriteU64 =
            t.WriteU32 =
            t.WriteU16 =
            t.WriteU8 =
            t.WriteBool =
            t.writeU64 =
            t.writeU32 =
            t.writeU16 =
            t.writeU8 =
              void 0);
        const g = new TextEncoder();
        function v(e, t, r = 0) {
          return t.set([e], r), r + 1;
        }
        function b(e, t, r = 0) {
          return t.set([255 & e, (e >> 8) & 255], r), r + 2;
        }
        function w(e, t, r = 0) {
          return (
            t.set(
              [255 & e, (e >> 8) & 255, (e >> 16) & 255, (e >> 24) & 255],
              r,
            ),
            r + 4
          );
        }
        function E(e, t, r = 0) {
          return (
            t.set(
              [
                Number(BigInt(0xff) & e),
                Number((e >> BigInt(8))& BigInt(0xff)),
                Number((e >> BigInt(16)) & BigInt(0xff)),
                Number((e >> BigInt(24)) & BigInt(0xff)),
                Number((e >> BigInt(32)) & BigInt(0xff)),
                Number((e >> BigInt(40)) & BigInt(0xff)),
                Number((e >> BigInt(48)) & BigInt(0xff)),
                Number((e >> BigInt(56)) & BigInt(0xff)),
              ],
              r,
            ),
            r + 8
          );
        }
        (t.writeU8 = v), (t.writeU16 = b), (t.writeU32 = w), (t.writeU64 = E);
        class A {
          constructor(e) {
            r.set(this, void 0), m(this, r, e, "f");
          }
          get length() {
            return 1;
          }
          write(e, t = 0) {
            e.set([y(this, r, "f") ? 1 : 0], t);
          }
        }
        (t.WriteBool = A), (r = new WeakMap());
        class _ {
          constructor(e) {
            n.set(this, void 0), m(this, n, e, "f");
          }
          get length() {
            return 1;
          }
          write(e, t = 0) {
            v(y(this, n, "f"), e, t);
          }
        }
        (t.WriteU8 = _), (n = new WeakMap());
        class T {
          constructor(e) {
            i.set(this, void 0), m(this, i, e, "f");
          }
          get length() {
            return 2;
          }
          write(e, t = 0) {
            b(y(this, i, "f"), e, t);
          }
        }
        (t.WriteU16 = T), (i = new WeakMap());
        class R {
          constructor(e) {
            s.set(this, void 0), m(this, s, e, "f");
          }
          get length() {
            return 4;
          }
          write(e, t = 0) {
            w(y(this, s, "f"), e, t);
          }
        }
        (t.WriteU32 = R), (s = new WeakMap());
        class I {
          constructor(e) {
            o.set(this, void 0), m(this, o, e, "f");
          }
          get length() {
            return 8;
          }
          write(e, t = 0) {
            E(y(this, o, "f"), e, t);
          }
        }
        (t.WriteU64 = I), (o = new WeakMap());
        class S {
          constructor(e) {
            a.set(this, void 0), m(this, a, e, "f");
          }
          get length() {
            return y(this, a, "f").length;
          }
          write(e, t = 0) {
            e.set(y(this, a, "f"), t);
          }
        }
        (t.WriteUint8Array = S), (a = new WeakMap());
        class x {
          constructor(e) {
            c.set(this, void 0),
              d.set(this, void 0),
              m(this, c, g.encode(e), "f"),
              m(this, d, y(this, c, "f").length + 4, "f");
          }
          get length() {
            return y(this, d, "f");
          }
          write(e, t = 0) {
            (t = w(y(this, c, "f").length, e, t)), e.set(y(this, c, "f"), t);
          }
        }
        (t.WriteString = x), (c = new WeakMap()), (d = new WeakMap());
        class P {
          constructor(e, t, r) {
            u.set(this, void 0),
              l.set(this, void 0),
              h.set(this, void 0),
              m(this, u, e, "f"),
              m(this, h, r, "f"),
              m(this, l, t, "f");
          }
          get length() {
            return y(this, l, "f");
          }
          write(e, t = 0) {
            y(this, h, "f").write(y(this, u, "f"), e, t);
          }
        }
        (t.WriteExtended = P),
          (u = new WeakMap()),
          (l = new WeakMap()),
          (h = new WeakMap()),
          (t.BinaryWriter = class {
            constructor() {
              f.set(this, void 0),
                p.set(this, void 0),
                m(this, f, [], "f"),
                m(this, p, 0, "f");
            }
            writeBool(e) {
              const t = new A(e);
              m(this, p, y(this, p, "f") + t.length, "f"),
                y(this, f, "f").push(t);
            }
            writeU8(e) {
              const t = new _(e);
              m(this, p, y(this, p, "f") + t.length, "f"),
                y(this, f, "f").push(t);
            }
            writeU16(e) {
              const t = new T(e);
              m(this, p, y(this, p, "f") + t.length, "f"),
                y(this, f, "f").push(t);
            }
            writeU32(e) {
              const t = new R(e);
              m(this, p, y(this, p, "f") + t.length, "f"),
                y(this, f, "f").push(t);
            }
            writeU64(e) {
              const t = new I(e);
              m(this, p, y(this, p, "f") + t.length, "f"),
                y(this, f, "f").push(t);
            }
            writeU128() {
              throw new Error("Not implemented yet!");
            }
            writeI8() {
              throw new Error("Not implemented yet!");
            }
            writeI16() {
              throw new Error("Not implemented yet!");
            }
            writeI32() {
              throw new Error("Not implemented yet!");
            }
            writeI64() {
              throw new Error("Not implemented yet!");
            }
            writeI128() {
              throw new Error("Not implemented yet!");
            }
            writeString(e) {
              const t = new x(e);
              m(this, p, y(this, p, "f") + t.length, "f"),
                y(this, f, "f").push(t);
            }
            writeByteArray(e) {
              const t = new S(e);
              m(this, p, y(this, p, "f") + t.length, "f"),
                y(this, f, "f").push(t);
            }
            writeF32() {
              throw new Error("Not implemented yet!");
            }
            writeF64() {
              throw new Error("Not implemented yet!");
            }
            writeExtended(e, t) {
              const r = new P(e, t.size, t.writer);
              m(this, p, y(this, p, "f") + r.length, "f"),
                y(this, f, "f").push(r);
            }
            toArray() {
              let e = new Uint8Array(y(this, p, "f")),
                t = 0;
              for (const r of y(this, f, "f")) r.write(e, t), (t += r.length);
              return e;
            }
          }),
          (f = new WeakMap()),
          (p = new WeakMap());
      },
      214: (e, t, r) => {
        "use strict";
        function n(e) {
          return "string" == typeof e;
        }
        function i(e) {
          return void 0 !== e.writer;
        }
        function s(e) {
          return void 0 !== e.reader;
        }
        r.r(t),
          r.d(t, {
            array: () => Y,
            deserialize: () => se,
            enums: () => ne,
            extend: () => $,
            field: () => X,
            hasExtendReader: () => s,
            hasExtendWriter: () => i,
            isPrimitiveType: () => n,
            map: () => ee,
            option: () => te,
            serialize: () => ie,
            struct: () => re,
            variant: () => Q,
          });
        var o,
          a,
          c,
          d,
          u,
          l,
          h,
          f,
          p,
          m,
          y,
          g,
          v,
          b = function (e, t, r, n, i) {
            if ("m" === n)
              throw new TypeError("Private method is not writable");
            if ("a" === n && !i)
              throw new TypeError(
                "Private accessor was defined without a setter",
              );
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
              throw new TypeError(
                "Cannot write private member to an object whose class did not declare it",
              );
            return (
              "a" === n ? i.call(e, r) : i ? (i.value = r) : t.set(e, r), r
            );
          },
          w = function (e, t, r, n) {
            if ("a" === r && !n)
              throw new TypeError(
                "Private accessor was defined without a getter",
              );
            if ("function" == typeof t ? e !== t || !n : !t.has(e))
              throw new TypeError(
                "Cannot read private member from an object whose class did not declare it",
              );
            return "m" === r
              ? n
              : "a" === r
              ? n.call(e)
              : n
              ? n.value
              : t.get(e);
          };
        const E = new TextEncoder();
        function A(e, t, r = 0) {
          return (
            t.set(
              [255 & e, (e >> 8) & 255, (e >> 16) & 255, (e >> 24) & 255],
              r,
            ),
            r + 4
          );
        }
        class _ {
          constructor(e) {
            o.set(this, void 0), b(this, o, e, "f");
          }
          get length() {
            return 1;
          }
          write(e, t = 0) {
            e.set([w(this, o, "f") ? 1 : 0], t);
          }
        }
        o = new WeakMap();
        class T {
          constructor(e) {
            a.set(this, void 0), b(this, a, e, "f");
          }
          get length() {
            return 1;
          }
          write(e, t = 0) {
            !(function (e, t, r = 0) {
              t.set([e], r);
            })(w(this, a, "f"), e, t);
          }
        }
        a = new WeakMap();
        class R {
          constructor(e) {
            c.set(this, void 0), b(this, c, e, "f");
          }
          get length() {
            return 2;
          }
          write(e, t = 0) {
            !(function (e, t, r = 0) {
              t.set([255 & e, (e >> 8) & 255], r);
            })(w(this, c, "f"), e, t);
          }
        }
        c = new WeakMap();
        class I {
          constructor(e) {
            d.set(this, void 0), b(this, d, e, "f");
          }
          get length() {
            return 4;
          }
          write(e, t = 0) {
            A(w(this, d, "f"), e, t);
          }
        }
        d = new WeakMap();
        class S {
          constructor(e) {
            u.set(this, void 0), b(this, u, e, "f");
          }
          get length() {
            return 8;
          }
          write(e, t = 0) {
            !(function (e, t, r = 0) {
              t.set(
                [
                  Number(BigInt(0xff) & e),
                  Number((e >> BigInt(8))& BigInt(0xff)),
                  Number((e >> BigInt(16)) & BigInt(0xff)),
                  Number((e >> BigInt(24)) & BigInt(0xff)),
                  Number((e >> BigInt(32)) & BigInt(0xff)),
                  Number((e >> BigInt(40)) & BigInt(0xff)),
                  Number((e >> BigInt(48)) & BigInt(0xff)),
                  Number((e >> BigInt(56)) & BigInt(0xff)),
                ],
                r,
              );
            })(w(this, u, "f"), e, t);
          }
        }
        u = new WeakMap();
        class x {
          constructor(e) {
            l.set(this, void 0), b(this, l, e, "f");
          }
          get length() {
            return w(this, l, "f").length;
          }
          write(e, t = 0) {
            e.set(w(this, l, "f"), t);
          }
        }
        l = new WeakMap();
        class P {
          constructor(e) {
            h.set(this, void 0),
              f.set(this, void 0),
              b(this, h, E.encode(e), "f"),
              b(this, f, w(this, h, "f").length + 4, "f");
          }
          get length() {
            return w(this, f, "f");
          }
          write(e, t = 0) {
            (t = A(w(this, h, "f").length, e, t)), e.set(w(this, h, "f"), t);
          }
        }
        (h = new WeakMap()), (f = new WeakMap());
        class O {
          constructor(e, t, r) {
            p.set(this, void 0),
              m.set(this, void 0),
              y.set(this, void 0),
              b(this, p, e, "f"),
              b(this, y, r, "f"),
              b(this, m, t, "f");
          }
          get length() {
            return w(this, m, "f");
          }
          write(e, t = 0) {
            w(this, y, "f").write(w(this, p, "f"), e, t);
          }
        }
        (p = new WeakMap()), (m = new WeakMap()), (y = new WeakMap());
        class C {
          constructor() {
            g.set(this, void 0),
              v.set(this, void 0),
              b(this, g, [], "f"),
              b(this, v, 0, "f");
          }
          writeBool(e) {
            const t = new _(e);
            b(this, v, w(this, v, "f") + t.length, "f"),
              w(this, g, "f").push(t);
          }
          writeU8(e) {
            const t = new T(e);
            b(this, v, w(this, v, "f") + t.length, "f"),
              w(this, g, "f").push(t);
          }
          writeU16(e) {
            const t = new R(e);
            b(this, v, w(this, v, "f") + t.length, "f"),
              w(this, g, "f").push(t);
          }
          writeU32(e) {
            const t = new I(e);
            b(this, v, w(this, v, "f") + t.length, "f"),
              w(this, g, "f").push(t);
          }
          writeU64(e) {
            const t = new S(e);
            b(this, v, w(this, v, "f") + t.length, "f"),
              w(this, g, "f").push(t);
          }
          writeU128() {
            throw new Error("Not implemented yet!");
          }
          writeI8() {
            throw new Error("Not implemented yet!");
          }
          writeI16() {
            throw new Error("Not implemented yet!");
          }
          writeI32() {
            throw new Error("Not implemented yet!");
          }
          writeI64() {
            throw new Error("Not implemented yet!");
          }
          writeI128() {
            throw new Error("Not implemented yet!");
          }
          writeString(e) {
            const t = new P(e);
            b(this, v, w(this, v, "f") + t.length, "f"),
              w(this, g, "f").push(t);
          }
          writeByteArray(e) {
            const t = new x(e);
            b(this, v, w(this, v, "f") + t.length, "f"),
              w(this, g, "f").push(t);
          }
          writeF32() {
            throw new Error("Not implemented yet!");
          }
          writeF64() {
            throw new Error("Not implemented yet!");
          }
          writeExtended(e, t) {
            const r = new O(e, t.size, t.writer);
            b(this, v, w(this, v, "f") + r.length, "f"),
              w(this, g, "f").push(r);
          }
          toArray() {
            let e = new Uint8Array(w(this, v, "f")),
              t = 0;
            for (const r of w(this, g, "f")) r.write(e, t), (t += r.length);
            return e;
          }
        }
        (g = new WeakMap()), (v = new WeakMap());
        var k,
          M,
          N = function (e, t, r, n, i) {
            if ("m" === n)
              throw new TypeError("Private method is not writable");
            if ("a" === n && !i)
              throw new TypeError(
                "Private accessor was defined without a setter",
              );
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
              throw new TypeError(
                "Cannot write private member to an object whose class did not declare it",
              );
            return (
              "a" === n ? i.call(e, r) : i ? (i.value = r) : t.set(e, r), r
            );
          },
          B = function (e, t, r, n) {
            if ("a" === r && !n)
              throw new TypeError(
                "Private accessor was defined without a getter",
              );
            if ("function" == typeof t ? e !== t || !n : !t.has(e))
              throw new TypeError(
                "Cannot read private member from an object whose class did not declare it",
              );
            return "m" === r
              ? n
              : "a" === r
              ? n.call(e)
              : n
              ? n.value
              : t.get(e);
          };
        const D = new TextDecoder("utf8");
        class j {
          constructor(e) {
            k.set(this, void 0),
              M.set(this, void 0),
              N(this, k, e, "f"),
              N(this, M, 0, "f");
          }
          readBool() {
            const e = 1 == B(this, k, "f")[B(this, M, "f")];
            return N(this, M, B(this, M, "f") + 1, "f"), e;
          }
          readU8() {
            const e = B(this, k, "f")[B(this, M, "f")];
            return N(this, M, B(this, M, "f") + 1, "f"), e;
          }
          readU16() {
            const e =
              B(this, k, "f")[B(this, M, "f")] |
              (B(this, k, "f")[B(this, M, "f") + 1] << 8);
            return N(this, M, B(this, M, "f") + 2, "f"), e;
          }
          readU32() {
            const e =
              B(this, k, "f")[B(this, M, "f")] |
              (B(this, k, "f")[B(this, M, "f") + 1] << 8) |
              (B(this, k, "f")[B(this, M, "f") + 2] << 16) |
              (B(this, k, "f")[B(this, M, "f") + 3] << 24);
            return N(this, M, B(this, M, "f") + 4, "f"), e;
          }
          readU64() {
            const e = (function (e, t) {
              const r =
                BigInt(e[t]) |
                (BigInt(e[t + 1]) << BigInt(8))|
                (BigInt(e[t + 2]) << BigInt(16)) |
                (BigInt(e[t + 3]) << BigInt(24)) |
                (BigInt(e[t + 4]) << BigInt(32)) |
                (BigInt(e[t + 5]) << BigInt(40)) |
                (BigInt(e[t + 6]) << BigInt(48)) |
                (BigInt(e[t + 7]) << BigInt(56));
              return (t += 8), r;
            })(B(this, k, "f"), B(this, M, "f"));
            return N(this, M, B(this, M, "f") + 8, "f"), e;
          }
          readString() {
            const e = this.readU32(),
              t = B(this, k, "f").slice(B(this, M, "f"), B(this, M, "f") + e);
            return N(this, M, B(this, M, "f") + e, "f"), D.decode(t);
          }
          readByteArray(e) {
            const t = B(this, k, "f").slice(
              B(this, M, "f"),
              B(this, M, "f") + e,
            );
            return N(this, M, B(this, M, "f") + e, "f"), t;
          }
          readExtended(e) {
            const t = e.reader.read(B(this, k, "f"), B(this, M, "f"));
            return N(this, M, B(this, M, "f") + e.size, "f"), t;
          }
        }
        function L(e) {
          throw new Error(`Borsh: Invalid enum field type at: ${e.join(",")}`);
        }
        function U(e) {
          return e.__schema_fields || [];
        }
        function F(e) {
          return e.__schema_variant;
        }
        function H(e) {
          return e.__schema_enum_variants;
        }
        function G(e, t, r, s) {
          if (n(r)) {
            if ("u8" === r) s.writeU8(t);
            else if ("u16" === r) s.writeU16(t);
            else if ("u32" === r) s.writeU32(t);
            else if ("u64" === r) s.writeU64(t);
            else if ("usize" === r) s.writeU64(BigInt(t));
            else if ("bool" === r) s.writeBool(t);
            else if ("string" === r) s.writeString(t);
            else if ("u8-array" === r) {
              s.writeU32(t.length);
              for (let e = 0; e < t.length; e++) s.writeU8(t[e]);
            }
          } else if ("number" == typeof r)
            t.length !== r &&
              (function (e, t, r) {
                throw new Error(
                  `Borsh: Invalid byte array length at: ${e.join(
                    ",",
                  )}, expected: ${t}, actual: ${r}`,
                );
              })(e, r, t.length),
              s.writeByteArray(t);
          else {
            const { kind: n, value: o } = r;
            if ("option" === n)
              null == t
                ? s.writeU8(0)
                : (s.writeU8(1), G([...e, "<OptionValue>"], t, o, s));
            else if ("array" === n) {
              s.writeU32(t.length);
              for (let r = 0; r < t.length; r++)
                G([...e, `<Array[${r}]>`], t[r], o, s);
            } else if ("struct" === n) z(e, t, s);
            else if ("enum" === n) Z(e, t, s);
            else if ("map" === n) {
              s.writeU32(t.size);
              const [r, n] = o;
              for (const [i, o] of t)
                G([...e, "<Map[key]>"], i, r, s),
                  G([...e, "<Map[value]>"], o, n, s);
            } else
              "extend" === n &&
                (i(o)
                  ? s.writeExtended(t, o)
                  : (function (e) {
                      throw new Error(
                        `Borsh: Extended writer not found at: ${e.join(",")}`,
                      );
                    })(e));
          }
        }
        function V(e, t, r) {
          if (n(t)) {
            if ("u8" === t) return r.readU8();
            if ("u16" === t) return r.readU16();
            if ("u32" === t) return r.readU32();
            if ("u64" === t) return r.readU64();
            if ("bool" === t) return r.readBool();
            if ("usize" === t) return Number(r.readU64());
            if ("string" === t) return r.readString();
            if ("u8-array" === t) {
              let e = [];
              const t = r.readU32();
              for (let n = 0; n < t; n++) {
                let t = r.readU8();
                e.push(t);
              }
              return Uint8Array.from(e);
            }
          } else {
            if ("number" == typeof t) return r.readByteArray(t);
            {
              const { kind: n, value: i } = t;
              if ("array" === n) {
                let t = [];
                const n = r.readU32();
                for (let s = 0; s < n; s++) {
                  let n = V([...e, `<Array[${s}]>`], i, r);
                  t.push(n);
                }
                return t;
              }
              if ("option" === n)
                return r.readBool() ? V([...e, "<OptionValue>"], i, r) : void 0;
              if ("struct" === n) return J(e, i, r);
              if ("enum" === n) return K(e, i, r);
              if ("map" === n) {
                const t = r.readU32(),
                  [n, s] = i,
                  o = new Map();
                for (let i = 0; i < t; i++) {
                  let t = V([...e, "<Map[key]>"], n, r),
                    i = V([...e, "<Map[value]>"], s, r);
                  o.set(t, i);
                }
                return o;
              }
              if ("extend" === n) {
                if (s(i)) return r.readExtended(i);
                !(function (e) {
                  throw new Error(
                    `Borsh: Extended reader not found at: ${e.join(",")}`,
                  );
                })(e);
              }
            }
          }
        }
        function W(e, t, r, n) {
          const [i, s] = r,
            o = i.toString();
          G([...e, o], t[o], s, n);
        }
        function q(e, t, r, n) {
          const [i, s] = r,
            o = i.toString(),
            a = V([...e, o], s, n);
          return (t[o] = a), t;
        }
        function Z(e, t, r) {
          const n = F(Object.getPrototypeOf(t));
          void 0 !== n
            ? (r.writeU8(n), z([...e, `<Variant[${n}]>`], t, r))
            : L(e);
        }
        function z(e, t, r) {
          const n = U(Object.getPrototypeOf(t));
          for (const i of n) W(e, t, i, r);
        }
        function K(e, t, r) {
          const n = H(t.prototype);
          if (n instanceof Array) {
            const t = r.readU8(),
              i = n[t];
            return J([...e, `<Variant[${t}]>`], i, r);
          }
          L(e);
        }
        function J(e, t, r) {
          const n = U(t.prototype);
          let i = {};
          for (const t of n) i = q(e, i, t, r);
          return new t(i);
        }
        function X(e) {
          return function (t, r) {
            !(function (e, t, r) {
              let n = e.__schema_fields || [];
              n.push([t, r]), (e.__schema_fields = n);
            })(t.constructor.prototype, r, e);
          };
        }
        function Q(e) {
          return function (t) {
            !(function (e, t) {
              e.prototype.__schema_variant = t;
              const r = Object.getPrototypeOf(e.prototype).constructor;
              let n = r.prototype.__schema_enum_variants || [];
              n.push(e), (r.prototype.__schema_enum_variants = n);
            })(t, e);
          };
        }
        function $(e) {
          return { kind: "extend", value: e };
        }
        function Y(e) {
          return { kind: "array", value: e };
        }
        function ee(e, t) {
          return { kind: "map", value: [e, t] };
        }
        function te(e) {
          return { kind: "option", value: e };
        }
        function re(e) {
          return { kind: "struct", value: e };
        }
        function ne(e) {
          return { kind: "enum", value: e };
        }
        function ie(e) {
          const t = new C();
          return (
            (function (e) {
              return void 0 !== F(Object.getPrototypeOf(e));
            })(e)
              ? Z([], e, t)
              : z([], e, t),
            t.toArray()
          );
        }
        function se(e, t) {
          const r = new j(t);
          return void 0 !== H(e.prototype) ? K([], e, r) : J([], e, r);
        }
        (k = new WeakMap()), (M = new WeakMap());
      },
      302: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__decorate) ||
          function (e, t, r, n) {
            var i,
              s = arguments.length,
              o =
                s < 3
                  ? t
                  : null === n
                  ? (n = Object.getOwnPropertyDescriptor(t, r))
                  : n;
            if (
              "object" == typeof Reflect &&
              "function" == typeof Reflect.decorate
            )
              o = Reflect.decorate(e, t, r, n);
            else
              for (var a = e.length - 1; a >= 0; a--)
                (i = e[a]) &&
                  (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
            return s > 3 && o && Object.defineProperty(t, r, o), o;
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PlayerProfile =
            t.RegistrationWithGames =
            t.RegistrationAccount =
            t.GameRegistration =
            t.GameBundle =
            t.GameAccount =
            t.Vote =
            t.PlayerDeposit =
            t.ServerJoin =
            t.PlayerJoin =
            t.ServerAccount =
            t.TokenWithBalance =
            t.Token =
            t.VoteType =
              void 0);
        const i = r(1786);
        var s;
        ((s = t.VoteType || (t.VoteType = {}))[
          (s.ServerVoteTransactorDropOff = 0)
        ] = "ServerVoteTransactorDropOff"),
          (s[(s.ClientVoteTransactorDropOff = 1)] =
            "ClientVoteTransactorDropOff"),
          (t.Token = class {
            constructor(e) {
              Object.assign(this, e);
            }
          }),
          (t.TokenWithBalance = class {
            constructor(e, t) {
              Object.assign(this, e),
                (this.amount = t),
                (this.uiAmount = (
                  Number(t) / Math.pow(10, e.decimals)
                ).toLocaleString());
            }
          });
        class o {
          constructor(e) {
            Object.assign(this, e);
          }
        }
        n([(0, i.field)("string")], o.prototype, "addr", void 0),
          n([(0, i.field)("string")], o.prototype, "endpoint", void 0),
          (t.ServerAccount = o);
        class a {
          constructor(e) {
            Object.assign(this, e);
          }
        }
        n([(0, i.field)("string")], a.prototype, "addr", void 0),
          n([(0, i.field)("u16")], a.prototype, "position", void 0),
          n([(0, i.field)("u64")], a.prototype, "balance", void 0),
          n([(0, i.field)("u64")], a.prototype, "accessVersion", void 0),
          n([(0, i.field)("string")], a.prototype, "verifyKey", void 0),
          (t.PlayerJoin = a);
        class c {
          constructor(e) {
            Object.assign(this, e);
          }
        }
        n([(0, i.field)("string")], c.prototype, "addr", void 0),
          n([(0, i.field)("string")], c.prototype, "endpoint", void 0),
          n([(0, i.field)("u64")], c.prototype, "accessVersion", void 0),
          n([(0, i.field)("string")], c.prototype, "verifyKey", void 0),
          (t.ServerJoin = c);
        class d {
          constructor(e) {
            Object.assign(this, e);
          }
        }
        n([(0, i.field)("string")], d.prototype, "addr", void 0),
          n([(0, i.field)("u64")], d.prototype, "amount", void 0),
          n([(0, i.field)("u64")], d.prototype, "settleVersion", void 0),
          (t.PlayerDeposit = d);
        class u {
          constructor(e) {
            Object.assign(this, e);
          }
        }
        n([(0, i.field)("string")], u.prototype, "voter", void 0),
          n([(0, i.field)("string")], u.prototype, "votee", void 0),
          n([(0, i.field)("u8")], u.prototype, "voteType", void 0),
          (t.Vote = u);
        class l {
          constructor(e) {
            Object.assign(this, e);
          }
        }
        n([(0, i.field)("string")], l.prototype, "addr", void 0),
          n([(0, i.field)("string")], l.prototype, "title", void 0),
          n([(0, i.field)("string")], l.prototype, "bundleAddr", void 0),
          n([(0, i.field)("string")], l.prototype, "tokenAddr", void 0),
          n([(0, i.field)("string")], l.prototype, "ownerAddr", void 0),
          n([(0, i.field)("u64")], l.prototype, "settleVersion", void 0),
          n([(0, i.field)("u64")], l.prototype, "accessVersion", void 0),
          n(
            [(0, i.field)((0, i.array)((0, i.struct)(a)))],
            l.prototype,
            "players",
            void 0,
          ),
          n(
            [(0, i.field)((0, i.array)((0, i.struct)(d)))],
            l.prototype,
            "deposits",
            void 0,
          ),
          n(
            [(0, i.field)((0, i.array)((0, i.struct)(c)))],
            l.prototype,
            "servers",
            void 0,
          ),
          n(
            [(0, i.field)((0, i.option)("string"))],
            l.prototype,
            "transactorAddr",
            void 0,
          ),
          n(
            [(0, i.field)((0, i.array)((0, i.struct)(u)))],
            l.prototype,
            "votes",
            void 0,
          ),
          n(
            [(0, i.field)((0, i.option)("u64"))],
            l.prototype,
            "unlockTime",
            void 0,
          ),
          n([(0, i.field)("u16")], l.prototype, "maxPlayers", void 0),
          n([(0, i.field)("u64")], l.prototype, "minDeposit", void 0),
          n([(0, i.field)("u64")], l.prototype, "maxDeposit", void 0),
          n([(0, i.field)("u32")], l.prototype, "dataLen", void 0),
          n([(0, i.field)("u8-array")], l.prototype, "data", void 0),
          (t.GameAccount = l);
        class h {
          constructor(e) {
            Object.assign(this, e);
          }
        }
        n([(0, i.field)("string")], h.prototype, "uri", void 0),
          n([(0, i.field)("string")], h.prototype, "name", void 0),
          n([(0, i.field)("u8-array")], h.prototype, "data", void 0),
          (t.GameBundle = h);
        class f {
          constructor(e) {
            Object.assign(this, e);
          }
        }
        n([(0, i.field)("string")], f.prototype, "title", void 0),
          n([(0, i.field)("string")], f.prototype, "addr", void 0),
          n([(0, i.field)("u64")], f.prototype, "regTime", void 0),
          n([(0, i.field)("string")], f.prototype, "bundleAddr", void 0),
          (t.GameRegistration = f);
        class p {
          constructor(e) {
            Object.assign(this, e);
          }
        }
        n([(0, i.field)("string")], p.prototype, "addr", void 0),
          n([(0, i.field)("bool")], p.prototype, "isPrivate", void 0),
          n([(0, i.field)("u16")], p.prototype, "size", void 0),
          n(
            [(0, i.field)((0, i.option)("string"))],
            p.prototype,
            "owner",
            void 0,
          ),
          n(
            [(0, i.field)((0, i.array)((0, i.struct)(f)))],
            p.prototype,
            "games",
            void 0,
          ),
          (t.RegistrationAccount = p),
          (t.RegistrationWithGames = class {
            constructor(e) {
              Object.assign(this, e);
            }
          });
        class m {
          constructor(e) {
            Object.assign(this, e);
          }
        }
        n([(0, i.field)("string")], m.prototype, "addr", void 0),
          n([(0, i.field)("string")], m.prototype, "nick", void 0),
          n(
            [(0, i.field)((0, i.option)("string"))],
            m.prototype,
            "pfp",
            void 0,
          ),
          (t.PlayerProfile = m);
      },
      4784: function (e, t, r) {
        "use strict";
        var n,
          i,
          s,
          o,
          a,
          c,
          d,
          u,
          l,
          h,
          f,
          p,
          m,
          y =
            (this && this.__classPrivateFieldSet) ||
            function (e, t, r, n, i) {
              if ("m" === n)
                throw new TypeError("Private method is not writable");
              if ("a" === n && !i)
                throw new TypeError(
                  "Private accessor was defined without a setter",
                );
              if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError(
                  "Cannot write private member to an object whose class did not declare it",
                );
              return (
                "a" === n ? i.call(e, r) : i ? (i.value = r) : t.set(e, r), r
              );
            },
          g =
            (this && this.__classPrivateFieldGet) ||
            function (e, t, r, n) {
              if ("a" === r && !n)
                throw new TypeError(
                  "Private accessor was defined without a getter",
                );
              if ("function" == typeof t ? e !== t || !n : !t.has(e))
                throw new TypeError(
                  "Cannot read private member from an object whose class did not declare it",
                );
              return "m" === r
                ? n
                : "a" === r
                ? n.call(e)
                : n
                ? n.value
                : t.get(e);
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.AppClient = void 0);
        const v = r(5360),
          b = r(5412),
          w = r(6793),
          E = r(5305),
          A = r(9952),
          _ = r(4409),
          T = r(5001),
          R = r(2987),
          I = r(2944);
        class S {
          constructor(e, t, r, g, v, b, w, E, A, _, T, R) {
            n.set(this, void 0),
              i.set(this, void 0),
              s.set(this, void 0),
              o.set(this, void 0),
              a.set(this, void 0),
              c.set(this, void 0),
              d.set(this, void 0),
              u.set(this, void 0),
              l.set(this, void 0),
              h.set(this, void 0),
              f.set(this, void 0),
              p.set(this, void 0),
              m.set(this, void 0),
              y(this, n, e, "f"),
              y(this, i, t, "f"),
              y(this, s, r, "f"),
              y(this, o, g, "f"),
              y(this, a, v, "f"),
              y(this, c, b, "f"),
              y(this, d, w, "f"),
              y(this, u, E, "f"),
              y(this, l, A, "f"),
              y(this, h, _, "f"),
              y(this, f, T, "f"),
              y(this, p, new I.ProfileCache(v), "f"),
              y(this, m, R, "f");
          }
          static async initialize(e) {
            const {
              transport: t,
              wallet: r,
              gameAddr: n,
              onEvent: i,
              onMessage: s,
              storage: o,
            } = e;
            console.group("AppClient initialization");
            try {
              const e = r.walletAddr,
                a = await A.Encryptor.create(e, o),
                c = await t.getGameAccount(n);
              if (void 0 === c) throw _.SdkError.gameAccountNotFound(n);
              console.log("Game account:", c);
              const d = await t.getGameBundle(c.bundleAddr);
              if (void 0 === d)
                throw _.SdkError.gameBundleNotFound(c.bundleAddr);
              console.log("Game bundle:", d);
              const u = c.transactorAddr;
              if (void 0 === u) throw _.SdkError.gameNotServed(n);
              console.log("Transactor address:", u);
              const l = await t.getServerAccount(u);
              if (void 0 === l) throw _.SdkError.transactorAccountNotFound(u);
              const h = await E.Handler.initialize(d, a),
                f = v.Connection.initialize(e, l.endpoint, a),
                p = new T.Client(e, n, t, a, f),
                m = new b.GameContext(c),
                y = await t.getToken(c.tokenAddr);
              if (void 0 === y) throw _.SdkError.tokenNotFound(c.tokenAddr);
              const g = {
                title: c.title,
                minDeposit: c.minDeposit,
                maxDeposit: c.maxDeposit,
                maxPlayers: c.maxPlayers,
                token: y,
              };
              return new S(n, h, r, p, t, f, m, c, i, s, a, g);
            } finally {
              console.groupEnd();
            }
          }
          get playerAddr() {
            return g(this, s, "f").walletAddr;
          }
          get gameAddr() {
            return g(this, n, "f");
          }
          get gameContext() {
            return g(this, d, "f");
          }
          async getProfile(e) {
            return await g(this, a, "f").getPlayerProfile(e);
          }
          async invokeEventCallback(e) {
            const t = new w.GameContextSnapshot(g(this, d, "f"));
            await g(this, p, "f").injectProfiles(t);
            const r = g(this, d, "f").handlerState;
            g(this, l, "f").call(this, t, r, e);
          }
          async attachGame() {
            await g(this, o, "f").attachGame();
            const e = g(this, d, "f").settleVersion;
            let t = g(this, c, "f").subscribeEvents(
              g(this, n, "f"),
              new v.SubscribeEventParams({ settleVersion: e }),
            );
            for await (const e of t)
              if (e instanceof v.BroadcastFrameInit) {
                console.group("Initialize handler state");
                try {
                  const { state: t, accessVersion: r, settleVersion: n } = e;
                  console.log("Access version:", r),
                    console.log("Settle version:", n),
                    g(this, d, "f").applyCheckpoint(r, n);
                  const s = E.InitAccount.createFromGameAccount(
                    g(this, u, "f"),
                    r,
                    n,
                  );
                  console.log("Init account:", s),
                    await g(this, i, "f").initState(g(this, d, "f"), s),
                    void 0 !== t
                      ? (console.log("State:", t),
                        (g(this, d, "f").handlerState = t))
                      : console.log("No state snapshot, start from beginning."),
                    console.log("Context created:", g(this, d, "f")),
                    await this.invokeEventCallback(void 0);
                } catch (e) {
                  console.error(e);
                } finally {
                  console.groupEnd();
                }
              } else if (e instanceof v.BroadcastFrameMessage) {
                const { message: t } = e;
                console.log("Message:", t), g(this, h, "f").call(this, t);
              } else {
                if (!(e instanceof v.BroadcastFrameEvent)) break;
                {
                  const { event: t, timestamp: r } = e;
                  console.group("Handle event: " + t.kind());
                  try {
                    console.log("Event:", t),
                      console.log(
                        "Timestamp:",
                        new Date(Number(r)).toLocaleTimeString(),
                      ),
                      (g(this, d, "f").timestamp = r);
                    try {
                      let e = new b.GameContext(g(this, d, "f"));
                      await g(this, i, "f").handleEvent(e, t),
                        y(this, d, e, "f"),
                        console.log("Game context:", g(this, d, "f"));
                    } catch (e) {
                      console.error(e);
                    }
                    await this.invokeEventCallback(t);
                  } catch (e) {
                    console.error(e);
                  } finally {
                    console.groupEnd();
                  }
                }
              }
          }
          async join(e) {
            const t = await g(this, a, "f").getGameAccount(this.gameAddr);
            if (void 0 === t) throw new Error("Game account not found");
            const r = t.players.length;
            if (t.maxPlayers <= r) throw new Error("Game is full");
            let n = e.position;
            if (void 0 === n)
              for (let e = 0; e < t.maxPlayers; e++)
                if (void 0 === t.players.find((t) => t.position === e)) {
                  n = e;
                  break;
                }
            if (void 0 === n) throw new Error("Game is full");
            const i = await g(this, f, "f").exportPublicKey();
            g(this, a, "f").join(g(this, s, "f"), {
              gameAddr: this.gameAddr,
              amount: e.amount,
              accessVersion: t.accessVersion,
              position: n,
              verifyKey: i.ec,
            });
          }
          async submitEvent(e) {
            let t = e instanceof Uint8Array ? e : e.serialize();
            const r = new R.Custom({ sender: this.playerAddr, raw: t });
            await g(this, c, "f").submitEvent(
              g(this, n, "f"),
              new v.SubmitEventParams({ event: r }),
            );
          }
          async submitMessage(e) {
            await g(this, c, "f").submitMessage(
              g(this, n, "f"),
              new v.SubmitMessageParams({ content: e }),
            );
          }
          async getRevealed(e) {
            return await g(this, o, "f").decrypt(g(this, d, "f"), e);
          }
          async close() {}
          async exit() {
            await g(this, c, "f").exitGame(g(this, n, "f"), {});
          }
          get info() {
            return g(this, m, "f");
          }
        }
        (t.AppClient = S),
          (n = new WeakMap()),
          (i = new WeakMap()),
          (s = new WeakMap()),
          (o = new WeakMap()),
          (a = new WeakMap()),
          (c = new WeakMap()),
          (d = new WeakMap()),
          (u = new WeakMap()),
          (l = new WeakMap()),
          (h = new WeakMap()),
          (f = new WeakMap()),
          (p = new WeakMap()),
          (m = new WeakMap());
      },
      4890: function (e, t, r) {
        "use strict";
        var n,
          i =
            (this && this.__classPrivateFieldSet) ||
            function (e, t, r, n, i) {
              if ("m" === n)
                throw new TypeError("Private method is not writable");
              if ("a" === n && !i)
                throw new TypeError(
                  "Private accessor was defined without a setter",
                );
              if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError(
                  "Cannot write private member to an object whose class did not declare it",
                );
              return (
                "a" === n ? i.call(e, r) : i ? (i.value = r) : t.set(e, r), r
              );
            },
          s =
            (this && this.__classPrivateFieldGet) ||
            function (e, t, r, n) {
              if ("a" === r && !n)
                throw new TypeError(
                  "Private accessor was defined without a getter",
                );
              if ("function" == typeof t ? e !== t || !n : !t.has(e))
                throw new TypeError(
                  "Cannot read private member from an object whose class did not declare it",
                );
              return "m" === r
                ? n
                : "a" === r
                ? n.call(e)
                : n
                ? n.value
                : t.get(e);
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.AppHelper = void 0);
        const o = r(302);
        (t.AppHelper = class {
          constructor(e) {
            n.set(this, void 0), i(this, n, e, "f");
          }
          async getGame(e) {
            return await s(this, n, "f").getGameAccount(e);
          }
          async createGame(e, t) {
            if (0 == t.title.length || t.title.length > 16)
              throw new Error("Invalid title");
            if (t.minDeposit <= 0) throw new Error("Invalid minDeposit");
            if (t.maxDeposit < t.minDeposit)
              throw new Error("Invalid maxDeposit");
            if (t.maxPlayers < 1 || t.maxPlayers > 512)
              throw new Error("Invalid maxPlayers");
            let r = await s(this, n, "f").createGameAccount(e, t);
            return console.debug("Game account created at %s", r), r;
          }
          async registerGame(e, t, r) {
            await s(this, n, "f").registerGame(e, { gameAddr: t, regAddr: r });
          }
          async createProfile(e, t, r) {
            await s(this, n, "f").createPlayerProfile(e, { nick: t, pfp: r });
          }
          async getProfile(e) {
            return await s(this, n, "f").getPlayerProfile(e);
          }
          async listGames(e) {
            let t = [];
            for (const r of e) {
              const e = await s(this, n, "f").getRegistrationWithGames(r);
              if (void 0 !== e) for (const r of e.games) t.push(r);
            }
            return t;
          }
          async listTokens() {
            return await s(this, n, "f").listTokens();
          }
          async listNfts(e, t = void 0) {
            const r = await s(this, n, "f").listNfts(e);
            return void 0 === t ? r : r.filter((e) => e.collection === t);
          }
          async listTokensWithBalance(e) {
            const t = await this.listTokens(),
              r = t.map((e) => e.addr),
              i = await s(this, n, "f").fetchBalances(e, r);
            return t.map((e) => {
              let t = i.get(e.addr);
              return void 0 === t && (t = 0n), new o.TokenWithBalance(e, t);
            });
          }
        }),
          (n = new WeakMap());
      },
      5001: function (e, t, r) {
        "use strict";
        var n,
          i,
          s,
          o,
          a,
          c,
          d,
          u =
            (this && this.__classPrivateFieldSet) ||
            function (e, t, r, n, i) {
              if ("m" === n)
                throw new TypeError("Private method is not writable");
              if ("a" === n && !i)
                throw new TypeError(
                  "Private accessor was defined without a setter",
                );
              if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError(
                  "Cannot write private member to an object whose class did not declare it",
                );
              return (
                "a" === n ? i.call(e, r) : i ? (i.value = r) : t.set(e, r), r
              );
            },
          l =
            (this && this.__classPrivateFieldGet) ||
            function (e, t, r, n) {
              if ("a" === r && !n)
                throw new TypeError(
                  "Private accessor was defined without a getter",
                );
              if ("function" == typeof t ? e !== t || !n : !t.has(e))
                throw new TypeError(
                  "Cannot read private member from an object whose class did not declare it",
                );
              return "m" === r
                ? n
                : "a" === r
                ? n.call(e)
                : n
                ? n.value
                : t.get(e);
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Client = void 0);
        const h = r(5360),
          f = r(7498),
          p = r(2987);
        (t.Client = class {
          constructor(e, t, r, l, h) {
            n.set(this, void 0),
              i.set(this, void 0),
              s.set(this, void 0),
              o.set(this, void 0),
              a.set(this, void 0),
              c.set(this, void 0),
              d.set(this, void 0),
              u(this, a, e, "f"),
              u(this, o, t, "f"),
              u(this, i, r, "f"),
              u(this, n, l, "f"),
              u(this, s, h, "f"),
              u(this, c, new Array(), "f"),
              u(this, d, new f.SecretState(l), "f");
          }
          async attachGame() {
            const e = await l(this, n, "f").exportPublicKey(void 0);
            await l(this, s, "f").attachGame(
              l(this, o, "f"),
              new h.AttachGameParams({ signer: l(this, a, "f"), key: e }),
            );
          }
          async submitEvent(e) {
            await l(this, s, "f").submitEvent(
              l(this, o, "f"),
              new h.SubmitEventParams({ event: e }),
            );
          }
          async submitCustomEvent(e) {
            const t = (0, p.makeCustomEvent)(l(this, o, "f"), e);
            await l(this, s, "f").submitEvent(
              l(this, o, "f"),
              new h.SubmitEventParams({ event: t }),
            );
          }
          async handleDecision(e) {
            return [];
          }
          loadRandomStates(e) {
            for (let t of e.randomStates)
              l(this, d, "f").isRandomLoaded(t.id) ||
                l(this, d, "f").genRandomStates(t.id, t.size);
          }
          async handleUpdatedContext(e) {
            return this.loadRandomStates(e), await this.handleDecision(e);
          }
          flushSecretStates() {
            l(this, d, "f").clear(), l(this, c, "f").splice(0);
          }
          async decrypt(e, t) {
            let r = e.getRandomState(t),
              i = r.options,
              s = await l(this, n, "f").decryptWithSecrets(
                r.listRevealedCiphertexts(),
                r.listRevealedSecrets(),
                i,
              ),
              o = await l(this, n, "f").decryptWithSecrets(
                r.listAssignedCiphertexts(l(this, a, "f")),
                r.listSharedSecrets(l(this, a, "f")),
                i,
              );
            return new Map([...s, ...o]);
          }
        }),
          (n = new WeakMap()),
          (i = new WeakMap()),
          (s = new WeakMap()),
          (o = new WeakMap()),
          (a = new WeakMap()),
          (c = new WeakMap()),
          (d = new WeakMap());
      },
      5360: function (e, t, r) {
        "use strict";
        var n,
          i,
          s,
          o,
          a =
            (this && this.__decorate) ||
            function (e, t, r, n) {
              var i,
                s = arguments.length,
                o =
                  s < 3
                    ? t
                    : null === n
                    ? (n = Object.getOwnPropertyDescriptor(t, r))
                    : n;
              if (
                "object" == typeof Reflect &&
                "function" == typeof Reflect.decorate
              )
                o = Reflect.decorate(e, t, r, n);
              else
                for (var a = e.length - 1; a >= 0; a--)
                  (i = e[a]) &&
                    (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
              return s > 3 && o && Object.defineProperty(t, r, o), o;
            },
          c =
            (this && this.__classPrivateFieldSet) ||
            function (e, t, r, n, i) {
              if ("m" === n)
                throw new TypeError("Private method is not writable");
              if ("a" === n && !i)
                throw new TypeError(
                  "Private accessor was defined without a setter",
                );
              if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError(
                  "Cannot write private member to an object whose class did not declare it",
                );
              return (
                "a" === n ? i.call(e, r) : i ? (i.value = r) : t.set(e, r), r
              );
            },
          d =
            (this && this.__classPrivateFieldGet) ||
            function (e, t, r, n) {
              if ("a" === r && !n)
                throw new TypeError(
                  "Private accessor was defined without a getter",
                );
              if ("function" == typeof t ? e !== t || !n : !t.has(e))
                throw new TypeError(
                  "Cannot read private member from an object whose class did not declare it",
                );
              return "m" === r
                ? n
                : "a" === r
                ? n.call(e)
                : n
                ? n.value
                : t.get(e);
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Connection =
            t.BroadcastFrameMessage =
            t.BroadcastFrameInit =
            t.BroadcastFrameEvent =
            t.BroadcastFrame =
            t.Message =
            t.SubmitMessageParams =
            t.SubmitEventParams =
            t.SubscribeEventParams =
            t.ExitGameParams =
            t.AttachGameParams =
              void 0);
        const u = r(9952),
          l = r(2987),
          h = r(1786),
          f = r(8895);
        class p {
          constructor(e) {
            (this.key = e.key), (this.signer = e.signer);
          }
        }
        a([(0, h.field)("string")], p.prototype, "signer", void 0),
          a(
            [(0, h.field)((0, h.struct)(u.PublicKeyRaws))],
            p.prototype,
            "key",
            void 0,
          ),
          (t.AttachGameParams = p),
          (t.ExitGameParams = class {});
        class m {
          constructor(e) {
            this.settleVersion = e.settleVersion;
          }
        }
        a([(0, h.field)("u64")], m.prototype, "settleVersion", void 0),
          (t.SubscribeEventParams = m);
        class y {
          constructor(e) {
            this.event = e.event;
          }
        }
        a(
          [(0, h.field)((0, h.enums)(l.GameEvent))],
          y.prototype,
          "event",
          void 0,
        ),
          (t.SubmitEventParams = y);
        class g {
          constructor(e) {
            this.content = e.content;
          }
        }
        a([(0, h.field)("string")], g.prototype, "content", void 0),
          (t.SubmitMessageParams = g);
        class v {
          constructor(e) {
            Object.assign(this, e);
          }
        }
        a([(0, h.field)("string")], v.prototype, "sender", void 0),
          a([(0, h.field)("string")], v.prototype, "content", void 0),
          (t.Message = v);
        class b {}
        t.BroadcastFrame = b;
        let w = class extends b {
          constructor(e) {
            super(), Object.assign(this, e);
          }
        };
        a([(0, h.field)("string")], w.prototype, "gameAddr", void 0),
          a(
            [(0, h.field)((0, h.enums)(l.GameEvent))],
            w.prototype,
            "event",
            void 0,
          ),
          a([(0, h.field)("u64")], w.prototype, "timestamp", void 0),
          (w = a([(0, h.variant)(0)], w)),
          (t.BroadcastFrameEvent = w);
        let E = class extends b {
          constructor(e) {
            super(), Object.assign(this, e);
          }
        };
        a([(0, h.field)("string")], E.prototype, "gameAddr", void 0),
          a([(0, h.field)("u64")], E.prototype, "accessVersion", void 0),
          a([(0, h.field)("u64")], E.prototype, "settleVersion", void 0),
          a(
            [(0, h.field)((0, h.option)("u8-array"))],
            E.prototype,
            "state",
            void 0,
          ),
          (E = a([(0, h.variant)(1)], E)),
          (t.BroadcastFrameInit = E);
        let A = class extends b {
          constructor(e) {
            super(), Object.assign(this, e);
          }
        };
        a([(0, h.field)("string")], A.prototype, "gameAddr", void 0),
          a([(0, h.field)((0, h.struct)(v))], A.prototype, "message", void 0),
          (A = a([(0, h.variant)(2)], A)),
          (t.BroadcastFrameMessage = A);
        class _ {
          constructor(e, t, r) {
            n.set(this, void 0),
              i.set(this, void 0),
              s.set(this, void 0),
              o.set(this, void 0),
              c(this, n, e, "f"),
              c(this, i, t, "f"),
              c(this, s, r, "f");
            const a = new WebSocket(t);
            c(this, o, a, "f");
          }
          async attachGame(e, t) {
            const r = this.makeReqNoSig(e, "attach_game", t);
            await this.requestXhr(r);
          }
          async submitEvent(e, t) {
            const r = await this.makeReq(e, "submit_event", t);
            await this.requestXhr(r);
          }
          async submitMessage(e, t) {
            const r = await this.makeReq(e, "submit_message", t);
            await this.requestXhr(r);
          }
          async exitGame(e, t) {
            const r = await this.makeReq(e, "exit_game", t);
            await this.requestXhr(r);
          }
          async *subscribeEvents(e, t) {
            const r = this.makeReqNoSig(e, "subscribe_event", t);
            await this.requestWs(r);
            let n,
              i = [],
              s = new Promise((e) => (n = e));
            for (
              d(this, o, "f").onmessage = (e) => {
                if (void 0 !== n) {
                  let t = this.parseEventMessage(e.data);
                  if (void 0 !== t) {
                    let e = n;
                    (n = void 0), e(t);
                  }
                } else {
                  let t = this.parseEventMessage(e.data);
                  void 0 !== t && i.push(t);
                }
              },
                d(this, o, "f").onclose = () => {
                  if (void 0 !== n) {
                    let e = n;
                    (n = void 0), e(void 0);
                  }
                };
              ;

            )
              i.length > 0
                ? yield i.shift()
                : (yield s, (s = new Promise((e) => (n = e))));
          }
          parseEventMessage(e) {
            let t = JSON.parse(e);
            if ("s_event" === t.method) {
              let e = t.params.result,
                r = (0, f.base64ToUint8Array)(e);
              return (0, h.deserialize)(b, r);
            }
          }
          static initialize(e, t, r) {
            return new _(e, t, r);
          }
          async makeReq(e, t, r) {
            const i = (0, h.serialize)(r),
              o = await d(this, s, "f").sign(i, d(this, n, "f")),
              a = (0, h.serialize)(o);
            return JSON.stringify({
              jsonrpc: "2.0",
              method: t,
              id: crypto.randomUUID(),
              params: [
                e,
                (0, f.arrayBufferToBase64)(i),
                (0, f.arrayBufferToBase64)(a),
              ],
            });
          }
          makeReqNoSig(e, t, r) {
            const n = (0, h.serialize)(r);
            return JSON.stringify({
              jsonrpc: "2.0",
              method: t,
              id: crypto.randomUUID(),
              params: [e, (0, f.arrayBufferToBase64)(n)],
            });
          }
          async requestWs(e) {
            try {
              await this.waitSocketReady(), d(this, o, "f").send(e);
            } catch (e) {
              throw (
                (console.error(
                  "Failed to connect to current transactor: " + d(this, i, "f"),
                ),
                e)
              );
            }
          }
          async requestXhr(e) {
            try {
              const t = await fetch(d(this, i, "f").replace(/^ws/, "http"), {
                method: "POST",
                body: e,
                headers: { "Content-Type": "application/json" },
              });
              if (t.ok) return t.json();
              throw Error("Transactor request failed:" + t.json());
            } catch (e) {
              throw (
                (console.error(
                  "Failed to connect to current transactor: " + d(this, i, "f"),
                ),
                e)
              );
            }
          }
          waitSocketReady() {
            return new Promise((e, t) => {
              let r = 0;
              const n = setInterval(() => {
                r > 10
                  ? (clearInterval(n), t())
                  : d(this, o, "f").readyState === d(this, o, "f").OPEN &&
                    (clearInterval(n), e(void 0)),
                  r++;
              }, 200);
            });
          }
        }
        (t.Connection = _),
          (n = new WeakMap()),
          (i = new WeakMap()),
          (s = new WeakMap()),
          (o = new WeakMap());
      },
      3928: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.DecisionState = t.Answer = void 0);
        class r {
          constructor(e, t) {
            (this.digest = t), (this.ciphertext = e);
          }
        }
        (t.Answer = r),
          (t.DecisionState = class {
            constructor(e, t) {
              (this.id = e),
                (this.owner = t),
                (this.status = "asked"),
                (this.secret = void 0),
                (this.answer = void 0),
                (this.value = void 0);
            }
            setAnswer(e, t, n) {
              if (this.owner !== e) throw new Error("Invalid decision owner");
              if ("asked" !== this.status)
                throw new Error("Invalid decision status");
              (this.answer = new r(t, n)), (this.status = "answered");
            }
            release() {
              if ("answered" !== this.status)
                throw new Error("Invalid decision status");
              this.status = "releasing";
            }
            addReleased(e) {
              if ("released" !== this.status)
                throw new Error("Invalid decision status");
              this.value = e;
            }
            addSecret(e, t) {
              if ("releasing" !== this.status)
                throw new Error("Invalid decision status");
              if (this.owner !== e) throw new Error("Invalid decision owner");
              (this.secret = t), (this.status = "released");
            }
          });
      },
      7779: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__decorate) ||
          function (e, t, r, n) {
            var i,
              s = arguments.length,
              o =
                s < 3
                  ? t
                  : null === n
                  ? (n = Object.getOwnPropertyDescriptor(t, r))
                  : n;
            if (
              "object" == typeof Reflect &&
              "function" == typeof Reflect.decorate
            )
              o = Reflect.decorate(e, t, r, n);
            else
              for (var a = e.length - 1; a >= 0; a--)
                (i = e[a]) &&
                  (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
            return s > 3 && o && Object.defineProperty(t, r, o), o;
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Effect =
            t.ActionTimeout =
            t.Release =
            t.Reveal =
            t.Assign =
            t.Ask =
            t.Settle =
            t.SettleEject =
            t.SettleSub =
            t.SettleAdd =
            t.SettleOp =
              void 0);
        const i = r(7403),
          s = r(4409),
          o = r(1786);
        class a {}
        t.SettleOp = a;
        let c = class extends a {
          constructor(e) {
            super(), Object.assign(this, e);
          }
        };
        n([(0, o.field)("u64")], c.prototype, "amount", void 0),
          (c = n([(0, o.variant)(0)], c)),
          (t.SettleAdd = c);
        let d = class extends a {
          constructor(e) {
            super(), Object.assign(this, e);
          }
        };
        n([(0, o.field)("u64")], d.prototype, "amount", void 0),
          (d = n([(0, o.variant)(1)], d)),
          (t.SettleSub = d);
        let u = class extends a {
          constructor(e) {
            super();
          }
        };
        (u = n([(0, o.variant)(2)], u)), (t.SettleEject = u);
        class l {
          constructor(e) {
            (this.addr = e.addr), (this.op = e.op);
          }
          sortKey() {
            return this.op instanceof c ? 0 : this.op instanceof d ? 1 : 2;
          }
          compare(e) {
            return this.sortKey() - e.sortKey();
          }
        }
        n([(0, o.field)("string")], l.prototype, "addr", void 0),
          n([(0, o.field)((0, o.enums)(a))], l.prototype, "op", void 0),
          (t.Settle = l);
        class h {
          constructor(e) {
            Object.assign(this, e);
          }
        }
        n([(0, o.field)("string")], h.prototype, "playerAddr", void 0),
          (t.Ask = h);
        class f {
          constructor(e) {
            Object.assign(this, e);
          }
        }
        n([(0, o.field)("usize")], f.prototype, "randomId", void 0),
          n([(0, o.field)("string")], f.prototype, "playerAddr", void 0),
          n(
            [(0, o.field)((0, o.array)("usize"))],
            f.prototype,
            "indexes",
            void 0,
          ),
          (t.Assign = f);
        class p {
          constructor(e) {
            Object.assign(this, e);
          }
        }
        n([(0, o.field)("usize")], p.prototype, "randomId", void 0),
          n(
            [(0, o.field)((0, o.array)("usize"))],
            p.prototype,
            "indexes",
            void 0,
          ),
          (t.Reveal = p);
        class m {
          constructor(e) {
            Object.assign(this, e);
          }
        }
        n([(0, o.field)("usize")], m.prototype, "decisionId", void 0),
          (t.Release = m);
        class y {
          constructor(e) {
            Object.assign(this, e);
          }
        }
        n([(0, o.field)("string")], y.prototype, "playerAddr", void 0),
          n([(0, o.field)("u64")], y.prototype, "timeout", void 0),
          (t.ActionTimeout = y);
        class g {
          constructor(e) {
            Object.assign(this, e);
          }
          static fromContext(e) {
            const t = new Map();
            for (const r of e.randomStates) t.set(r.id, r.revealed);
            const r = new Map();
            for (const t of e.decisionStates) r.set(t.id, t.value);
            const n = e.timestamp,
              i = e.randomStates.length + 1,
              s = e.decisionStates.length + 1,
              o = e.players.length,
              a = e.servers.length,
              c = e.handlerState,
              d = e.allowExit;
            return new g({
              actionTimeout: void 0,
              waitTimeout: void 0,
              startGame: !1,
              stopGame: !1,
              cancelDispatch: !1,
              timestamp: n,
              currRandomId: i,
              currDecisionId: s,
              playersCount: o,
              serversCount: a,
              asks: [],
              assigns: [],
              releases: [],
              reveals: [],
              initRandomStates: [],
              revealed: t,
              answered: r,
              settles: [],
              handlerState: c,
              error: void 0,
              allowExit: d,
            });
          }
        }
        n(
          [(0, o.field)((0, o.option)((0, o.struct)(y)))],
          g.prototype,
          "actionTimeout",
          void 0,
        ),
          n(
            [(0, o.field)((0, o.option)("u64"))],
            g.prototype,
            "waitTimeout",
            void 0,
          ),
          n([(0, o.field)("bool")], g.prototype, "startGame", void 0),
          n([(0, o.field)("bool")], g.prototype, "stopGame", void 0),
          n([(0, o.field)("bool")], g.prototype, "cancelDispatch", void 0),
          n([(0, o.field)("u64")], g.prototype, "timestamp", void 0),
          n([(0, o.field)("usize")], g.prototype, "currRandomId", void 0),
          n([(0, o.field)("usize")], g.prototype, "currDecisionId", void 0),
          n([(0, o.field)("u16")], g.prototype, "playersCount", void 0),
          n([(0, o.field)("u16")], g.prototype, "serversCount", void 0),
          n(
            [(0, o.field)((0, o.array)((0, o.struct)(h)))],
            g.prototype,
            "asks",
            void 0,
          ),
          n(
            [(0, o.field)((0, o.array)((0, o.struct)(f)))],
            g.prototype,
            "assigns",
            void 0,
          ),
          n(
            [(0, o.field)((0, o.array)((0, o.struct)(p)))],
            g.prototype,
            "reveals",
            void 0,
          ),
          n(
            [(0, o.field)((0, o.array)((0, o.struct)(m)))],
            g.prototype,
            "releases",
            void 0,
          ),
          n(
            [(0, o.field)((0, o.array)((0, o.enums)(i.RandomSpec)))],
            g.prototype,
            "initRandomStates",
            void 0,
          ),
          n(
            [(0, o.field)((0, o.map)("usize", (0, o.map)("usize", "string")))],
            g.prototype,
            "revealed",
            void 0,
          ),
          n(
            [(0, o.field)((0, o.map)("usize", "string"))],
            g.prototype,
            "answered",
            void 0,
          ),
          n(
            [(0, o.field)((0, o.array)((0, o.struct)(l)))],
            g.prototype,
            "settles",
            void 0,
          ),
          n(
            [(0, o.field)((0, o.option)("u8-array"))],
            g.prototype,
            "handlerState",
            void 0,
          ),
          n(
            [(0, o.field)((0, o.option)((0, o.enums)(s.HandleError)))],
            g.prototype,
            "error",
            void 0,
          ),
          n([(0, o.field)("bool")], g.prototype, "allowExit", void 0),
          (t.Effect = g);
      },
      9952: function (e, t, r) {
        "use strict";
        var n,
          i,
          s =
            (this && this.__decorate) ||
            function (e, t, r, n) {
              var i,
                s = arguments.length,
                o =
                  s < 3
                    ? t
                    : null === n
                    ? (n = Object.getOwnPropertyDescriptor(t, r))
                    : n;
              if (
                "object" == typeof Reflect &&
                "function" == typeof Reflect.decorate
              )
                o = Reflect.decorate(e, t, r, n);
              else
                for (var a = e.length - 1; a >= 0; a--)
                  (i = e[a]) &&
                    (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
              return s > 3 && o && Object.defineProperty(t, r, o), o;
            },
          o =
            (this && this.__classPrivateFieldSet) ||
            function (e, t, r, n, i) {
              if ("m" === n)
                throw new TypeError("Private method is not writable");
              if ("a" === n && !i)
                throw new TypeError(
                  "Private accessor was defined without a setter",
                );
              if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError(
                  "Cannot write private member to an object whose class did not declare it",
                );
              return (
                "a" === n ? i.call(e, r) : i ? (i.value = r) : t.set(e, r), r
              );
            },
          a =
            (this && this.__classPrivateFieldGet) ||
            function (e, t, r, n) {
              if ("a" === r && !n)
                throw new TypeError(
                  "Private accessor was defined without a getter",
                );
              if ("function" == typeof t ? e !== t || !n : !t.has(e))
                throw new TypeError(
                  "Cannot read private member from an object whose class did not declare it",
                );
              return "m" === r
                ? n
                : "a" === r
                ? n.call(e)
                : n
                ? n.value
                : t.get(e);
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Encryptor =
            t.Signature =
            t.generateAes =
            t.generateChacha20 =
            t.generateRsaKeypair =
            t.generateEcKeypair =
            t.importEcPublicKey =
            t.importRsaPublicKey =
            t.importEc =
            t.importRsa =
            t.importAes =
            t.decryptAes =
            t.encryptAes =
            t.decryptChacha20 =
            t.encryptChacha20 =
            t.verifyEc =
            t.signEc =
            t.decryptRsa =
            t.encryptRsa =
            t.exportEc =
            t.exportRsa =
            t.exportAes =
            t.exportEcPublicKey =
            t.exportRsaPublicKey =
            t.PublicKeyRaws =
            t.aesDigestIv =
            t.chacha20Nonce =
            t.aesContentIv =
              void 0);
        const c = r(4409),
          d = r(1786),
          u = r(8895),
          l = r(1625);
        let h = crypto.subtle;
        (t.aesContentIv = Uint8Array.of(
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
        )),
          (t.chacha20Nonce = Uint8Array.of(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)),
          (t.aesDigestIv = Uint8Array.of(
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
          ));
        const f = new TextDecoder("utf8"),
          p = Uint8Array.of(1, 0, 1);
        class m {
          constructor(e) {
            (this.rsa = e.rsa), (this.ec = e.ec);
          }
        }
        s([(0, d.field)("string")], m.prototype, "rsa", void 0),
          s([(0, d.field)("string")], m.prototype, "ec", void 0),
          (t.PublicKeyRaws = m);
        const y = { name: "RSA-OAEP", hash: "SHA-256" },
          g = { name: "ECDSA", namedCurve: "P-256" };
        async function v(e) {
          return (0, u.arrayBufferToBase64)(await h.exportKey("spki", e));
        }
        async function b(e) {
          return (0, u.arrayBufferToBase64)(await h.exportKey("spki", e));
        }
        async function w(e) {
          let t = await h.exportKey("pkcs8", e.privateKey);
          return [(0, u.arrayBufferToBase64)(t), await v(e.publicKey)];
        }
        async function E(e) {
          let t = await h.exportKey("pkcs8", e.privateKey);
          return [(0, u.arrayBufferToBase64)(t), await b(e.publicKey)];
        }
        async function A(e, t) {
          return new Uint8Array(await h.decrypt("RSA-OAEP", e, t));
        }
        async function _(e, t) {
          return new Uint8Array(
            await h.sign({ name: "ECDSA", hash: { name: "SHA-256" } }, e, t),
          );
        }
        async function T(e, t, r) {
          return await h.verify(
            { name: "ECDSA", hash: { name: "SHA-256" } },
            e,
            t,
            r,
          );
        }
        function R(e, t, r) {
          return new l.Chacha20(e, r).encrypt(t);
        }
        function I(e, t, r) {
          return new l.Chacha20(e, r).decrypt(t);
        }
        async function S(e, t, r) {
          return new Uint8Array(
            await h.decrypt({ name: "AES-CTR", counter: r, length: 64 }, e, t),
          );
        }
        async function x(e) {
          return await h.importKey("raw", e, { name: "AES-CTR" }, !0, [
            "encrypt",
            "decrypt",
          ]);
        }
        async function P([e, t]) {
          const r = (0, u.base64ToArrayBuffer)(e),
            n = await h.importKey("pkcs8", r, y, !0, ["decrypt"]);
          return { publicKey: await C(t), privateKey: n };
        }
        async function O([e, t]) {
          const r = (0, u.base64ToArrayBuffer)(e),
            n = await h.importKey("pkcs8", r, g, !0, ["sign"]);
          return { publicKey: await k(t), privateKey: n };
        }
        async function C(e) {
          const t = (0, u.base64ToArrayBuffer)(e);
          return await h.importKey("spki", t, y, !0, ["encrypt"]);
        }
        async function k(e) {
          const t = (0, u.base64ToArrayBuffer)(e);
          return await h.importKey("spki", t, g, !0, ["verify"]);
        }
        async function M() {
          return await h.generateKey(g, !0, ["verify", "sign"]);
        }
        async function N() {
          return await h.generateKey(
            {
              name: "RSA-OAEP",
              modulusLength: 1024,
              publicExponent: p,
              hash: "SHA-256",
            },
            !0,
            ["encrypt", "decrypt"],
          );
        }
        (t.exportRsaPublicKey = v),
          (t.exportEcPublicKey = b),
          (t.exportAes = async function (e) {
            return new Uint8Array(await h.exportKey("raw", e));
          }),
          (t.exportRsa = w),
          (t.exportEc = E),
          (t.encryptRsa = async function (e, t) {
            return new Uint8Array(await h.encrypt("RSA-OAEP", e, t));
          }),
          (t.decryptRsa = A),
          (t.signEc = _),
          (t.verifyEc = T),
          (t.encryptChacha20 = R),
          (t.decryptChacha20 = I),
          (t.encryptAes = async function (e, t, r) {
            return new Uint8Array(
              await h.encrypt(
                { name: "AES-CTR", counter: r, length: 64 },
                e,
                t,
              ),
            );
          }),
          (t.decryptAes = S),
          (t.importAes = x),
          (t.importRsa = P),
          (t.importEc = O),
          (t.importRsaPublicKey = C),
          (t.importEcPublicKey = k),
          (t.generateEcKeypair = M),
          (t.generateRsaKeypair = N),
          (t.generateChacha20 = function () {
            const e = new Uint8Array(32);
            return crypto.getRandomValues(e), e;
          }),
          (t.generateAes = async function () {
            return await h.generateKey({ name: "AES-CTR", length: 128 }, !0, [
              "encrypt",
              "decrypt",
            ]);
          });
        class B {
          constructor(e) {
            (this.signer = e.signer),
              (this.timestamp = e.timestamp),
              (this.signature = e.signature);
          }
        }
        s([(0, d.field)("string")], B.prototype, "signer", void 0),
          s([(0, d.field)("u64")], B.prototype, "timestamp", void 0),
          s([(0, d.field)("u8-array")], B.prototype, "signature", void 0),
          (t.Signature = B);
        class D {
          constructor(e, t) {
            (this.rsa = e), (this.ec = t);
          }
          static async initialize(e) {
            // let t, r;
            // return (
            //   (t = void 0 === e?.rsa ? await N() : e.rsa),
            //   (r = void 0 === e?.ec ? await M() : e.ec),
            //   new D(t, r)
            // );
            let t, r;
            return (
              (t = typeof e === 'undefined' || typeof e.rsa === 'undefined' ? await N() : e.rsa),
              (r = typeof e === 'undefined' || typeof e.ec === 'undefined' ? await M() : e.ec),
              new D(t, r)
            );
          }
        }
        class j {
          constructor(e, t) {
            (this.rsa = e), (this.ec = t);
          }
        }
        class L {
          constructor(e) {
            n.set(this, void 0),
              i.set(this, void 0),
              o(this, n, e, "f"),
              o(this, i, new Map(), "f");
          }
          async decryptRsa(e) {
            return await A(a(this, n, "f").rsa.privateKey, e);
          }
          async decryptAes(e, r) {
            const n = await x(e);
            return await S(n, r, t.aesContentIv);
          }
          async decryptAesMulti(e, t) {
            for (const r of e) t = await this.decryptAes(r, t);
            return t;
          }
          encryptChacha20(e, r) {
            return R(e, r, t.chacha20Nonce);
          }
          decryptChacha20(e, r) {
            return I(e, r, t.chacha20Nonce);
          }
          decryptChacha20Multi(e, t) {
            for (const r of e) t = this.decryptChacha20(r, t);
            return t;
          }
          async signRaw(e) {
            return await _(a(this, n, "f").ec.privateKey, e);
          }
          makeSignMessage(e, t) {
            const r = new DataView(new ArrayBuffer(8));
            r.setBigUint64(0, t, !0);
            const n = new Uint8Array(e.length + 8);
            return n.set(e), n.set(new Uint8Array(r.buffer), e.length), n;
          }
          async sign(e, t) {
            const r = BigInt(new Date().getTime()),
              n = this.makeSignMessage(e, r),
              i = await this.signRaw(n);
            return new B({ timestamp: r, signer: t, signature: i });
          }
          async verify(e, t) {
            // const r = t.timestamp,
            //   n = a(this, i, "f").get(t.signer)?.ec;
            const r = t.timestamp;
            let n;

            if (typeof a(this, i, "f").get(t.signer) !== 'undefined') {
              n = a(this, i, "f").get(t.signer).ec;
            }
            if (void 0 === n)
              throw new Error("Can't verify message, ECDSA key is missing");
            const s = this.makeSignMessage(e, r);
            return await T(n, t.signature, s);
          }
          static async create(e, t) {
            if (void 0 !== t) {
              const r = await L.importFromStorage(e, t);
              if (void 0 !== r) return r;
            }
            const r = await N(),
              n = await M(),
              i = new L(new D(r, n));
            return void 0 !== t && (await i.exportToStorage(e, t)), i;
          }
          static makeStorageKey(e) {
            return `ENCRYPTOR_KEY_1.0_${e}`;
          }
          async exportToStorage(e, t) {
            const r = await this.exportEcKeys(),
              n = await this.exportRsaKeys();
            t.setItem(L.makeStorageKey(e), JSON.stringify({ rsa: n, ec: r }));
          }
          static async importFromStorage(e, t) {
            const r = L.makeStorageKey(e),
              n = t.getItem(r);
            if (null === n) return;
            const { rsa: i, ec: s } = JSON.parse(n),
              o = await O(s),
              a = await P(i);
            return new L(new D(a, o));
          }
          async exportRsaKeys() {
            return await w(a(this, n, "f").rsa);
          }
          async exportEcKeys() {
            return await E(a(this, n, "f").ec);
          }
          async addPublicKey(e, { rsa: t, ec: r }) {
            const n = await C(t),
              s = await k(r);
            a(this, i, "f").set(e, new j(n, s));
          }
          async exportPublicKey(e) {
            let t, r;
            if (void 0 === e)
              (t = a(this, n, "f").rsa.publicKey),
                (r = a(this, n, "f").ec.publicKey);
            else {
              const n = a(this, i, "f").get(e);
              if (void 0 === n) throw c.SdkError.publicKeyNotFound(e);
              (t = n.rsa), (r = n.ec);
            }
            return new m({ rsa: await v(t), ec: await b(r) });
          }
          async decryptWithSecrets(e, t, r) {
            const n = new Map();
            for (const [i, s] of e) {
              const e = t.get(i);
              if (void 0 === e) throw new Error("Missing secrets");
              {
                const t = this.decryptChacha20Multi(e, s),
                  o = f.decode(t);
                if (void 0 === r.find((e) => e === o))
                  throw new Error(
                    "Invalid result: [" + o + "], options:" + r.join(","),
                  );
                n.set(i, o);
              }
            }
            return n;
          }
        }
        (t.Encryptor = L), (n = new WeakMap()), (i = new WeakMap());
      },
      4409: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__decorate) ||
          function (e, t, r, n) {
            var i,
              s = arguments.length,
              o =
                s < 3
                  ? t
                  : null === n
                  ? (n = Object.getOwnPropertyDescriptor(t, r))
                  : n;
            if (
              "object" == typeof Reflect &&
              "function" == typeof Reflect.decorate
            )
              o = Reflect.decorate(e, t, r, n);
            else
              for (var a = e.length - 1; a >= 0; a--)
                (i = e[a]) &&
                  (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
            return s > 3 && o && Object.defineProperty(t, r, o), o;
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SdkError =
            t.InternalError =
            t.NoEnoughServers =
            t.SerializationError =
            t.MalformedCustomEvent =
            t.MalformedGameAccountData =
            t.InvalidAmount =
            t.CantLeave =
            t.PlayerNotInGame =
            t.NoEnoughPlayers =
            t.CustomError =
            t.HandleError =
              void 0);
        const i = r(1786);
        class s extends Error {}
        t.HandleError = s;
        let o = class extends s {
          constructor(e) {
            super(), (this.message = e.message);
          }
        };
        (o = n([(0, i.variant)(0)], o)), (t.CustomError = o);
        let a = class extends s {
          constructor(e) {
            super(), (this.message = "No enough players");
          }
        };
        (a = n([(0, i.variant)(1)], a)), (t.NoEnoughPlayers = a);
        let c = class extends s {
          constructor(e) {
            super(), (this.message = "Player not in game");
          }
        };
        (c = n([(0, i.variant)(2)], c)), (t.PlayerNotInGame = c);
        let d = class extends s {
          constructor(e) {
            super(), (this.message = "Can't leave game");
          }
        };
        (d = n([(0, i.variant)(3)], d)), (t.CantLeave = d);
        let u = class extends s {
          constructor(e) {
            super(), (this.message = "Invalid amount");
          }
        };
        (u = n([(0, i.variant)(4)], u)), (t.InvalidAmount = u);
        let l = class extends s {
          constructor(e) {
            super(), (this.message = "Malformed game account data");
          }
        };
        (l = n([(0, i.variant)(5)], l)), (t.MalformedGameAccountData = l);
        let h = class extends s {
          constructor(e) {
            super(), (this.message = "Malformed custom event");
          }
        };
        (h = n([(0, i.variant)(6)], h)), (t.MalformedCustomEvent = h);
        let f = class extends s {
          constructor(e) {
            super(), (this.message = "Serilization error");
          }
        };
        (f = n([(0, i.variant)(7)], f)), (t.SerializationError = f);
        let p = class extends s {
          constructor(e) {
            super(), (this.message = "No enough servers");
          }
        };
        (p = n([(0, i.variant)(8)], p)), (t.NoEnoughServers = p);
        let m = class extends s {
          constructor(e) {
            super(), (this.message = `Internal error: ${e.message}`);
          }
        };
        n([(0, i.field)("string")], m.prototype, "message", void 0),
          (m = n([(0, i.variant)(9)], m)),
          (t.InternalError = m);
        class y extends Error {
          constructor(e) {
            super(e);
          }
          static publicKeyNotFound(e) {
            return new y(`RSA public key for ${e} is missing`);
          }
          static gameAccountNotFound(e) {
            return new y(`Game account of ${e} not found`);
          }
          static gameBundleNotFound(e) {
            return new y(`Game bundle of ${e} not found`);
          }
          static transactorAccountNotFound(e) {
            return new y(`Transactor's account of ${e} not found`);
          }
          static gameNotServed(e) {
            return new y(`Game at ${e} is not served`);
          }
          static tokenNotFound(e) {
            return new y(`Token ${e} not found`);
          }
        }
        t.SdkError = y;
      },
      2987: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__decorate) ||
          function (e, t, r, n) {
            var i,
              s = arguments.length,
              o =
                s < 3
                  ? t
                  : null === n
                  ? (n = Object.getOwnPropertyDescriptor(t, r))
                  : n;
            if (
              "object" == typeof Reflect &&
              "function" == typeof Reflect.decorate
            )
              o = Reflect.decorate(e, t, r, n);
            else
              for (var a = e.length - 1; a >= 0; a--)
                (i = e[a]) &&
                  (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
            return s > 3 && o && Object.defineProperty(t, r, o), o;
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Shutdown =
            t.SecretsReady =
            t.AnswerDecision =
            t.ActionTimeout =
            t.DrawTimeout =
            t.DrawRandomItems =
            t.WaitingTimeout =
            t.GameStart =
            t.Leave =
            t.ServerLeave =
            t.Sync =
            t.RandomnessReady =
            t.Lock =
            t.CiphertextAndDigest =
            t.Mask =
            t.OperationTimeout =
            t.ShareSecrets =
            t.Ready =
            t.makeCustomEvent =
            t.Custom =
            t.GameEvent =
            t.Answer =
            t.Random =
            t.SecretShare =
              void 0);
        const i = r(1786),
          s = r(302);
        class o {}
        t.SecretShare = o;
        let a = class extends o {
          constructor(e) {
            super(), Object.assign(this, e);
          }
        };
        n([(0, i.field)("string")], a.prototype, "fromAddr", void 0),
          n(
            [(0, i.field)((0, i.option)("string"))],
            a.prototype,
            "toAddr",
            void 0,
          ),
          n([(0, i.field)("usize")], a.prototype, "randomId", void 0),
          n([(0, i.field)("usize")], a.prototype, "index", void 0),
          n([(0, i.field)("u8-array")], a.prototype, "secret", void 0),
          (a = n([(0, i.variant)(0)], a)),
          (t.Random = a);
        let c = class extends o {
          constructor(e) {
            super(), Object.assign(this, e);
          }
        };
        n([(0, i.field)("string")], c.prototype, "fromAddr", void 0),
          n([(0, i.field)("usize")], c.prototype, "decisionId", void 0),
          n([(0, i.field)("u8-array")], c.prototype, "secret", void 0),
          (c = n([(0, i.variant)(1)], c)),
          (t.Answer = c);
        class d {
          kind() {
            return "Invalid";
          }
        }
        t.GameEvent = d;
        let u = class extends d {
          constructor(e) {
            super(), Object.assign(this, e);
          }
          kind() {
            return "Custom";
          }
        };
        n([(0, i.field)("string")], u.prototype, "sender", void 0),
          n([(0, i.field)("u8-array")], u.prototype, "raw", void 0),
          (u = n([(0, i.variant)(0)], u)),
          (t.Custom = u),
          (t.makeCustomEvent = function (e, t) {
            return new u({ sender: e, raw: t.serialize() });
          });
        let l = class extends d {
          constructor(e = {}) {
            super();
          }
          kind() {
            return "Ready";
          }
        };
        (l = n([(0, i.variant)(1)], l)), (t.Ready = l);
        let h = class extends d {
          constructor(e) {
            super(), Object.assign(this, e);
          }
          kind() {
            return "ShareSecrets";
          }
        };
        n([(0, i.field)("string")], h.prototype, "sender", void 0),
          n(
            [(0, i.field)((0, i.array)((0, i.enums)(o)))],
            h.prototype,
            "shares",
            void 0,
          ),
          (h = n([(0, i.variant)(2)], h)),
          (t.ShareSecrets = h);
        let f = class extends d {
          constructor(e) {
            super(), Object.assign(this, e);
          }
          kind() {
            return "OperationTimeout";
          }
        };
        n([(0, i.field)((0, i.array)("string"))], f.prototype, "addrs", void 0),
          (f = n([(0, i.variant)(3)], f)),
          (t.OperationTimeout = f);
        let p = class extends d {
          constructor(e) {
            super(), Object.assign(this, e);
          }
          kind() {
            return "Mask";
          }
        };
        n([(0, i.field)("string")], p.prototype, "sender", void 0),
          n([(0, i.field)("usize")], p.prototype, "randomId", void 0),
          n(
            [(0, i.field)((0, i.array)("u8-array"))],
            p.prototype,
            "ciphertexts",
            void 0,
          ),
          (p = n([(0, i.variant)(4)], p)),
          (t.Mask = p);
        class m {
          constructor(e) {
            Object.assign(this, e);
          }
        }
        n([(0, i.field)("u8-array")], m.prototype, "ciphertext", void 0),
          n([(0, i.field)("u8-array")], m.prototype, "digest", void 0),
          (t.CiphertextAndDigest = m);
        let y = class extends d {
          constructor(e) {
            super(), Object.assign(this, e);
          }
          kind() {
            return "Lock";
          }
        };
        n([(0, i.field)("string")], y.prototype, "sender", void 0),
          n([(0, i.field)("usize")], y.prototype, "randomId", void 0),
          n(
            [(0, i.field)((0, i.array)((0, i.struct)(m)))],
            y.prototype,
            "ciphertextsAndDigests",
            void 0,
          ),
          (y = n([(0, i.variant)(5)], y)),
          (t.Lock = y);
        let g = class extends d {
          constructor(e) {
            super(), Object.assign(this, e);
          }
          kind() {
            return "RandomnessReady";
          }
        };
        n([(0, i.field)("usize")], g.prototype, "randomId", void 0),
          (g = n([(0, i.variant)(6)], g)),
          (t.RandomnessReady = g);
        let v = class extends d {
          constructor(e) {
            super(), Object.assign(this, e);
          }
          kind() {
            return "Sync";
          }
        };
        n(
          [(0, i.field)((0, i.array)((0, i.struct)(s.PlayerJoin)))],
          v.prototype,
          "newPlayers",
          void 0,
        ),
          n(
            [(0, i.field)((0, i.array)((0, i.struct)(s.ServerJoin)))],
            v.prototype,
            "newServers",
            void 0,
          ),
          n([(0, i.field)("string")], v.prototype, "transactorAddr", void 0),
          n([(0, i.field)("u64")], v.prototype, "accessVersion", void 0),
          (v = n([(0, i.variant)(7)], v)),
          (t.Sync = v);
        let b = class extends d {
          constructor(e) {
            super(), Object.assign(this, e);
          }
          kind() {
            return "ServerLeave";
          }
        };
        n([(0, i.field)("string")], b.prototype, "serverAddr", void 0),
          n([(0, i.field)("string")], b.prototype, "transactorAddr", void 0),
          (b = n([(0, i.variant)(8)], b)),
          (t.ServerLeave = b);
        let w = class extends d {
          constructor(e) {
            super(), Object.assign(this, e);
          }
          kind() {
            return "Leave";
          }
        };
        n([(0, i.field)("string")], w.prototype, "playerAddr", void 0),
          (w = n([(0, i.variant)(9)], w)),
          (t.Leave = w);
        let E = class extends d {
          constructor(e) {
            super(), Object.assign(this, e);
          }
          kind() {
            return "GameStart";
          }
        };
        n([(0, i.field)("u64")], E.prototype, "accessVersion", void 0),
          (E = n([(0, i.variant)(10)], E)),
          (t.GameStart = E);
        let A = class extends d {
          constructor(e = {}) {
            super();
          }
          kind() {
            return "WaitingTimeout";
          }
        };
        (A = n([(0, i.variant)(11)], A)), (t.WaitingTimeout = A);
        let _ = class extends d {
          constructor(e) {
            super(), Object.assign(this, e);
          }
          kind() {
            return "DrawRandomItems";
          }
        };
        n([(0, i.field)("string")], _.prototype, "sender", void 0),
          n([(0, i.field)("usize")], _.prototype, "randomId", void 0),
          n(
            [(0, i.field)((0, i.array)("usize"))],
            _.prototype,
            "indexes",
            void 0,
          ),
          (_ = n([(0, i.variant)(12)], _)),
          (t.DrawRandomItems = _);
        let T = class extends d {
          constructor(e) {
            super();
          }
          kind() {
            return "DrawTimeout";
          }
        };
        (T = n([(0, i.variant)(13)], T)), (t.DrawTimeout = T);
        let R = class extends d {
          constructor(e) {
            super(), Object.assign(this, e);
          }
          kind() {
            return "ActionTimeout";
          }
        };
        n([(0, i.field)("string")], R.prototype, "playerAddr", void 0),
          (R = n([(0, i.variant)(14)], R)),
          (t.ActionTimeout = R);
        let I = class extends d {
          constructor(e) {
            super(), Object.assign(this, e);
          }
          kind() {
            return "AnswerDecision";
          }
        };
        n([(0, i.field)("string")], I.prototype, "sender", void 0),
          n([(0, i.field)("usize")], I.prototype, "decisionId", void 0),
          n([(0, i.field)("u8-array")], I.prototype, "ciphertext", void 0),
          n([(0, i.field)("u8-array")], I.prototype, "digest", void 0),
          (I = n([(0, i.variant)(15)], I)),
          (t.AnswerDecision = I);
        let S = class extends d {
          constructor(e = {}) {
            super();
          }
          kind() {
            return "SecretsReady";
          }
        };
        (S = n([(0, i.variant)(16)], S)), (t.SecretsReady = S);
        let x = class extends d {
          constructor(e = {}) {
            super();
          }
          kind() {
            return "Shutdown";
          }
        };
        (x = n([(0, i.variant)(17)], x)), (t.Shutdown = x);
      },
      6793: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.GameContextSnapshot =
            t.ServerShapshot =
            t.PlayerShapshot =
              void 0);
        class r {
          constructor(e) {
            (this.addr = e.addr),
              (this.balance = e.balance),
              (this.position = e.position),
              (this.status = e.status);
          }
        }
        t.PlayerShapshot = r;
        class n {
          constructor(e) {
            (this.addr = e.addr),
              (this.endpoint = e.endpoint),
              (this.status = e.status);
          }
        }
        (t.ServerShapshot = n),
          (t.GameContextSnapshot = class {
            constructor(e) {
              (this.gameAddr = e.gameAddr),
                (this.accessVersion = e.accessVersion),
                (this.settleVersion = e.settleVersion),
                (this.status = e.status),
                (this.allowExit = e.allowExit),
                (this.players = e.players.map((e) => new r(e))),
                (this.servers = e.servers.map((e) => new n(e)));
            }
          });
      },
      5412: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.GameContext = void 0);
        const n = r(7403),
          i = r(3928),
          s = r(2987),
          o = r(7779),
          a = 15000n;
        class c {
          constructor(e) {
            if (e instanceof c) {
              const t = e;
              (this.gameAddr = t.gameAddr),
                (this.accessVersion = t.accessVersion),
                (this.settleVersion = t.settleVersion),
                (this.transactorAddr = t.transactorAddr),
                (this.status = t.status),
                (this.players = t.players.map((e) => Object.assign({}, e))),
                (this.servers = t.servers.map((e) => Object.assign({}, e))),
                (this.dispatch = t.dispatch),
                (this.handlerState = new Uint8Array(t.handlerState)),
                (this.timestamp = t.timestamp),
                (this.allowExit = t.allowExit),
                (this.randomStates = t.randomStates),
                (this.decisionStates = t.decisionStates),
                (this.settles = t.settles);
            } else {
              const t = e,
                r = t.transactorAddr;
              if (void 0 === r) throw new Error("Game not served");
              const n = t.players.map((e) => ({
                  addr: e.addr,
                  balance: e.balance,
                  position: e.position,
                  status: { kind: "pending", accessVersion: e.accessVersion },
                })),
                i = t.servers.map((e) => ({
                  addr: e.addr,
                  endpoint: e.endpoint,
                  status: { kind: "pending", accessVersion: e.accessVersion },
                }));
              (this.gameAddr = t.addr),
                (this.transactorAddr = r),
                (this.accessVersion = t.accessVersion),
                (this.settleVersion = t.settleVersion),
                (this.status = "uninit"),
                (this.dispatch = void 0),
                (this.players = n),
                (this.servers = i),
                (this.timestamp = 0n),
                (this.allowExit = !1),
                (this.randomStates = []),
                (this.decisionStates = []),
                (this.settles = void 0),
                (this.handlerState = Uint8Array.of());
            }
          }
          getServerByAddress(e) {
            return this.servers.find((t) => t.addr === e);
          }
          getPlayerByAddress(e) {
            return this.players.find((t) => t.addr === e);
          }
          dispatchEvent(e, t) {
            this.dispatch = { event: e, timeout: this.timestamp + t };
          }
          dispatchEventInstantly(e) {
            this.dispatchEvent(e, 0n);
          }
          waitTimeout(e) {
            this.dispatch = {
              event: new s.WaitingTimeout({}),
              timeout: this.timestamp + e,
            };
          }
          actionTimeout(e, t) {
            this.dispatch = {
              event: new s.ActionTimeout({ playerAddr: e }),
              timeout: this.timestamp + t,
            };
          }
          genStartGameEvent() {
            return new s.GameStart({ accessVersion: this.accessVersion });
          }
          startGame() {
            (this.randomStates = []),
              (this.decisionStates = []),
              (this.dispatch = {
                event: this.genStartGameEvent(),
                timeout: 0n,
              });
          }
          shutdownGame() {
            this.dispatch = { event: new s.Shutdown({}), timeout: 0n };
          }
          getRandomState(e) {
            if (e <= 0) throw new Error("Invalid random id: " + e);
            const t = this.randomStates[e - 1];
            if (void 0 === t) throw new Error("Invalid random id: " + e);
            return t;
          }
          getDecisionState(e) {
            if (e <= 0) throw new Error("Invalid decision id: " + e);
            const t = this.decisionStates[e - 1];
            if (void 0 === t) throw new Error("Invalid decision id: " + e);
            return t;
          }
          assign(e, t, r) {
            this.getRandomState(e).assign(t, r);
          }
          reveal(e, t) {
            this.getRandomState(e).reveal(t);
          }
          isRandomReady(e) {
            const t = this.getRandomState(e).status.kind;
            return "ready" === t || "waiting-secrets" === t;
          }
          isAllRandomReady() {
            for (const e of this.randomStates) {
              const t = e.status.kind;
              if ("ready" !== t && "waiting-secrets" !== t) return !1;
            }
            return !0;
          }
          isSecretsReady() {
            return this.randomStates.every((e) => "ready" === e.status.kind);
          }
          setPlayerStatus(e, t) {
            let r = this.players.find((t) => t.addr === e);
            if (void 0 === r) throw new Error("Invalid player address");
            r.status = t;
          }
          addPlayer(e) {
            const t = this.players.find(
              (t) => t.addr === e.addr || t.position === e.position,
            );
            if (void 0 !== t)
              throw t.position === e.position
                ? new Error("Position occupied")
                : new Error("Player already joined");
            this.players.push({
              addr: e.addr,
              balance: e.balance,
              status: { kind: "ready" },
              position: e.position,
            });
          }
          addServer(e) {
            if (void 0 !== this.players.find((t) => t.addr === e.addr))
              throw new Error("Server already joined");
            this.servers.push({
              addr: e.addr,
              status: { kind: "ready" },
              endpoint: e.endpoint,
            });
          }
          setAccessVersion(e) {
            this.accessVersion = e;
          }
          setAllowExit(e) {
            this.allowExit = e;
          }
          removePlayer(e) {
            if (!this.allowExit) throw new Error("Can't leave");
            {
              const t = this.players.length;
              if (
                ((this.players = this.players.filter((t) => t.addr !== e)),
                this.players.length === t)
              )
                throw new Error("Player not in game");
            }
          }
          initRandomState(e) {
            const t = this.randomStates.length + 1,
              r = this.servers
                .filter((e) => "ready" === e.status.kind)
                .map((e) => e.addr),
              i = new n.RandomState(t, e, r);
            return this.randomStates.push(i), t;
          }
          addSharedSecrets(e, t) {
            for (const e of t)
              if (e instanceof s.Random) {
                const {
                  randomId: t,
                  toAddr: r,
                  fromAddr: n,
                  index: i,
                  secret: s,
                } = e;
                this.getRandomState(t).addSecret(n, r, i, s);
              } else if (e instanceof s.Answer) {
                const { fromAddr: t, decisionId: r, secret: n } = e;
                this.getDecisionState(r).addSecret(t, n);
              }
          }
          randomizeAndMask(e, t, r) {
            this.getRandomState(t).mask(e, r),
              this.dispatchRandomizationTimeout(t);
          }
          lock(e, t, r) {
            this.getRandomState(t).lock(e, r),
              this.dispatchRandomizationTimeout(t);
          }
          dispatchRandomizationTimeout(e) {
            const t = void 0 === this.dispatch;
            let r = this.getRandomState(e);
            const n = r.status.kind;
            if ("ready" === n)
              this.dispatchEventInstantly(
                new s.RandomnessReady({ randomId: e }),
              );
            else if ("locking" === n || "masking" === n) {
              const e = r.status.addr;
              t &&
                this.dispatchEvent(new s.OperationTimeout({ addrs: [e] }), a);
            } else if ("waiting-secrets" === n && t) {
              const e = r.listOperatingAddrs();
              this.dispatchEvent(new s.OperationTimeout({ addrs: e }), a);
            }
          }
          settle(e) {
            this.settles = e;
          }
          bumpSettleVersion() {
            this.settleVersion += 1n;
          }
          applyAndTakeSettles() {
            if (void 0 === this.settles) return;
            let e = this.settles;
            (this.settles = void 0), (e = e.sort((e, t) => e.compare(t)));
            for (const t of e)
              if (t.op instanceof o.SettleAdd) {
                let e = this.getPlayerByAddress(t.addr);
                if (void 0 === e)
                  throw new Error("Invalid settle player address");
                e.balance += t.op.amount;
              } else if (t.op instanceof o.SettleSub) {
                let e = this.getPlayerByAddress(t.addr);
                if (void 0 === e)
                  throw new Error("Invalid settle player address");
                e.balance -= t.op.amount;
              } else
                t.op instanceof o.SettleEject &&
                  (this.players = this.players.filter(
                    (e) => e.addr !== t.addr,
                  ));
            return this.bumpSettleVersion(), e;
          }
          addSettle(e) {
            void 0 === this.settles
              ? (this.settles = [e])
              : this.settles.push(e);
          }
          addRevealedRandom(e, t) {
            this.getRandomState(e).addRevealed(t);
          }
          addRevealedAnswer(e, t) {
            this.getDecisionState(e).addReleased(t);
          }
          ask(e) {
            const t = this.decisionStates.length + 1,
              r = new i.DecisionState(t, e);
            return this.decisionStates.push(r), t;
          }
          answerDecision(e, t, r, n) {
            this.getDecisionState(e).setAnswer(t, r, n);
          }
          getRevealed(e) {
            return this.getRandomState(e).revealed;
          }
          applyEffect(e) {
            e.startGame
              ? this.startGame()
              : e.stopGame
              ? this.shutdownGame()
              : void 0 !== e.actionTimeout
              ? this.actionTimeout(
                  e.actionTimeout.playerAddr,
                  e.actionTimeout.timeout,
                )
              : void 0 !== e.waitTimeout
              ? this.waitTimeout(e.waitTimeout)
              : e.cancelDispatch && (this.dispatch = void 0),
              this.setAllowExit(e.allowExit);
            for (const t of e.assigns)
              this.assign(t.randomId, t.playerAddr, t.indexes);
            for (const t of e.reveals) this.reveal(t.randomId, t.indexes);
            for (const t of e.asks) this.ask(t.playerAddr);
            for (const t of e.initRandomStates) this.initRandomState(t);
            e.settles.length > 0 && this.settle(e.settles),
              void 0 !== e.handlerState && (this.handlerState = e.handlerState);
          }
          setNodeReady(e) {
            for (const t of this.servers)
              "pending" === t.status.kind &&
                t.status.accessVersion < e &&
                (t.status = { kind: "ready" });
            for (const t of this.players)
              "pending" === t.status.kind &&
                t.status.accessVersion < e &&
                (t.status = { kind: "ready" });
          }
          applyCheckpoint(e, t) {
            if (this.settleVersion !== t) throw new Error("Invalid checkpoint");
            (this.players = this.players.filter(
              (t) => "pending" !== t.status.kind || t.status.accessVersion <= e,
            )),
              (this.servers = this.servers.filter(
                (t) =>
                  "pending" !== t.status.kind || t.status.accessVersion <= e,
              )),
              (this.accessVersion = e);
          }
        }
        t.GameContext = c;
      },
      5305: function (e, t, r) {
        "use strict";
        var n,
          i,
          s =
            (this && this.__decorate) ||
            function (e, t, r, n) {
              var i,
                s = arguments.length,
                o =
                  s < 3
                    ? t
                    : null === n
                    ? (n = Object.getOwnPropertyDescriptor(t, r))
                    : n;
              if (
                "object" == typeof Reflect &&
                "function" == typeof Reflect.decorate
              )
                o = Reflect.decorate(e, t, r, n);
              else
                for (var a = e.length - 1; a >= 0; a--)
                  (i = e[a]) &&
                    (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
              return s > 3 && o && Object.defineProperty(t, r, o), o;
            },
          o =
            (this && this.__classPrivateFieldSet) ||
            function (e, t, r, n, i) {
              if ("m" === n)
                throw new TypeError("Private method is not writable");
              if ("a" === n && !i)
                throw new TypeError(
                  "Private accessor was defined without a setter",
                );
              if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError(
                  "Cannot write private member to an object whose class did not declare it",
                );
              return (
                "a" === n ? i.call(e, r) : i ? (i.value = r) : t.set(e, r), r
              );
            },
          a =
            (this && this.__classPrivateFieldGet) ||
            function (e, t, r, n) {
              if ("a" === r && !n)
                throw new TypeError(
                  "Private accessor was defined without a getter",
                );
              if ("function" == typeof t ? e !== t || !n : !t.has(e))
                throw new TypeError(
                  "Cannot read private member from an object whose class did not declare it",
                );
              return "m" === r
                ? n
                : "a" === r
                ? n.call(e)
                : n
                ? n.value
                : t.get(e);
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Handler = t.InitAccount = void 0);
        const c = r(1786),
          d = r(302),
          u = r(2987),
          l = r(7779);
        class h {
          constructor(e) {
            (this.addr = e.addr),
              (this.accessVersion = e.accessVersion),
              (this.settleVersion = e.settleVersion),
              (this.data = e.data),
              (this.players = e.players),
              (this.servers = e.servers);
          }
          static createFromGameAccount(e, t, r) {
            let { addr: n, players: i, servers: s, data: o } = e;
            return (
              (i = i.filter((e) => e.accessVersion <= t)),
              (s = s.filter((e) => e.accessVersion <= t)),
              new h({
                addr: n,
                data: o,
                players: i,
                servers: s,
                accessVersion: t,
                settleVersion: r,
              })
            );
          }
          serialize() {
            return (0, c.serialize)(h);
          }
          static deserialize(e) {
            return (0, c.deserialize)(h, e);
          }
        }
        s([(0, c.field)("string")], h.prototype, "addr", void 0),
          s(
            [(0, c.field)((0, c.array)((0, c.struct)(d.PlayerJoin)))],
            h.prototype,
            "players",
            void 0,
          ),
          s(
            [(0, c.field)((0, c.array)((0, c.struct)(d.ServerJoin)))],
            h.prototype,
            "servers",
            void 0,
          ),
          s([(0, c.field)("u8-array")], h.prototype, "data", void 0),
          s([(0, c.field)("u64")], h.prototype, "accessVersion", void 0),
          s([(0, c.field)("u64")], h.prototype, "settleVersion", void 0),
          (t.InitAccount = h);
        class f {
          constructor(e, t) {
            n.set(this, void 0),
              i.set(this, void 0),
              o(this, n, t, "f"),
              o(this, i, e, "f");
          }
          static async initialize(e, t) {
            const r = {
              imports: {
                memory: new WebAssembly.Memory({
                  shared: !0,
                  maximum: 100,
                  initial: 100,
                }),
              },
            };
            let n;
            return (
              0 === e.data.length
                ? (console.debug("Initiate handler by streaming:", e.uri),
                  (n = await WebAssembly.instantiateStreaming(fetch(e.uri), r)))
                : (n = await WebAssembly.instantiate(e.data, r)),
              new f(n.instance, t)
            );
          }
          async handleEvent(e, t) {
            await this.generalPreHandleEvent(e, t, a(this, n, "f")),
              await this.customHandleEvent(e, t),
              await this.generalPostHandleEvent(e, t),
              e.applyAndTakeSettles();
          }
          async initState(e, t) {
            await this.generalPreInitState(e, t),
              await this.customInitState(e, t),
              await this.generalPostInitState(e, t);
          }
          async generalPreInitState(e, t) {}
          async generalPostInitState(e, t) {}
          async generalPreHandleEvent(e, t, r) {
            if (t instanceof u.ShareSecrets) {
              const { sender: r, shares: n } = t;
              e.addSharedSecrets(r, n),
                e.isSecretsReady() &&
                  e.dispatchEventInstantly(new u.SecretsReady());
            } else if (t instanceof u.AnswerDecision) {
              const { decisionId: r, ciphertext: n, sender: i, digest: s } = t;
              e.answerDecision(r, i, n, s);
            } else if (t instanceof u.Mask) {
              const { sender: r, randomId: n, ciphertexts: i } = t;
              e.randomizeAndMask(r, n, i);
            } else if (t instanceof u.Lock) {
              const { sender: r, randomId: n, ciphertextsAndDigests: i } = t;
              e.lock(r, n, i);
            } else if (t instanceof u.Sync) {
              const { accessVersion: r, newPlayers: n, newServers: i } = t;
              if (r < e.accessVersion) throw new Error("Event ignored");
              for (const t of n) e.addPlayer(t);
              for (const t of i) e.addServer(t);
              e.accessVersion = r;
            } else if (t instanceof u.Leave) {
              const { playerAddr: r } = t;
              if (void 0 === e.players.find((e) => e.addr === r))
                throw new Error("Invalid player address");
            } else if (t instanceof u.GameStart) {
              const { accessVersion: r } = t;
              (e.status = "running"), e.setNodeReady(r);
            } else if (t instanceof u.SecretsReady)
              for (const t of e.randomStates) {
                const n = t.options,
                  i = await r.decryptWithSecrets(
                    t.listRevealedCiphertexts(),
                    t.listRevealedSecrets(),
                    n,
                  );
                e.addRevealedRandom(t.id, i);
              }
          }
          async generalPostHandleEvent(e, t) {}
          async customInitState(e, t) {
            const r = a(this, i, "f").exports,
              n = r.memory;
            n.grow(4);
            let s = new Uint8Array(n.buffer);
            const o = l.Effect.fromContext(e),
              d = (0, c.serialize)(o),
              u = d.length,
              h = (0, c.serialize)(t),
              f = h.length;
            if (
              (console.debug("Effect Bytes: [%s]", Array.of(d).toString()),
              s.length < 1 + f + u)
            )
              throw new Error(
                `WASM memory overflow, buffer length: ${s.length}, required: ${
                  1 + f + u
                }`,
              );
            let p = 1;
            s.set(d, p), (p += u), s.set(h, p);
            const m = (0, r.init_state)(u, f),
              y = new Uint8Array(n.buffer).slice(1, m + 1),
              g = (0, c.deserialize)(l.Effect, y);
            if (void 0 !== g.error) throw (console.error(g.error), g.error);
            e.applyEffect(g);
          }
          async customHandleEvent(e, t) {
            const r = a(this, i, "f").exports,
              n = r.memory;
            let s = new Uint8Array(n.buffer);
            const o = l.Effect.fromContext(e),
              d = (0, c.serialize)(o),
              u = d.length,
              h = (0, c.serialize)(t),
              f = h.length;
            if (s.length < 1 + f + u)
              throw new Error(
                `WASM memory overflow, buffer length: ${s.length}, required: ${
                  1 + f + u
                }`,
              );
            let p = 1;
            s.set(d, p), (p += u), s.set(h, p);
            const m = (0, r.handle_event)(u, f),
              y = new Uint8Array(n.buffer).slice(1, m + 1);
            let g;
            try {
              g = (0, c.deserialize)(l.Effect, y);
            } catch (e) {
              throw (
                (console.debug(
                  "Failed to deserialize effect, raw: [%s]",
                  Array.from(y).toString(),
                ),
                e)
              );
            }
            if (void 0 !== g.error) throw g.error;
            e.applyEffect(g);
          }
        }
        (t.Handler = f), (n = new WeakMap()), (i = new WeakMap());
      },
      978: function (e, t, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (e, t, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(t, r);
                  (i &&
                    !("get" in i
                      ? !t.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return t[r];
                      },
                    }),
                    Object.defineProperty(e, n, i);
                }
              : function (e, t, r, n) {
                  void 0 === n && (n = r), (e[n] = t[r]);
                }),
          i =
            (this && this.__exportStar) ||
            function (e, t) {
              for (var r in e)
                "default" === r ||
                  Object.prototype.hasOwnProperty.call(t, r) ||
                  n(t, e, r);
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          i(r(9918), t),
          i(r(162), t),
          i(r(302), t),
          i(r(4890), t),
          i(r(4784), t),
          i(r(2987), t),
          i(r(6793), t),
          i(r(5360), t),
          i(r(5740), t);
      },
      2944: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ProfileCache = void 0),
          (t.ProfileCache = class {
            constructor(e) {
              (this.transport = e), (this.caches = new Map());
            }
            async getProfile(e) {
              let t = this.caches.get(e);
              if (void 0 !== t) return t;
              {
                const t = await this.transport.getPlayerProfile(e);
                return void 0 === t ? void 0 : (this.caches.set(e, t), t);
              }
            }
            async injectProfiles(e) {
              for (let t of e.players) {
                const e = await this.getProfile(t.addr);
                t.profile = e;
              }
            }
          });
      },
      7403: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__decorate) ||
          function (e, t, r, n) {
            var i,
              s = arguments.length,
              o =
                s < 3
                  ? t
                  : null === n
                  ? (n = Object.getOwnPropertyDescriptor(t, r))
                  : n;
            if (
              "object" == typeof Reflect &&
              "function" == typeof Reflect.decorate
            )
              o = Reflect.decorate(e, t, r, n);
            else
              for (var a = e.length - 1; a >= 0; a--)
                (i = e[a]) &&
                  (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
            return s > 3 && o && Object.defineProperty(t, r, o), o;
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.RandomState =
            t.Share =
            t.LockedCiphertext =
            t.Mask =
            t.Lock =
            t.Lottery =
            t.ShuffledList =
            t.RandomSpec =
              void 0);
        const i = r(1786);
        class s {}
        t.RandomSpec = s;
        let o = class extends s {
          constructor(e) {
            super(), Object.assign(this, e);
          }
          asOptions() {
            return this.options;
          }
        };
        n(
          [(0, i.field)((0, i.array)("string"))],
          o.prototype,
          "options",
          void 0,
        ),
          (o = n([(0, i.variant)(0)], o)),
          (t.ShuffledList = o);
        let a = class extends s {
          constructor(e) {
            super(), Object.assign(this, e);
          }
          asOptions() {
            const e = [];
            for (const [t, r] of this.optionsAndWeights)
              for (let n = 0; n < r; n++) e.push(t);
            return e;
          }
        };
        n(
          [(0, i.field)((0, i.map)("string", "u16"))],
          a.prototype,
          "optionsAndWeights",
          void 0,
        ),
          (a = n([(0, i.variant)(1)], a)),
          (t.Lottery = a);
        class c {
          constructor(e, t) {
            (this.digest = t), (this.owner = e);
          }
        }
        t.Lock = c;
        class d {
          constructor(e) {
            (this.owner = e), (this.status = "required");
          }
        }
        t.Mask = d;
        class u {
          constructor(e) {
            (this.ciphertext = e),
              (this.locks = []),
              (this.owner = { kind: "unclaimed" });
          }
        }
        t.LockedCiphertext = u;
        class l {
          constructor(e, t, r) {
            (this.fromAddr = e),
              (this.index = t),
              (this.toAddr = r),
              (this.secret = void 0);
          }
        }
        (t.Share = l),
          (t.RandomState = class {
            constructor(e, t, r) {
              if (0 === r.length) throw new Error("No enough servers");
              this.owners = r;
              const n = t.asOptions(),
                i = n.map((e) => new u(new TextEncoder().encode(e)));
              (this.options = n),
                (this.size = n.length),
                (this.ciphertexts = i),
                (this.masks = r.map((e) => new d(e))),
                (this.id = e),
                (this.revealed = new Map()),
                (this.secretShares = []),
                (this.status = { kind: "masking", addr: r[0] });
            }
            isFullyMasked() {
              return this.masks.every((e) => "required" !== e.status);
            }
            isFullyLocked() {
              return this.masks.every((e) => "removed" === e.status);
            }
            mask(e, t) {
              if ("masking" !== this.status.kind)
                throw new Error("Invalid status" + this.status);
              {
                if (this.status.addr !== e) throw new Error("Invalid operator");
                const r = this.masks.find((t) => t.owner === e);
                if (void 0 === r) throw new Error("Invalid operator");
                if ("required" !== r.status) throw new Error("Duplicated mask");
                if (t.length !== this.ciphertexts.length)
                  throw new Error("Invalid ciphertexts");
                for (let e = 0; e < this.ciphertexts.length; e++)
                  this.ciphertexts[e].ciphertext = t[e];
                (r.status = "applied"), this.updateStatus();
              }
            }
            lock(e, t) {
              if ("locking" !== this.status.kind)
                throw new Error("Invalid status" + this.status);
              {
                if (this.status.addr !== e) throw new Error("Invalid operator");
                const r = this.masks.find((t) => t.owner === e);
                if (void 0 === r) throw new Error("Invalid operator");
                if (t.length !== this.ciphertexts.length)
                  throw new Error("Invalid ciphertexts");
                r.status = "removed";
                for (let r = 0; r < this.ciphertexts.length; r++) {
                  const { ciphertext: n, digest: i } = t[r];
                  (this.ciphertexts[r].ciphertext = n),
                    this.ciphertexts[r].locks.push(new c(e, i));
                }
                this.updateStatus();
              }
            }
            assign(e, t) {
              if (
                "ready" !== this.status.kind &&
                "waiting-secrets" !== this.status.kind
              )
                throw new Error("Invalid status" + this.status);
              for (const r of t) {
                let t = this.ciphertexts[r];
                if ("assigned" === t.owner.kind || "revealed" === t.owner.kind)
                  throw new Error("Ciphertext already assigned");
                t.owner = { kind: "assigned", addr: e };
                let n = this.secretShares;
                this.owners.forEach((t) => {
                  n.push(new l(t, r, e));
                });
              }
              this.status = { kind: "waiting-secrets" };
            }
            addSecretShare(e) {
              void 0 ===
                this.secretShares.find(
                  (t) =>
                    t.fromAddr === e.fromAddr &&
                    t.toAddr === e.toAddr &&
                    t.index === e.index,
                ) && this.secretShares.push(e);
            }
            reveal(e) {
              if (
                "ready" !== this.status.kind &&
                "waiting-secrets" !== this.status.kind
              )
                throw new Error("Invalid status" + this.status);
              for (const t of e) {
                let e = this.ciphertexts[t];
                if ("revealed" !== e.owner.kind) {
                  e.owner = { kind: "revealed" };
                  let r = this.secretShares;
                  this.owners.forEach((e) => {
                    r.push(new l(e, t));
                  });
                }
              }
              this.status = { kind: "waiting-secrets" };
            }
            listRequiredSecretsByFromAddr(e) {
              return this.secretShares
                .filter((t) => void 0 === t.secret && t.fromAddr === e)
                .map((e) => ({
                  fromAddr: e.fromAddr,
                  toAddr: e.toAddr,
                  randomId: this.id,
                  index: e.index,
                }));
            }
            listRevealedSecrets() {
              if ("ready" !== this.status.kind)
                throw new Error(
                  "Secrets not ready, current status: " + this.status.kind,
                );
              let e = new Map();
              for (const t of this.secretShares)
                if (void 0 === t.toAddr) {
                  let r = e.get(t.index);
                  void 0 === r ? e.set(t.index, [t.secret]) : r.push(t.secret);
                }
              return e;
            }
            listAssignedCiphertexts(e) {
              let t = new Map();
              for (let r = 0; r < this.ciphertexts.length; r++) {
                const n = this.ciphertexts[r];
                "assigned" === n.owner.kind &&
                  n.owner.addr === e &&
                  t.set(r, n.ciphertext);
              }
              return t;
            }
            listRevealedCiphertexts() {
              let e = new Map();
              for (let t = 0; t < this.ciphertexts.length; t++) {
                const r = this.ciphertexts[t];
                "revealed" === r.owner.kind && e.set(t, r.ciphertext);
              }
              return e;
            }
            listSharedSecrets(e) {
              if ("ready" !== this.status.kind)
                throw new Error(
                  "Secrets not ready, current status: " + this.status.kind,
                );
              let t = new Map();
              for (const r of this.secretShares)
                if (r.toAddr === e) {
                  let e = t.get(r.index);
                  void 0 === e ? t.set(r.index, [r.secret]) : e.push(r.secret);
                }
              return t;
            }
            addRevealed(e) {
              for (const [t, r] of e) {
                if (t >= this.size) throw new Error("Invalid index");
                this.revealed.set(t, r);
              }
            }
            addSecret(e, t, r, n) {
              const i = this.secretShares.find(
                (n) => n.fromAddr === e && n.toAddr === t && n.index === r,
              );
              if (void 0 !== i) {
                if (void 0 !== i.secret) throw new Error("Duplicated secret");
                if (void 0 === this.ciphertexts[i.index])
                  throw new Error("Invalid secret");
                i.secret = n;
              }
              this.updateStatus();
            }
            listOperatingAddrs() {
              switch (this.status.kind) {
                case "ready":
                  return [];
                case "locking":
                case "masking":
                  return [this.status.addr];
                case "waiting-secrets":
                  return this.secretShares
                    .filter((e) => void 0 === e.secret)
                    .map((e) => e.fromAddr);
              }
            }
            updateStatus() {
              let e = this.masks.find((e) => "required" === e.status);
              void 0 === e
                ? ((e = this.masks.find((e) => "applied" === e.status)),
                  void 0 === e
                    ? void 0 ===
                      this.secretShares.find((e) => void 0 === e.secret)
                      ? (this.status = { kind: "ready" })
                      : (this.status = { kind: "waiting-secrets" })
                    : (this.status = { kind: "locking", addr: e.owner }))
                : (this.status = { kind: "masking", addr: e.owner });
            }
          });
      },
      7498: function (e, t) {
        "use strict";
        var r,
          n =
            (this && this.__classPrivateFieldSet) ||
            function (e, t, r, n, i) {
              if ("m" === n)
                throw new TypeError("Private method is not writable");
              if ("a" === n && !i)
                throw new TypeError(
                  "Private accessor was defined without a setter",
                );
              if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError(
                  "Cannot write private member to an object whose class did not declare it",
                );
              return (
                "a" === n ? i.call(e, r) : i ? (i.value = r) : t.set(e, r), r
              );
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SecretState = void 0),
          (t.SecretState = class {
            constructor(e) {
              r.set(this, void 0), n(this, r, e, "f");
            }
            clear() {}
            isRandomLoaded(e) {
              return !0;
            }
            genRandomStates(e, t) {}
          }),
          (r = new WeakMap());
      },
      5740: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
      },
      9918: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
      },
      8895: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.base64ToUint8Array =
            t.base64ToArrayBuffer =
            t.arrayBufferToBase64 =
              void 0),
          (t.arrayBufferToBase64 = function (e) {
            let t = "",
              r = new Uint8Array(e),
              n = r.byteLength;
            for (let e = 0; e < n; e++) t += String.fromCharCode(r[e]);
            return btoa(t);
          }),
          (t.base64ToArrayBuffer = function (e) {
            const t = atob(e),
              r = new Uint8Array(t.length);
            for (let e = 0; e < t.length; e++) r[e] = t.charCodeAt(e);
            return r.buffer;
          }),
          (t.base64ToUint8Array = function (e) {
            const t = atob(e),
              r = new Uint8Array(t.length);
            for (let e = 0; e < t.length; e++) r[e] = t.charCodeAt(e);
            return r;
          });
      },
      162: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
      },
      3550: function (e, t, r) {
        !(function (e, t) {
          "use strict";
          function n(e, t) {
            if (!e) throw new Error(t || "Assertion failed");
          }
          function i(e, t) {
            e.super_ = t;
            var r = function () {};
            (r.prototype = t.prototype),
              (e.prototype = new r()),
              (e.prototype.constructor = e);
          }
          function s(e, t, r) {
            if (s.isBN(e)) return e;
            (this.negative = 0),
              (this.words = null),
              (this.length = 0),
              (this.red = null),
              null !== e &&
                (("le" !== t && "be" !== t) || ((r = t), (t = 10)),
                this._init(e || 0, t || 10, r || "be"));
          }
          var o;
          "object" == typeof e ? (e.exports = s) : (t.BN = s),
            (s.BN = s),
            (s.wordSize = 26);
          try {
            o =
              "undefined" != typeof window && void 0 !== window.Buffer
                ? window.Buffer
                : r(6601).Buffer;
          } catch (e) {}
          function a(e, t) {
            var r = e.charCodeAt(t);
            return r >= 48 && r <= 57
              ? r - 48
              : r >= 65 && r <= 70
              ? r - 55
              : r >= 97 && r <= 102
              ? r - 87
              : void n(!1, "Invalid character in " + e);
          }
          function c(e, t, r) {
            var n = a(e, r);
            return r - 1 >= t && (n |= a(e, r - 1) << 4), n;
          }
          function d(e, t, r, i) {
            for (
              var s = 0, o = 0, a = Math.min(e.length, r), c = t;
              c < a;
              c++
            ) {
              var d = e.charCodeAt(c) - 48;
              (s *= i),
                (o = d >= 49 ? d - 49 + 10 : d >= 17 ? d - 17 + 10 : d),
                n(d >= 0 && o < i, "Invalid character"),
                (s += o);
            }
            return s;
          }
          function u(e, t) {
            (e.words = t.words),
              (e.length = t.length),
              (e.negative = t.negative),
              (e.red = t.red);
          }
          if (
            ((s.isBN = function (e) {
              return (
                e instanceof s ||
                (null !== e &&
                  "object" == typeof e &&
                  e.constructor.wordSize === s.wordSize &&
                  Array.isArray(e.words))
              );
            }),
            (s.max = function (e, t) {
              return e.cmp(t) > 0 ? e : t;
            }),
            (s.min = function (e, t) {
              return e.cmp(t) < 0 ? e : t;
            }),
            (s.prototype._init = function (e, t, r) {
              if ("number" == typeof e) return this._initNumber(e, t, r);
              if ("object" == typeof e) return this._initArray(e, t, r);
              "hex" === t && (t = 16), n(t === (0 | t) && t >= 2 && t <= 36);
              var i = 0;
              "-" === (e = e.toString().replace(/\s+/g, ""))[0] &&
                (i++, (this.negative = 1)),
                i < e.length &&
                  (16 === t
                    ? this._parseHex(e, i, r)
                    : (this._parseBase(e, t, i),
                      "le" === r && this._initArray(this.toArray(), t, r)));
            }),
            (s.prototype._initNumber = function (e, t, r) {
              e < 0 && ((this.negative = 1), (e = -e)),
                e < 67108864
                  ? ((this.words = [67108863 & e]), (this.length = 1))
                  : e < 4503599627370496
                  ? ((this.words = [67108863 & e, (e / 67108864) & 67108863]),
                    (this.length = 2))
                  : (n(e < 9007199254740992),
                    (this.words = [67108863 & e, (e / 67108864) & 67108863, 1]),
                    (this.length = 3)),
                "le" === r && this._initArray(this.toArray(), t, r);
            }),
            (s.prototype._initArray = function (e, t, r) {
              if ((n("number" == typeof e.length), e.length <= 0))
                return (this.words = [0]), (this.length = 1), this;
              (this.length = Math.ceil(e.length / 3)),
                (this.words = new Array(this.length));
              for (var i = 0; i < this.length; i++) this.words[i] = 0;
              var s,
                o,
                a = 0;
              if ("be" === r)
                for (i = e.length - 1, s = 0; i >= 0; i -= 3)
                  (o = e[i] | (e[i - 1] << 8) | (e[i - 2] << 16)),
                    (this.words[s] |= (o << a) & 67108863),
                    (this.words[s + 1] = (o >>> (26 - a)) & 67108863),
                    (a += 24) >= 26 && ((a -= 26), s++);
              else if ("le" === r)
                for (i = 0, s = 0; i < e.length; i += 3)
                  (o = e[i] | (e[i + 1] << 8) | (e[i + 2] << 16)),
                    (this.words[s] |= (o << a) & 67108863),
                    (this.words[s + 1] = (o >>> (26 - a)) & 67108863),
                    (a += 24) >= 26 && ((a -= 26), s++);
              return this._strip();
            }),
            (s.prototype._parseHex = function (e, t, r) {
              (this.length = Math.ceil((e.length - t) / 6)),
                (this.words = new Array(this.length));
              for (var n = 0; n < this.length; n++) this.words[n] = 0;
              var i,
                s = 0,
                o = 0;
              if ("be" === r)
                for (n = e.length - 1; n >= t; n -= 2)
                  (i = c(e, t, n) << s),
                    (this.words[o] |= 67108863 & i),
                    s >= 18
                      ? ((s -= 18), (o += 1), (this.words[o] |= i >>> 26))
                      : (s += 8);
              else
                for (
                  n = (e.length - t) % 2 == 0 ? t + 1 : t;
                  n < e.length;
                  n += 2
                )
                  (i = c(e, t, n) << s),
                    (this.words[o] |= 67108863 & i),
                    s >= 18
                      ? ((s -= 18), (o += 1), (this.words[o] |= i >>> 26))
                      : (s += 8);
              this._strip();
            }),
            (s.prototype._parseBase = function (e, t, r) {
              (this.words = [0]), (this.length = 1);
              for (var n = 0, i = 1; i <= 67108863; i *= t) n++;
              n--, (i = (i / t) | 0);
              for (
                var s = e.length - r,
                  o = s % n,
                  a = Math.min(s, s - o) + r,
                  c = 0,
                  u = r;
                u < a;
                u += n
              )
                (c = d(e, u, u + n, t)),
                  this.imuln(i),
                  this.words[0] + c < 67108864
                    ? (this.words[0] += c)
                    : this._iaddn(c);
              if (0 !== o) {
                var l = 1;
                for (c = d(e, u, e.length, t), u = 0; u < o; u++) l *= t;
                this.imuln(l),
                  this.words[0] + c < 67108864
                    ? (this.words[0] += c)
                    : this._iaddn(c);
              }
              this._strip();
            }),
            (s.prototype.copy = function (e) {
              e.words = new Array(this.length);
              for (var t = 0; t < this.length; t++) e.words[t] = this.words[t];
              (e.length = this.length),
                (e.negative = this.negative),
                (e.red = this.red);
            }),
            (s.prototype._move = function (e) {
              u(e, this);
            }),
            (s.prototype.clone = function () {
              var e = new s(null);
              return this.copy(e), e;
            }),
            (s.prototype._expand = function (e) {
              for (; this.length < e; ) this.words[this.length++] = 0;
              return this;
            }),
            (s.prototype._strip = function () {
              for (; this.length > 1 && 0 === this.words[this.length - 1]; )
                this.length--;
              return this._normSign();
            }),
            (s.prototype._normSign = function () {
              return (
                1 === this.length && 0 === this.words[0] && (this.negative = 0),
                this
              );
            }),
            "undefined" != typeof Symbol && "function" == typeof Symbol.for)
          )
            try {
              s.prototype[Symbol.for("nodejs.util.inspect.custom")] = l;
            } catch (e) {
              s.prototype.inspect = l;
            }
          else s.prototype.inspect = l;
          function l() {
            return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
          }
          var h = [
              "",
              "0",
              "00",
              "000",
              "0000",
              "00000",
              "000000",
              "0000000",
              "00000000",
              "000000000",
              "0000000000",
              "00000000000",
              "000000000000",
              "0000000000000",
              "00000000000000",
              "000000000000000",
              "0000000000000000",
              "00000000000000000",
              "000000000000000000",
              "0000000000000000000",
              "00000000000000000000",
              "000000000000000000000",
              "0000000000000000000000",
              "00000000000000000000000",
              "000000000000000000000000",
              "0000000000000000000000000",
            ],
            f = [
              0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6,
              6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
            ],
            p = [
              0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607,
              16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536,
              11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101,
              5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368,
              20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875,
              60466176,
            ];
          function m(e, t, r) {
            r.negative = t.negative ^ e.negative;
            var n = (e.length + t.length) | 0;
            (r.length = n), (n = (n - 1) | 0);
            var i = 0 | e.words[0],
              s = 0 | t.words[0],
              o = i * s,
              a = 67108863 & o,
              c = (o / 67108864) | 0;
            r.words[0] = a;
            for (var d = 1; d < n; d++) {
              for (
                var u = c >>> 26,
                  l = 67108863 & c,
                  h = Math.min(d, t.length - 1),
                  f = Math.max(0, d - e.length + 1);
                f <= h;
                f++
              ) {
                var p = (d - f) | 0;
                (u +=
                  ((o = (i = 0 | e.words[p]) * (s = 0 | t.words[f]) + l) /
                    67108864) |
                  0),
                  (l = 67108863 & o);
              }
              (r.words[d] = 0 | l), (c = 0 | u);
            }
            return 0 !== c ? (r.words[d] = 0 | c) : r.length--, r._strip();
          }
          (s.prototype.toString = function (e, t) {
            var r;
            if (((t = 0 | t || 1), 16 === (e = e || 10) || "hex" === e)) {
              r = "";
              for (var i = 0, s = 0, o = 0; o < this.length; o++) {
                var a = this.words[o],
                  c = (16777215 & ((a << i) | s)).toString(16);
                (s = (a >>> (24 - i)) & 16777215),
                  (i += 2) >= 26 && ((i -= 26), o--),
                  (r =
                    0 !== s || o !== this.length - 1
                      ? h[6 - c.length] + c + r
                      : c + r);
              }
              for (0 !== s && (r = s.toString(16) + r); r.length % t != 0; )
                r = "0" + r;
              return 0 !== this.negative && (r = "-" + r), r;
            }
            if (e === (0 | e) && e >= 2 && e <= 36) {
              var d = f[e],
                u = p[e];
              r = "";
              var l = this.clone();
              for (l.negative = 0; !l.isZero(); ) {
                var m = l.modrn(u).toString(e);
                r = (l = l.idivn(u)).isZero() ? m + r : h[d - m.length] + m + r;
              }
              for (this.isZero() && (r = "0" + r); r.length % t != 0; )
                r = "0" + r;
              return 0 !== this.negative && (r = "-" + r), r;
            }
            n(!1, "Base should be between 2 and 36");
          }),
            (s.prototype.toNumber = function () {
              var e = this.words[0];
              return (
                2 === this.length
                  ? (e += 67108864 * this.words[1])
                  : 3 === this.length && 1 === this.words[2]
                  ? (e += 4503599627370496 + 67108864 * this.words[1])
                  : this.length > 2 &&
                    n(!1, "Number can only safely store up to 53 bits"),
                0 !== this.negative ? -e : e
              );
            }),
            (s.prototype.toJSON = function () {
              return this.toString(16, 2);
            }),
            o &&
              (s.prototype.toBuffer = function (e, t) {
                return this.toArrayLike(o, e, t);
              }),
            (s.prototype.toArray = function (e, t) {
              return this.toArrayLike(Array, e, t);
            }),
            (s.prototype.toArrayLike = function (e, t, r) {
              this._strip();
              var i = this.byteLength(),
                s = r || Math.max(1, i);
              n(i <= s, "byte array longer than desired length"),
                n(s > 0, "Requested array length <= 0");
              var o = (function (e, t) {
                return e.allocUnsafe ? e.allocUnsafe(t) : new e(t);
              })(e, s);
              return this["_toArrayLike" + ("le" === t ? "LE" : "BE")](o, i), o;
            }),
            (s.prototype._toArrayLikeLE = function (e, t) {
              for (var r = 0, n = 0, i = 0, s = 0; i < this.length; i++) {
                var o = (this.words[i] << s) | n;
                (e[r++] = 255 & o),
                  r < e.length && (e[r++] = (o >> 8) & 255),
                  r < e.length && (e[r++] = (o >> 16) & 255),
                  6 === s
                    ? (r < e.length && (e[r++] = (o >> 24) & 255),
                      (n = 0),
                      (s = 0))
                    : ((n = o >>> 24), (s += 2));
              }
              if (r < e.length) for (e[r++] = n; r < e.length; ) e[r++] = 0;
            }),
            (s.prototype._toArrayLikeBE = function (e, t) {
              for (
                var r = e.length - 1, n = 0, i = 0, s = 0;
                i < this.length;
                i++
              ) {
                var o = (this.words[i] << s) | n;
                (e[r--] = 255 & o),
                  r >= 0 && (e[r--] = (o >> 8) & 255),
                  r >= 0 && (e[r--] = (o >> 16) & 255),
                  6 === s
                    ? (r >= 0 && (e[r--] = (o >> 24) & 255), (n = 0), (s = 0))
                    : ((n = o >>> 24), (s += 2));
              }
              if (r >= 0) for (e[r--] = n; r >= 0; ) e[r--] = 0;
            }),
            Math.clz32
              ? (s.prototype._countBits = function (e) {
                  return 32 - Math.clz32(e);
                })
              : (s.prototype._countBits = function (e) {
                  var t = e,
                    r = 0;
                  return (
                    t >= 4096 && ((r += 13), (t >>>= 13)),
                    t >= 64 && ((r += 7), (t >>>= 7)),
                    t >= 8 && ((r += 4), (t >>>= 4)),
                    t >= 2 && ((r += 2), (t >>>= 2)),
                    r + t
                  );
                }),
            (s.prototype._zeroBits = function (e) {
              if (0 === e) return 26;
              var t = e,
                r = 0;
              return (
                0 == (8191 & t) && ((r += 13), (t >>>= 13)),
                0 == (127 & t) && ((r += 7), (t >>>= 7)),
                0 == (15 & t) && ((r += 4), (t >>>= 4)),
                0 == (3 & t) && ((r += 2), (t >>>= 2)),
                0 == (1 & t) && r++,
                r
              );
            }),
            (s.prototype.bitLength = function () {
              var e = this.words[this.length - 1],
                t = this._countBits(e);
              return 26 * (this.length - 1) + t;
            }),
            (s.prototype.zeroBits = function () {
              if (this.isZero()) return 0;
              for (var e = 0, t = 0; t < this.length; t++) {
                var r = this._zeroBits(this.words[t]);
                if (((e += r), 26 !== r)) break;
              }
              return e;
            }),
            (s.prototype.byteLength = function () {
              return Math.ceil(this.bitLength() / 8);
            }),
            (s.prototype.toTwos = function (e) {
              return 0 !== this.negative
                ? this.abs().inotn(e).iaddn(1)
                : this.clone();
            }),
            (s.prototype.fromTwos = function (e) {
              return this.testn(e - 1)
                ? this.notn(e).iaddn(1).ineg()
                : this.clone();
            }),
            (s.prototype.isNeg = function () {
              return 0 !== this.negative;
            }),
            (s.prototype.neg = function () {
              return this.clone().ineg();
            }),
            (s.prototype.ineg = function () {
              return this.isZero() || (this.negative ^= 1), this;
            }),
            (s.prototype.iuor = function (e) {
              for (; this.length < e.length; ) this.words[this.length++] = 0;
              for (var t = 0; t < e.length; t++)
                this.words[t] = this.words[t] | e.words[t];
              return this._strip();
            }),
            (s.prototype.ior = function (e) {
              return n(0 == (this.negative | e.negative)), this.iuor(e);
            }),
            (s.prototype.or = function (e) {
              return this.length > e.length
                ? this.clone().ior(e)
                : e.clone().ior(this);
            }),
            (s.prototype.uor = function (e) {
              return this.length > e.length
                ? this.clone().iuor(e)
                : e.clone().iuor(this);
            }),
            (s.prototype.iuand = function (e) {
              var t;
              t = this.length > e.length ? e : this;
              for (var r = 0; r < t.length; r++)
                this.words[r] = this.words[r] & e.words[r];
              return (this.length = t.length), this._strip();
            }),
            (s.prototype.iand = function (e) {
              return n(0 == (this.negative | e.negative)), this.iuand(e);
            }),
            (s.prototype.and = function (e) {
              return this.length > e.length
                ? this.clone().iand(e)
                : e.clone().iand(this);
            }),
            (s.prototype.uand = function (e) {
              return this.length > e.length
                ? this.clone().iuand(e)
                : e.clone().iuand(this);
            }),
            (s.prototype.iuxor = function (e) {
              var t, r;
              this.length > e.length
                ? ((t = this), (r = e))
                : ((t = e), (r = this));
              for (var n = 0; n < r.length; n++)
                this.words[n] = t.words[n] ^ r.words[n];
              if (this !== t)
                for (; n < t.length; n++) this.words[n] = t.words[n];
              return (this.length = t.length), this._strip();
            }),
            (s.prototype.ixor = function (e) {
              return n(0 == (this.negative | e.negative)), this.iuxor(e);
            }),
            (s.prototype.xor = function (e) {
              return this.length > e.length
                ? this.clone().ixor(e)
                : e.clone().ixor(this);
            }),
            (s.prototype.uxor = function (e) {
              return this.length > e.length
                ? this.clone().iuxor(e)
                : e.clone().iuxor(this);
            }),
            (s.prototype.inotn = function (e) {
              n("number" == typeof e && e >= 0);
              var t = 0 | Math.ceil(e / 26),
                r = e % 26;
              this._expand(t), r > 0 && t--;
              for (var i = 0; i < t; i++)
                this.words[i] = 67108863 & ~this.words[i];
              return (
                r > 0 &&
                  (this.words[i] = ~this.words[i] & (67108863 >> (26 - r))),
                this._strip()
              );
            }),
            (s.prototype.notn = function (e) {
              return this.clone().inotn(e);
            }),
            (s.prototype.setn = function (e, t) {
              n("number" == typeof e && e >= 0);
              var r = (e / 26) | 0,
                i = e % 26;
              return (
                this._expand(r + 1),
                (this.words[r] = t
                  ? this.words[r] | (1 << i)
                  : this.words[r] & ~(1 << i)),
                this._strip()
              );
            }),
            (s.prototype.iadd = function (e) {
              var t, r, n;
              if (0 !== this.negative && 0 === e.negative)
                return (
                  (this.negative = 0),
                  (t = this.isub(e)),
                  (this.negative ^= 1),
                  this._normSign()
                );
              if (0 === this.negative && 0 !== e.negative)
                return (
                  (e.negative = 0),
                  (t = this.isub(e)),
                  (e.negative = 1),
                  t._normSign()
                );
              this.length > e.length
                ? ((r = this), (n = e))
                : ((r = e), (n = this));
              for (var i = 0, s = 0; s < n.length; s++)
                (t = (0 | r.words[s]) + (0 | n.words[s]) + i),
                  (this.words[s] = 67108863 & t),
                  (i = t >>> 26);
              for (; 0 !== i && s < r.length; s++)
                (t = (0 | r.words[s]) + i),
                  (this.words[s] = 67108863 & t),
                  (i = t >>> 26);
              if (((this.length = r.length), 0 !== i))
                (this.words[this.length] = i), this.length++;
              else if (r !== this)
                for (; s < r.length; s++) this.words[s] = r.words[s];
              return this;
            }),
            (s.prototype.add = function (e) {
              var t;
              return 0 !== e.negative && 0 === this.negative
                ? ((e.negative = 0), (t = this.sub(e)), (e.negative ^= 1), t)
                : 0 === e.negative && 0 !== this.negative
                ? ((this.negative = 0),
                  (t = e.sub(this)),
                  (this.negative = 1),
                  t)
                : this.length > e.length
                ? this.clone().iadd(e)
                : e.clone().iadd(this);
            }),
            (s.prototype.isub = function (e) {
              if (0 !== e.negative) {
                e.negative = 0;
                var t = this.iadd(e);
                return (e.negative = 1), t._normSign();
              }
              if (0 !== this.negative)
                return (
                  (this.negative = 0),
                  this.iadd(e),
                  (this.negative = 1),
                  this._normSign()
                );
              var r,
                n,
                i = this.cmp(e);
              if (0 === i)
                return (
                  (this.negative = 0),
                  (this.length = 1),
                  (this.words[0] = 0),
                  this
                );
              i > 0 ? ((r = this), (n = e)) : ((r = e), (n = this));
              for (var s = 0, o = 0; o < n.length; o++)
                (s = (t = (0 | r.words[o]) - (0 | n.words[o]) + s) >> 26),
                  (this.words[o] = 67108863 & t);
              for (; 0 !== s && o < r.length; o++)
                (s = (t = (0 | r.words[o]) + s) >> 26),
                  (this.words[o] = 67108863 & t);
              if (0 === s && o < r.length && r !== this)
                for (; o < r.length; o++) this.words[o] = r.words[o];
              return (
                (this.length = Math.max(this.length, o)),
                r !== this && (this.negative = 1),
                this._strip()
              );
            }),
            (s.prototype.sub = function (e) {
              return this.clone().isub(e);
            });
          var y = function (e, t, r) {
            var n,
              i,
              s,
              o = e.words,
              a = t.words,
              c = r.words,
              d = 0,
              u = 0 | o[0],
              l = 8191 & u,
              h = u >>> 13,
              f = 0 | o[1],
              p = 8191 & f,
              m = f >>> 13,
              y = 0 | o[2],
              g = 8191 & y,
              v = y >>> 13,
              b = 0 | o[3],
              w = 8191 & b,
              E = b >>> 13,
              A = 0 | o[4],
              _ = 8191 & A,
              T = A >>> 13,
              R = 0 | o[5],
              I = 8191 & R,
              S = R >>> 13,
              x = 0 | o[6],
              P = 8191 & x,
              O = x >>> 13,
              C = 0 | o[7],
              k = 8191 & C,
              M = C >>> 13,
              N = 0 | o[8],
              B = 8191 & N,
              D = N >>> 13,
              j = 0 | o[9],
              L = 8191 & j,
              U = j >>> 13,
              F = 0 | a[0],
              H = 8191 & F,
              G = F >>> 13,
              V = 0 | a[1],
              W = 8191 & V,
              q = V >>> 13,
              Z = 0 | a[2],
              z = 8191 & Z,
              K = Z >>> 13,
              J = 0 | a[3],
              X = 8191 & J,
              Q = J >>> 13,
              $ = 0 | a[4],
              Y = 8191 & $,
              ee = $ >>> 13,
              te = 0 | a[5],
              re = 8191 & te,
              ne = te >>> 13,
              ie = 0 | a[6],
              se = 8191 & ie,
              oe = ie >>> 13,
              ae = 0 | a[7],
              ce = 8191 & ae,
              de = ae >>> 13,
              ue = 0 | a[8],
              le = 8191 & ue,
              he = ue >>> 13,
              fe = 0 | a[9],
              pe = 8191 & fe,
              me = fe >>> 13;
            (r.negative = e.negative ^ t.negative), (r.length = 19);
            var ye =
              (((d + (n = Math.imul(l, H))) | 0) +
                ((8191 & (i = ((i = Math.imul(l, G)) + Math.imul(h, H)) | 0)) <<
                  13)) |
              0;
            (d =
              ((((s = Math.imul(h, G)) + (i >>> 13)) | 0) + (ye >>> 26)) | 0),
              (ye &= 67108863),
              (n = Math.imul(p, H)),
              (i = ((i = Math.imul(p, G)) + Math.imul(m, H)) | 0),
              (s = Math.imul(m, G));
            var ge =
              (((d + (n = (n + Math.imul(l, W)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(l, q)) | 0) + Math.imul(h, W)) | 0)) <<
                  13)) |
              0;
            (d =
              ((((s = (s + Math.imul(h, q)) | 0) + (i >>> 13)) | 0) +
                (ge >>> 26)) |
              0),
              (ge &= 67108863),
              (n = Math.imul(g, H)),
              (i = ((i = Math.imul(g, G)) + Math.imul(v, H)) | 0),
              (s = Math.imul(v, G)),
              (n = (n + Math.imul(p, W)) | 0),
              (i = ((i = (i + Math.imul(p, q)) | 0) + Math.imul(m, W)) | 0),
              (s = (s + Math.imul(m, q)) | 0);
            var ve =
              (((d + (n = (n + Math.imul(l, z)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(l, K)) | 0) + Math.imul(h, z)) | 0)) <<
                  13)) |
              0;
            (d =
              ((((s = (s + Math.imul(h, K)) | 0) + (i >>> 13)) | 0) +
                (ve >>> 26)) |
              0),
              (ve &= 67108863),
              (n = Math.imul(w, H)),
              (i = ((i = Math.imul(w, G)) + Math.imul(E, H)) | 0),
              (s = Math.imul(E, G)),
              (n = (n + Math.imul(g, W)) | 0),
              (i = ((i = (i + Math.imul(g, q)) | 0) + Math.imul(v, W)) | 0),
              (s = (s + Math.imul(v, q)) | 0),
              (n = (n + Math.imul(p, z)) | 0),
              (i = ((i = (i + Math.imul(p, K)) | 0) + Math.imul(m, z)) | 0),
              (s = (s + Math.imul(m, K)) | 0);
            var be =
              (((d + (n = (n + Math.imul(l, X)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(l, Q)) | 0) + Math.imul(h, X)) | 0)) <<
                  13)) |
              0;
            (d =
              ((((s = (s + Math.imul(h, Q)) | 0) + (i >>> 13)) | 0) +
                (be >>> 26)) |
              0),
              (be &= 67108863),
              (n = Math.imul(_, H)),
              (i = ((i = Math.imul(_, G)) + Math.imul(T, H)) | 0),
              (s = Math.imul(T, G)),
              (n = (n + Math.imul(w, W)) | 0),
              (i = ((i = (i + Math.imul(w, q)) | 0) + Math.imul(E, W)) | 0),
              (s = (s + Math.imul(E, q)) | 0),
              (n = (n + Math.imul(g, z)) | 0),
              (i = ((i = (i + Math.imul(g, K)) | 0) + Math.imul(v, z)) | 0),
              (s = (s + Math.imul(v, K)) | 0),
              (n = (n + Math.imul(p, X)) | 0),
              (i = ((i = (i + Math.imul(p, Q)) | 0) + Math.imul(m, X)) | 0),
              (s = (s + Math.imul(m, Q)) | 0);
            var we =
              (((d + (n = (n + Math.imul(l, Y)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(l, ee)) | 0) + Math.imul(h, Y)) |
                    0)) <<
                  13)) |
              0;
            (d =
              ((((s = (s + Math.imul(h, ee)) | 0) + (i >>> 13)) | 0) +
                (we >>> 26)) |
              0),
              (we &= 67108863),
              (n = Math.imul(I, H)),
              (i = ((i = Math.imul(I, G)) + Math.imul(S, H)) | 0),
              (s = Math.imul(S, G)),
              (n = (n + Math.imul(_, W)) | 0),
              (i = ((i = (i + Math.imul(_, q)) | 0) + Math.imul(T, W)) | 0),
              (s = (s + Math.imul(T, q)) | 0),
              (n = (n + Math.imul(w, z)) | 0),
              (i = ((i = (i + Math.imul(w, K)) | 0) + Math.imul(E, z)) | 0),
              (s = (s + Math.imul(E, K)) | 0),
              (n = (n + Math.imul(g, X)) | 0),
              (i = ((i = (i + Math.imul(g, Q)) | 0) + Math.imul(v, X)) | 0),
              (s = (s + Math.imul(v, Q)) | 0),
              (n = (n + Math.imul(p, Y)) | 0),
              (i = ((i = (i + Math.imul(p, ee)) | 0) + Math.imul(m, Y)) | 0),
              (s = (s + Math.imul(m, ee)) | 0);
            var Ee =
              (((d + (n = (n + Math.imul(l, re)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(l, ne)) | 0) + Math.imul(h, re)) |
                    0)) <<
                  13)) |
              0;
            (d =
              ((((s = (s + Math.imul(h, ne)) | 0) + (i >>> 13)) | 0) +
                (Ee >>> 26)) |
              0),
              (Ee &= 67108863),
              (n = Math.imul(P, H)),
              (i = ((i = Math.imul(P, G)) + Math.imul(O, H)) | 0),
              (s = Math.imul(O, G)),
              (n = (n + Math.imul(I, W)) | 0),
              (i = ((i = (i + Math.imul(I, q)) | 0) + Math.imul(S, W)) | 0),
              (s = (s + Math.imul(S, q)) | 0),
              (n = (n + Math.imul(_, z)) | 0),
              (i = ((i = (i + Math.imul(_, K)) | 0) + Math.imul(T, z)) | 0),
              (s = (s + Math.imul(T, K)) | 0),
              (n = (n + Math.imul(w, X)) | 0),
              (i = ((i = (i + Math.imul(w, Q)) | 0) + Math.imul(E, X)) | 0),
              (s = (s + Math.imul(E, Q)) | 0),
              (n = (n + Math.imul(g, Y)) | 0),
              (i = ((i = (i + Math.imul(g, ee)) | 0) + Math.imul(v, Y)) | 0),
              (s = (s + Math.imul(v, ee)) | 0),
              (n = (n + Math.imul(p, re)) | 0),
              (i = ((i = (i + Math.imul(p, ne)) | 0) + Math.imul(m, re)) | 0),
              (s = (s + Math.imul(m, ne)) | 0);
            var Ae =
              (((d + (n = (n + Math.imul(l, se)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(l, oe)) | 0) + Math.imul(h, se)) |
                    0)) <<
                  13)) |
              0;
            (d =
              ((((s = (s + Math.imul(h, oe)) | 0) + (i >>> 13)) | 0) +
                (Ae >>> 26)) |
              0),
              (Ae &= 67108863),
              (n = Math.imul(k, H)),
              (i = ((i = Math.imul(k, G)) + Math.imul(M, H)) | 0),
              (s = Math.imul(M, G)),
              (n = (n + Math.imul(P, W)) | 0),
              (i = ((i = (i + Math.imul(P, q)) | 0) + Math.imul(O, W)) | 0),
              (s = (s + Math.imul(O, q)) | 0),
              (n = (n + Math.imul(I, z)) | 0),
              (i = ((i = (i + Math.imul(I, K)) | 0) + Math.imul(S, z)) | 0),
              (s = (s + Math.imul(S, K)) | 0),
              (n = (n + Math.imul(_, X)) | 0),
              (i = ((i = (i + Math.imul(_, Q)) | 0) + Math.imul(T, X)) | 0),
              (s = (s + Math.imul(T, Q)) | 0),
              (n = (n + Math.imul(w, Y)) | 0),
              (i = ((i = (i + Math.imul(w, ee)) | 0) + Math.imul(E, Y)) | 0),
              (s = (s + Math.imul(E, ee)) | 0),
              (n = (n + Math.imul(g, re)) | 0),
              (i = ((i = (i + Math.imul(g, ne)) | 0) + Math.imul(v, re)) | 0),
              (s = (s + Math.imul(v, ne)) | 0),
              (n = (n + Math.imul(p, se)) | 0),
              (i = ((i = (i + Math.imul(p, oe)) | 0) + Math.imul(m, se)) | 0),
              (s = (s + Math.imul(m, oe)) | 0);
            var _e =
              (((d + (n = (n + Math.imul(l, ce)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(l, de)) | 0) + Math.imul(h, ce)) |
                    0)) <<
                  13)) |
              0;
            (d =
              ((((s = (s + Math.imul(h, de)) | 0) + (i >>> 13)) | 0) +
                (_e >>> 26)) |
              0),
              (_e &= 67108863),
              (n = Math.imul(B, H)),
              (i = ((i = Math.imul(B, G)) + Math.imul(D, H)) | 0),
              (s = Math.imul(D, G)),
              (n = (n + Math.imul(k, W)) | 0),
              (i = ((i = (i + Math.imul(k, q)) | 0) + Math.imul(M, W)) | 0),
              (s = (s + Math.imul(M, q)) | 0),
              (n = (n + Math.imul(P, z)) | 0),
              (i = ((i = (i + Math.imul(P, K)) | 0) + Math.imul(O, z)) | 0),
              (s = (s + Math.imul(O, K)) | 0),
              (n = (n + Math.imul(I, X)) | 0),
              (i = ((i = (i + Math.imul(I, Q)) | 0) + Math.imul(S, X)) | 0),
              (s = (s + Math.imul(S, Q)) | 0),
              (n = (n + Math.imul(_, Y)) | 0),
              (i = ((i = (i + Math.imul(_, ee)) | 0) + Math.imul(T, Y)) | 0),
              (s = (s + Math.imul(T, ee)) | 0),
              (n = (n + Math.imul(w, re)) | 0),
              (i = ((i = (i + Math.imul(w, ne)) | 0) + Math.imul(E, re)) | 0),
              (s = (s + Math.imul(E, ne)) | 0),
              (n = (n + Math.imul(g, se)) | 0),
              (i = ((i = (i + Math.imul(g, oe)) | 0) + Math.imul(v, se)) | 0),
              (s = (s + Math.imul(v, oe)) | 0),
              (n = (n + Math.imul(p, ce)) | 0),
              (i = ((i = (i + Math.imul(p, de)) | 0) + Math.imul(m, ce)) | 0),
              (s = (s + Math.imul(m, de)) | 0);
            var Te =
              (((d + (n = (n + Math.imul(l, le)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(l, he)) | 0) + Math.imul(h, le)) |
                    0)) <<
                  13)) |
              0;
            (d =
              ((((s = (s + Math.imul(h, he)) | 0) + (i >>> 13)) | 0) +
                (Te >>> 26)) |
              0),
              (Te &= 67108863),
              (n = Math.imul(L, H)),
              (i = ((i = Math.imul(L, G)) + Math.imul(U, H)) | 0),
              (s = Math.imul(U, G)),
              (n = (n + Math.imul(B, W)) | 0),
              (i = ((i = (i + Math.imul(B, q)) | 0) + Math.imul(D, W)) | 0),
              (s = (s + Math.imul(D, q)) | 0),
              (n = (n + Math.imul(k, z)) | 0),
              (i = ((i = (i + Math.imul(k, K)) | 0) + Math.imul(M, z)) | 0),
              (s = (s + Math.imul(M, K)) | 0),
              (n = (n + Math.imul(P, X)) | 0),
              (i = ((i = (i + Math.imul(P, Q)) | 0) + Math.imul(O, X)) | 0),
              (s = (s + Math.imul(O, Q)) | 0),
              (n = (n + Math.imul(I, Y)) | 0),
              (i = ((i = (i + Math.imul(I, ee)) | 0) + Math.imul(S, Y)) | 0),
              (s = (s + Math.imul(S, ee)) | 0),
              (n = (n + Math.imul(_, re)) | 0),
              (i = ((i = (i + Math.imul(_, ne)) | 0) + Math.imul(T, re)) | 0),
              (s = (s + Math.imul(T, ne)) | 0),
              (n = (n + Math.imul(w, se)) | 0),
              (i = ((i = (i + Math.imul(w, oe)) | 0) + Math.imul(E, se)) | 0),
              (s = (s + Math.imul(E, oe)) | 0),
              (n = (n + Math.imul(g, ce)) | 0),
              (i = ((i = (i + Math.imul(g, de)) | 0) + Math.imul(v, ce)) | 0),
              (s = (s + Math.imul(v, de)) | 0),
              (n = (n + Math.imul(p, le)) | 0),
              (i = ((i = (i + Math.imul(p, he)) | 0) + Math.imul(m, le)) | 0),
              (s = (s + Math.imul(m, he)) | 0);
            var Re =
              (((d + (n = (n + Math.imul(l, pe)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(l, me)) | 0) + Math.imul(h, pe)) |
                    0)) <<
                  13)) |
              0;
            (d =
              ((((s = (s + Math.imul(h, me)) | 0) + (i >>> 13)) | 0) +
                (Re >>> 26)) |
              0),
              (Re &= 67108863),
              (n = Math.imul(L, W)),
              (i = ((i = Math.imul(L, q)) + Math.imul(U, W)) | 0),
              (s = Math.imul(U, q)),
              (n = (n + Math.imul(B, z)) | 0),
              (i = ((i = (i + Math.imul(B, K)) | 0) + Math.imul(D, z)) | 0),
              (s = (s + Math.imul(D, K)) | 0),
              (n = (n + Math.imul(k, X)) | 0),
              (i = ((i = (i + Math.imul(k, Q)) | 0) + Math.imul(M, X)) | 0),
              (s = (s + Math.imul(M, Q)) | 0),
              (n = (n + Math.imul(P, Y)) | 0),
              (i = ((i = (i + Math.imul(P, ee)) | 0) + Math.imul(O, Y)) | 0),
              (s = (s + Math.imul(O, ee)) | 0),
              (n = (n + Math.imul(I, re)) | 0),
              (i = ((i = (i + Math.imul(I, ne)) | 0) + Math.imul(S, re)) | 0),
              (s = (s + Math.imul(S, ne)) | 0),
              (n = (n + Math.imul(_, se)) | 0),
              (i = ((i = (i + Math.imul(_, oe)) | 0) + Math.imul(T, se)) | 0),
              (s = (s + Math.imul(T, oe)) | 0),
              (n = (n + Math.imul(w, ce)) | 0),
              (i = ((i = (i + Math.imul(w, de)) | 0) + Math.imul(E, ce)) | 0),
              (s = (s + Math.imul(E, de)) | 0),
              (n = (n + Math.imul(g, le)) | 0),
              (i = ((i = (i + Math.imul(g, he)) | 0) + Math.imul(v, le)) | 0),
              (s = (s + Math.imul(v, he)) | 0);
            var Ie =
              (((d + (n = (n + Math.imul(p, pe)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(p, me)) | 0) + Math.imul(m, pe)) |
                    0)) <<
                  13)) |
              0;
            (d =
              ((((s = (s + Math.imul(m, me)) | 0) + (i >>> 13)) | 0) +
                (Ie >>> 26)) |
              0),
              (Ie &= 67108863),
              (n = Math.imul(L, z)),
              (i = ((i = Math.imul(L, K)) + Math.imul(U, z)) | 0),
              (s = Math.imul(U, K)),
              (n = (n + Math.imul(B, X)) | 0),
              (i = ((i = (i + Math.imul(B, Q)) | 0) + Math.imul(D, X)) | 0),
              (s = (s + Math.imul(D, Q)) | 0),
              (n = (n + Math.imul(k, Y)) | 0),
              (i = ((i = (i + Math.imul(k, ee)) | 0) + Math.imul(M, Y)) | 0),
              (s = (s + Math.imul(M, ee)) | 0),
              (n = (n + Math.imul(P, re)) | 0),
              (i = ((i = (i + Math.imul(P, ne)) | 0) + Math.imul(O, re)) | 0),
              (s = (s + Math.imul(O, ne)) | 0),
              (n = (n + Math.imul(I, se)) | 0),
              (i = ((i = (i + Math.imul(I, oe)) | 0) + Math.imul(S, se)) | 0),
              (s = (s + Math.imul(S, oe)) | 0),
              (n = (n + Math.imul(_, ce)) | 0),
              (i = ((i = (i + Math.imul(_, de)) | 0) + Math.imul(T, ce)) | 0),
              (s = (s + Math.imul(T, de)) | 0),
              (n = (n + Math.imul(w, le)) | 0),
              (i = ((i = (i + Math.imul(w, he)) | 0) + Math.imul(E, le)) | 0),
              (s = (s + Math.imul(E, he)) | 0);
            var Se =
              (((d + (n = (n + Math.imul(g, pe)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(g, me)) | 0) + Math.imul(v, pe)) |
                    0)) <<
                  13)) |
              0;
            (d =
              ((((s = (s + Math.imul(v, me)) | 0) + (i >>> 13)) | 0) +
                (Se >>> 26)) |
              0),
              (Se &= 67108863),
              (n = Math.imul(L, X)),
              (i = ((i = Math.imul(L, Q)) + Math.imul(U, X)) | 0),
              (s = Math.imul(U, Q)),
              (n = (n + Math.imul(B, Y)) | 0),
              (i = ((i = (i + Math.imul(B, ee)) | 0) + Math.imul(D, Y)) | 0),
              (s = (s + Math.imul(D, ee)) | 0),
              (n = (n + Math.imul(k, re)) | 0),
              (i = ((i = (i + Math.imul(k, ne)) | 0) + Math.imul(M, re)) | 0),
              (s = (s + Math.imul(M, ne)) | 0),
              (n = (n + Math.imul(P, se)) | 0),
              (i = ((i = (i + Math.imul(P, oe)) | 0) + Math.imul(O, se)) | 0),
              (s = (s + Math.imul(O, oe)) | 0),
              (n = (n + Math.imul(I, ce)) | 0),
              (i = ((i = (i + Math.imul(I, de)) | 0) + Math.imul(S, ce)) | 0),
              (s = (s + Math.imul(S, de)) | 0),
              (n = (n + Math.imul(_, le)) | 0),
              (i = ((i = (i + Math.imul(_, he)) | 0) + Math.imul(T, le)) | 0),
              (s = (s + Math.imul(T, he)) | 0);
            var xe =
              (((d + (n = (n + Math.imul(w, pe)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(w, me)) | 0) + Math.imul(E, pe)) |
                    0)) <<
                  13)) |
              0;
            (d =
              ((((s = (s + Math.imul(E, me)) | 0) + (i >>> 13)) | 0) +
                (xe >>> 26)) |
              0),
              (xe &= 67108863),
              (n = Math.imul(L, Y)),
              (i = ((i = Math.imul(L, ee)) + Math.imul(U, Y)) | 0),
              (s = Math.imul(U, ee)),
              (n = (n + Math.imul(B, re)) | 0),
              (i = ((i = (i + Math.imul(B, ne)) | 0) + Math.imul(D, re)) | 0),
              (s = (s + Math.imul(D, ne)) | 0),
              (n = (n + Math.imul(k, se)) | 0),
              (i = ((i = (i + Math.imul(k, oe)) | 0) + Math.imul(M, se)) | 0),
              (s = (s + Math.imul(M, oe)) | 0),
              (n = (n + Math.imul(P, ce)) | 0),
              (i = ((i = (i + Math.imul(P, de)) | 0) + Math.imul(O, ce)) | 0),
              (s = (s + Math.imul(O, de)) | 0),
              (n = (n + Math.imul(I, le)) | 0),
              (i = ((i = (i + Math.imul(I, he)) | 0) + Math.imul(S, le)) | 0),
              (s = (s + Math.imul(S, he)) | 0);
            var Pe =
              (((d + (n = (n + Math.imul(_, pe)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(_, me)) | 0) + Math.imul(T, pe)) |
                    0)) <<
                  13)) |
              0;
            (d =
              ((((s = (s + Math.imul(T, me)) | 0) + (i >>> 13)) | 0) +
                (Pe >>> 26)) |
              0),
              (Pe &= 67108863),
              (n = Math.imul(L, re)),
              (i = ((i = Math.imul(L, ne)) + Math.imul(U, re)) | 0),
              (s = Math.imul(U, ne)),
              (n = (n + Math.imul(B, se)) | 0),
              (i = ((i = (i + Math.imul(B, oe)) | 0) + Math.imul(D, se)) | 0),
              (s = (s + Math.imul(D, oe)) | 0),
              (n = (n + Math.imul(k, ce)) | 0),
              (i = ((i = (i + Math.imul(k, de)) | 0) + Math.imul(M, ce)) | 0),
              (s = (s + Math.imul(M, de)) | 0),
              (n = (n + Math.imul(P, le)) | 0),
              (i = ((i = (i + Math.imul(P, he)) | 0) + Math.imul(O, le)) | 0),
              (s = (s + Math.imul(O, he)) | 0);
            var Oe =
              (((d + (n = (n + Math.imul(I, pe)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(I, me)) | 0) + Math.imul(S, pe)) |
                    0)) <<
                  13)) |
              0;
            (d =
              ((((s = (s + Math.imul(S, me)) | 0) + (i >>> 13)) | 0) +
                (Oe >>> 26)) |
              0),
              (Oe &= 67108863),
              (n = Math.imul(L, se)),
              (i = ((i = Math.imul(L, oe)) + Math.imul(U, se)) | 0),
              (s = Math.imul(U, oe)),
              (n = (n + Math.imul(B, ce)) | 0),
              (i = ((i = (i + Math.imul(B, de)) | 0) + Math.imul(D, ce)) | 0),
              (s = (s + Math.imul(D, de)) | 0),
              (n = (n + Math.imul(k, le)) | 0),
              (i = ((i = (i + Math.imul(k, he)) | 0) + Math.imul(M, le)) | 0),
              (s = (s + Math.imul(M, he)) | 0);
            var Ce =
              (((d + (n = (n + Math.imul(P, pe)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(P, me)) | 0) + Math.imul(O, pe)) |
                    0)) <<
                  13)) |
              0;
            (d =
              ((((s = (s + Math.imul(O, me)) | 0) + (i >>> 13)) | 0) +
                (Ce >>> 26)) |
              0),
              (Ce &= 67108863),
              (n = Math.imul(L, ce)),
              (i = ((i = Math.imul(L, de)) + Math.imul(U, ce)) | 0),
              (s = Math.imul(U, de)),
              (n = (n + Math.imul(B, le)) | 0),
              (i = ((i = (i + Math.imul(B, he)) | 0) + Math.imul(D, le)) | 0),
              (s = (s + Math.imul(D, he)) | 0);
            var ke =
              (((d + (n = (n + Math.imul(k, pe)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(k, me)) | 0) + Math.imul(M, pe)) |
                    0)) <<
                  13)) |
              0;
            (d =
              ((((s = (s + Math.imul(M, me)) | 0) + (i >>> 13)) | 0) +
                (ke >>> 26)) |
              0),
              (ke &= 67108863),
              (n = Math.imul(L, le)),
              (i = ((i = Math.imul(L, he)) + Math.imul(U, le)) | 0),
              (s = Math.imul(U, he));
            var Me =
              (((d + (n = (n + Math.imul(B, pe)) | 0)) | 0) +
                ((8191 &
                  (i =
                    ((i = (i + Math.imul(B, me)) | 0) + Math.imul(D, pe)) |
                    0)) <<
                  13)) |
              0;
            (d =
              ((((s = (s + Math.imul(D, me)) | 0) + (i >>> 13)) | 0) +
                (Me >>> 26)) |
              0),
              (Me &= 67108863);
            var Ne =
              (((d + (n = Math.imul(L, pe))) | 0) +
                ((8191 &
                  (i = ((i = Math.imul(L, me)) + Math.imul(U, pe)) | 0)) <<
                  13)) |
              0;
            return (
              (d =
                ((((s = Math.imul(U, me)) + (i >>> 13)) | 0) + (Ne >>> 26)) |
                0),
              (Ne &= 67108863),
              (c[0] = ye),
              (c[1] = ge),
              (c[2] = ve),
              (c[3] = be),
              (c[4] = we),
              (c[5] = Ee),
              (c[6] = Ae),
              (c[7] = _e),
              (c[8] = Te),
              (c[9] = Re),
              (c[10] = Ie),
              (c[11] = Se),
              (c[12] = xe),
              (c[13] = Pe),
              (c[14] = Oe),
              (c[15] = Ce),
              (c[16] = ke),
              (c[17] = Me),
              (c[18] = Ne),
              0 !== d && ((c[19] = d), r.length++),
              r
            );
          };
          function g(e, t, r) {
            (r.negative = t.negative ^ e.negative),
              (r.length = e.length + t.length);
            for (var n = 0, i = 0, s = 0; s < r.length - 1; s++) {
              var o = i;
              i = 0;
              for (
                var a = 67108863 & n,
                  c = Math.min(s, t.length - 1),
                  d = Math.max(0, s - e.length + 1);
                d <= c;
                d++
              ) {
                var u = s - d,
                  l = (0 | e.words[u]) * (0 | t.words[d]),
                  h = 67108863 & l;
                (a = 67108863 & (h = (h + a) | 0)),
                  (i +=
                    (o =
                      ((o = (o + ((l / 67108864) | 0)) | 0) + (h >>> 26)) |
                      0) >>> 26),
                  (o &= 67108863);
              }
              (r.words[s] = a), (n = o), (o = i);
            }
            return 0 !== n ? (r.words[s] = n) : r.length--, r._strip();
          }
          function v(e, t, r) {
            return g(e, t, r);
          }
          function b(e, t) {
            (this.x = e), (this.y = t);
          }
          Math.imul || (y = m),
            (s.prototype.mulTo = function (e, t) {
              var r = this.length + e.length;
              return 10 === this.length && 10 === e.length
                ? y(this, e, t)
                : r < 63
                ? m(this, e, t)
                : r < 1024
                ? g(this, e, t)
                : v(this, e, t);
            }),
            (b.prototype.makeRBT = function (e) {
              for (
                var t = new Array(e), r = s.prototype._countBits(e) - 1, n = 0;
                n < e;
                n++
              )
                t[n] = this.revBin(n, r, e);
              return t;
            }),
            (b.prototype.revBin = function (e, t, r) {
              if (0 === e || e === r - 1) return e;
              for (var n = 0, i = 0; i < t; i++)
                (n |= (1 & e) << (t - i - 1)), (e >>= 1);
              return n;
            }),
            (b.prototype.permute = function (e, t, r, n, i, s) {
              for (var o = 0; o < s; o++) (n[o] = t[e[o]]), (i[o] = r[e[o]]);
            }),
            (b.prototype.transform = function (e, t, r, n, i, s) {
              this.permute(s, e, t, r, n, i);
              for (var o = 1; o < i; o <<= 1)
                for (
                  var a = o << 1,
                    c = Math.cos((2 * Math.PI) / a),
                    d = Math.sin((2 * Math.PI) / a),
                    u = 0;
                  u < i;
                  u += a
                )
                  for (var l = c, h = d, f = 0; f < o; f++) {
                    var p = r[u + f],
                      m = n[u + f],
                      y = r[u + f + o],
                      g = n[u + f + o],
                      v = l * y - h * g;
                    (g = l * g + h * y),
                      (y = v),
                      (r[u + f] = p + y),
                      (n[u + f] = m + g),
                      (r[u + f + o] = p - y),
                      (n[u + f + o] = m - g),
                      f !== a &&
                        ((v = c * l - d * h), (h = c * h + d * l), (l = v));
                  }
            }),
            (b.prototype.guessLen13b = function (e, t) {
              var r = 1 | Math.max(t, e),
                n = 1 & r,
                i = 0;
              for (r = (r / 2) | 0; r; r >>>= 1) i++;
              return 1 << (i + 1 + n);
            }),
            (b.prototype.conjugate = function (e, t, r) {
              if (!(r <= 1))
                for (var n = 0; n < r / 2; n++) {
                  var i = e[n];
                  (e[n] = e[r - n - 1]),
                    (e[r - n - 1] = i),
                    (i = t[n]),
                    (t[n] = -t[r - n - 1]),
                    (t[r - n - 1] = -i);
                }
            }),
            (b.prototype.normalize13b = function (e, t) {
              for (var r = 0, n = 0; n < t / 2; n++) {
                var i =
                  8192 * Math.round(e[2 * n + 1] / t) +
                  Math.round(e[2 * n] / t) +
                  r;
                (e[n] = 67108863 & i),
                  (r = i < 67108864 ? 0 : (i / 67108864) | 0);
              }
              return e;
            }),
            (b.prototype.convert13b = function (e, t, r, i) {
              for (var s = 0, o = 0; o < t; o++)
                (s += 0 | e[o]),
                  (r[2 * o] = 8191 & s),
                  (s >>>= 13),
                  (r[2 * o + 1] = 8191 & s),
                  (s >>>= 13);
              for (o = 2 * t; o < i; ++o) r[o] = 0;
              n(0 === s), n(0 == (-8192 & s));
            }),
            (b.prototype.stub = function (e) {
              for (var t = new Array(e), r = 0; r < e; r++) t[r] = 0;
              return t;
            }),
            (b.prototype.mulp = function (e, t, r) {
              var n = 2 * this.guessLen13b(e.length, t.length),
                i = this.makeRBT(n),
                s = this.stub(n),
                o = new Array(n),
                a = new Array(n),
                c = new Array(n),
                d = new Array(n),
                u = new Array(n),
                l = new Array(n),
                h = r.words;
              (h.length = n),
                this.convert13b(e.words, e.length, o, n),
                this.convert13b(t.words, t.length, d, n),
                this.transform(o, s, a, c, n, i),
                this.transform(d, s, u, l, n, i);
              for (var f = 0; f < n; f++) {
                var p = a[f] * u[f] - c[f] * l[f];
                (c[f] = a[f] * l[f] + c[f] * u[f]), (a[f] = p);
              }
              return (
                this.conjugate(a, c, n),
                this.transform(a, c, h, s, n, i),
                this.conjugate(h, s, n),
                this.normalize13b(h, n),
                (r.negative = e.negative ^ t.negative),
                (r.length = e.length + t.length),
                r._strip()
              );
            }),
            (s.prototype.mul = function (e) {
              var t = new s(null);
              return (
                (t.words = new Array(this.length + e.length)), this.mulTo(e, t)
              );
            }),
            (s.prototype.mulf = function (e) {
              var t = new s(null);
              return (
                (t.words = new Array(this.length + e.length)), v(this, e, t)
              );
            }),
            (s.prototype.imul = function (e) {
              return this.clone().mulTo(e, this);
            }),
            (s.prototype.imuln = function (e) {
              var t = e < 0;
              t && (e = -e), n("number" == typeof e), n(e < 67108864);
              for (var r = 0, i = 0; i < this.length; i++) {
                var s = (0 | this.words[i]) * e,
                  o = (67108863 & s) + (67108863 & r);
                (r >>= 26),
                  (r += (s / 67108864) | 0),
                  (r += o >>> 26),
                  (this.words[i] = 67108863 & o);
              }
              return (
                0 !== r && ((this.words[i] = r), this.length++),
                t ? this.ineg() : this
              );
            }),
            (s.prototype.muln = function (e) {
              return this.clone().imuln(e);
            }),
            (s.prototype.sqr = function () {
              return this.mul(this);
            }),
            (s.prototype.isqr = function () {
              return this.imul(this.clone());
            }),
            (s.prototype.pow = function (e) {
              var t = (function (e) {
                for (
                  var t = new Array(e.bitLength()), r = 0;
                  r < t.length;
                  r++
                ) {
                  var n = (r / 26) | 0,
                    i = r % 26;
                  t[r] = (e.words[n] >>> i) & 1;
                }
                return t;
              })(e);
              if (0 === t.length) return new s(1);
              for (
                var r = this, n = 0;
                n < t.length && 0 === t[n];
                n++, r = r.sqr()
              );
              if (++n < t.length)
                for (var i = r.sqr(); n < t.length; n++, i = i.sqr())
                  0 !== t[n] && (r = r.mul(i));
              return r;
            }),
            (s.prototype.iushln = function (e) {
              n("number" == typeof e && e >= 0);
              var t,
                r = e % 26,
                i = (e - r) / 26,
                s = (67108863 >>> (26 - r)) << (26 - r);
              if (0 !== r) {
                var o = 0;
                for (t = 0; t < this.length; t++) {
                  var a = this.words[t] & s,
                    c = ((0 | this.words[t]) - a) << r;
                  (this.words[t] = c | o), (o = a >>> (26 - r));
                }
                o && ((this.words[t] = o), this.length++);
              }
              if (0 !== i) {
                for (t = this.length - 1; t >= 0; t--)
                  this.words[t + i] = this.words[t];
                for (t = 0; t < i; t++) this.words[t] = 0;
                this.length += i;
              }
              return this._strip();
            }),
            (s.prototype.ishln = function (e) {
              return n(0 === this.negative), this.iushln(e);
            }),
            (s.prototype.iushrn = function (e, t, r) {
              var i;
              n("number" == typeof e && e >= 0),
                (i = t ? (t - (t % 26)) / 26 : 0);
              var s = e % 26,
                o = Math.min((e - s) / 26, this.length),
                a = 67108863 ^ ((67108863 >>> s) << s),
                c = r;
              if (((i -= o), (i = Math.max(0, i)), c)) {
                for (var d = 0; d < o; d++) c.words[d] = this.words[d];
                c.length = o;
              }
              if (0 === o);
              else if (this.length > o)
                for (this.length -= o, d = 0; d < this.length; d++)
                  this.words[d] = this.words[d + o];
              else (this.words[0] = 0), (this.length = 1);
              var u = 0;
              for (d = this.length - 1; d >= 0 && (0 !== u || d >= i); d--) {
                var l = 0 | this.words[d];
                (this.words[d] = (u << (26 - s)) | (l >>> s)), (u = l & a);
              }
              return (
                c && 0 !== u && (c.words[c.length++] = u),
                0 === this.length && ((this.words[0] = 0), (this.length = 1)),
                this._strip()
              );
            }),
            (s.prototype.ishrn = function (e, t, r) {
              return n(0 === this.negative), this.iushrn(e, t, r);
            }),
            (s.prototype.shln = function (e) {
              return this.clone().ishln(e);
            }),
            (s.prototype.ushln = function (e) {
              return this.clone().iushln(e);
            }),
            (s.prototype.shrn = function (e) {
              return this.clone().ishrn(e);
            }),
            (s.prototype.ushrn = function (e) {
              return this.clone().iushrn(e);
            }),
            (s.prototype.testn = function (e) {
              n("number" == typeof e && e >= 0);
              var t = e % 26,
                r = (e - t) / 26,
                i = 1 << t;
              return !(this.length <= r || !(this.words[r] & i));
            }),
            (s.prototype.imaskn = function (e) {
              n("number" == typeof e && e >= 0);
              var t = e % 26,
                r = (e - t) / 26;
              if (
                (n(
                  0 === this.negative,
                  "imaskn works only with positive numbers",
                ),
                this.length <= r)
              )
                return this;
              if (
                (0 !== t && r++,
                (this.length = Math.min(r, this.length)),
                0 !== t)
              ) {
                var i = 67108863 ^ ((67108863 >>> t) << t);
                this.words[this.length - 1] &= i;
              }
              return this._strip();
            }),
            (s.prototype.maskn = function (e) {
              return this.clone().imaskn(e);
            }),
            (s.prototype.iaddn = function (e) {
              return (
                n("number" == typeof e),
                n(e < 67108864),
                e < 0
                  ? this.isubn(-e)
                  : 0 !== this.negative
                  ? 1 === this.length && (0 | this.words[0]) <= e
                    ? ((this.words[0] = e - (0 | this.words[0])),
                      (this.negative = 0),
                      this)
                    : ((this.negative = 0),
                      this.isubn(e),
                      (this.negative = 1),
                      this)
                  : this._iaddn(e)
              );
            }),
            (s.prototype._iaddn = function (e) {
              this.words[0] += e;
              for (var t = 0; t < this.length && this.words[t] >= 67108864; t++)
                (this.words[t] -= 67108864),
                  t === this.length - 1
                    ? (this.words[t + 1] = 1)
                    : this.words[t + 1]++;
              return (this.length = Math.max(this.length, t + 1)), this;
            }),
            (s.prototype.isubn = function (e) {
              if ((n("number" == typeof e), n(e < 67108864), e < 0))
                return this.iaddn(-e);
              if (0 !== this.negative)
                return (
                  (this.negative = 0), this.iaddn(e), (this.negative = 1), this
                );
              if (
                ((this.words[0] -= e), 1 === this.length && this.words[0] < 0)
              )
                (this.words[0] = -this.words[0]), (this.negative = 1);
              else
                for (var t = 0; t < this.length && this.words[t] < 0; t++)
                  (this.words[t] += 67108864), (this.words[t + 1] -= 1);
              return this._strip();
            }),
            (s.prototype.addn = function (e) {
              return this.clone().iaddn(e);
            }),
            (s.prototype.subn = function (e) {
              return this.clone().isubn(e);
            }),
            (s.prototype.iabs = function () {
              return (this.negative = 0), this;
            }),
            (s.prototype.abs = function () {
              return this.clone().iabs();
            }),
            (s.prototype._ishlnsubmul = function (e, t, r) {
              var i,
                s,
                o = e.length + r;
              this._expand(o);
              var a = 0;
              for (i = 0; i < e.length; i++) {
                s = (0 | this.words[i + r]) + a;
                var c = (0 | e.words[i]) * t;
                (a = ((s -= 67108863 & c) >> 26) - ((c / 67108864) | 0)),
                  (this.words[i + r] = 67108863 & s);
              }
              for (; i < this.length - r; i++)
                (a = (s = (0 | this.words[i + r]) + a) >> 26),
                  (this.words[i + r] = 67108863 & s);
              if (0 === a) return this._strip();
              for (n(-1 === a), a = 0, i = 0; i < this.length; i++)
                (a = (s = -(0 | this.words[i]) + a) >> 26),
                  (this.words[i] = 67108863 & s);
              return (this.negative = 1), this._strip();
            }),
            (s.prototype._wordDiv = function (e, t) {
              var r = (this.length, e.length),
                n = this.clone(),
                i = e,
                o = 0 | i.words[i.length - 1];
              0 != (r = 26 - this._countBits(o)) &&
                ((i = i.ushln(r)),
                n.iushln(r),
                (o = 0 | i.words[i.length - 1]));
              var a,
                c = n.length - i.length;
              if ("mod" !== t) {
                ((a = new s(null)).length = c + 1),
                  (a.words = new Array(a.length));
                for (var d = 0; d < a.length; d++) a.words[d] = 0;
              }
              var u = n.clone()._ishlnsubmul(i, 1, c);
              0 === u.negative && ((n = u), a && (a.words[c] = 1));
              for (var l = c - 1; l >= 0; l--) {
                var h =
                  67108864 * (0 | n.words[i.length + l]) +
                  (0 | n.words[i.length + l - 1]);
                for (
                  h = Math.min((h / o) | 0, 67108863), n._ishlnsubmul(i, h, l);
                  0 !== n.negative;

                )
                  h--,
                    (n.negative = 0),
                    n._ishlnsubmul(i, 1, l),
                    n.isZero() || (n.negative ^= 1);
                a && (a.words[l] = h);
              }
              return (
                a && a._strip(),
                n._strip(),
                "div" !== t && 0 !== r && n.iushrn(r),
                { div: a || null, mod: n }
              );
            }),
            (s.prototype.divmod = function (e, t, r) {
              return (
                n(!e.isZero()),
                this.isZero()
                  ? { div: new s(0), mod: new s(0) }
                  : 0 !== this.negative && 0 === e.negative
                  ? ((a = this.neg().divmod(e, t)),
                    "mod" !== t && (i = a.div.neg()),
                    "div" !== t &&
                      ((o = a.mod.neg()), r && 0 !== o.negative && o.iadd(e)),
                    { div: i, mod: o })
                  : 0 === this.negative && 0 !== e.negative
                  ? ((a = this.divmod(e.neg(), t)),
                    "mod" !== t && (i = a.div.neg()),
                    { div: i, mod: a.mod })
                  : 0 != (this.negative & e.negative)
                  ? ((a = this.neg().divmod(e.neg(), t)),
                    "div" !== t &&
                      ((o = a.mod.neg()), r && 0 !== o.negative && o.isub(e)),
                    { div: a.div, mod: o })
                  : e.length > this.length || this.cmp(e) < 0
                  ? { div: new s(0), mod: this }
                  : 1 === e.length
                  ? "div" === t
                    ? { div: this.divn(e.words[0]), mod: null }
                    : "mod" === t
                    ? { div: null, mod: new s(this.modrn(e.words[0])) }
                    : {
                        div: this.divn(e.words[0]),
                        mod: new s(this.modrn(e.words[0])),
                      }
                  : this._wordDiv(e, t)
              );
              var i, o, a;
            }),
            (s.prototype.div = function (e) {
              return this.divmod(e, "div", !1).div;
            }),
            (s.prototype.mod = function (e) {
              return this.divmod(e, "mod", !1).mod;
            }),
            (s.prototype.umod = function (e) {
              return this.divmod(e, "mod", !0).mod;
            }),
            (s.prototype.divRound = function (e) {
              var t = this.divmod(e);
              if (t.mod.isZero()) return t.div;
              var r = 0 !== t.div.negative ? t.mod.isub(e) : t.mod,
                n = e.ushrn(1),
                i = e.andln(1),
                s = r.cmp(n);
              return s < 0 || (1 === i && 0 === s)
                ? t.div
                : 0 !== t.div.negative
                ? t.div.isubn(1)
                : t.div.iaddn(1);
            }),
            (s.prototype.modrn = function (e) {
              var t = e < 0;
              t && (e = -e), n(e <= 67108863);
              for (
                var r = (1 << 26) % e, i = 0, s = this.length - 1;
                s >= 0;
                s--
              )
                i = (r * i + (0 | this.words[s])) % e;
              return t ? -i : i;
            }),
            (s.prototype.modn = function (e) {
              return this.modrn(e);
            }),
            (s.prototype.idivn = function (e) {
              var t = e < 0;
              t && (e = -e), n(e <= 67108863);
              for (var r = 0, i = this.length - 1; i >= 0; i--) {
                var s = (0 | this.words[i]) + 67108864 * r;
                (this.words[i] = (s / e) | 0), (r = s % e);
              }
              return this._strip(), t ? this.ineg() : this;
            }),
            (s.prototype.divn = function (e) {
              return this.clone().idivn(e);
            }),
            (s.prototype.egcd = function (e) {
              n(0 === e.negative), n(!e.isZero());
              var t = this,
                r = e.clone();
              t = 0 !== t.negative ? t.umod(e) : t.clone();
              for (
                var i = new s(1),
                  o = new s(0),
                  a = new s(0),
                  c = new s(1),
                  d = 0;
                t.isEven() && r.isEven();

              )
                t.iushrn(1), r.iushrn(1), ++d;
              for (var u = r.clone(), l = t.clone(); !t.isZero(); ) {
                for (
                  var h = 0, f = 1;
                  0 == (t.words[0] & f) && h < 26;
                  ++h, f <<= 1
                );
                if (h > 0)
                  for (t.iushrn(h); h-- > 0; )
                    (i.isOdd() || o.isOdd()) && (i.iadd(u), o.isub(l)),
                      i.iushrn(1),
                      o.iushrn(1);
                for (
                  var p = 0, m = 1;
                  0 == (r.words[0] & m) && p < 26;
                  ++p, m <<= 1
                );
                if (p > 0)
                  for (r.iushrn(p); p-- > 0; )
                    (a.isOdd() || c.isOdd()) && (a.iadd(u), c.isub(l)),
                      a.iushrn(1),
                      c.iushrn(1);
                t.cmp(r) >= 0
                  ? (t.isub(r), i.isub(a), o.isub(c))
                  : (r.isub(t), a.isub(i), c.isub(o));
              }
              return { a, b: c, gcd: r.iushln(d) };
            }),
            (s.prototype._invmp = function (e) {
              n(0 === e.negative), n(!e.isZero());
              var t = this,
                r = e.clone();
              t = 0 !== t.negative ? t.umod(e) : t.clone();
              for (
                var i, o = new s(1), a = new s(0), c = r.clone();
                t.cmpn(1) > 0 && r.cmpn(1) > 0;

              ) {
                for (
                  var d = 0, u = 1;
                  0 == (t.words[0] & u) && d < 26;
                  ++d, u <<= 1
                );
                if (d > 0)
                  for (t.iushrn(d); d-- > 0; )
                    o.isOdd() && o.iadd(c), o.iushrn(1);
                for (
                  var l = 0, h = 1;
                  0 == (r.words[0] & h) && l < 26;
                  ++l, h <<= 1
                );
                if (l > 0)
                  for (r.iushrn(l); l-- > 0; )
                    a.isOdd() && a.iadd(c), a.iushrn(1);
                t.cmp(r) >= 0 ? (t.isub(r), o.isub(a)) : (r.isub(t), a.isub(o));
              }
              return (i = 0 === t.cmpn(1) ? o : a).cmpn(0) < 0 && i.iadd(e), i;
            }),
            (s.prototype.gcd = function (e) {
              if (this.isZero()) return e.abs();
              if (e.isZero()) return this.abs();
              var t = this.clone(),
                r = e.clone();
              (t.negative = 0), (r.negative = 0);
              for (var n = 0; t.isEven() && r.isEven(); n++)
                t.iushrn(1), r.iushrn(1);
              for (;;) {
                for (; t.isEven(); ) t.iushrn(1);
                for (; r.isEven(); ) r.iushrn(1);
                var i = t.cmp(r);
                if (i < 0) {
                  var s = t;
                  (t = r), (r = s);
                } else if (0 === i || 0 === r.cmpn(1)) break;
                t.isub(r);
              }
              return r.iushln(n);
            }),
            (s.prototype.invm = function (e) {
              return this.egcd(e).a.umod(e);
            }),
            (s.prototype.isEven = function () {
              return 0 == (1 & this.words[0]);
            }),
            (s.prototype.isOdd = function () {
              return 1 == (1 & this.words[0]);
            }),
            (s.prototype.andln = function (e) {
              return this.words[0] & e;
            }),
            (s.prototype.bincn = function (e) {
              n("number" == typeof e);
              var t = e % 26,
                r = (e - t) / 26,
                i = 1 << t;
              if (this.length <= r)
                return this._expand(r + 1), (this.words[r] |= i), this;
              for (var s = i, o = r; 0 !== s && o < this.length; o++) {
                var a = 0 | this.words[o];
                (s = (a += s) >>> 26), (a &= 67108863), (this.words[o] = a);
              }
              return 0 !== s && ((this.words[o] = s), this.length++), this;
            }),
            (s.prototype.isZero = function () {
              return 1 === this.length && 0 === this.words[0];
            }),
            (s.prototype.cmpn = function (e) {
              var t,
                r = e < 0;
              if (0 !== this.negative && !r) return -1;
              if (0 === this.negative && r) return 1;
              if ((this._strip(), this.length > 1)) t = 1;
              else {
                r && (e = -e), n(e <= 67108863, "Number is too big");
                var i = 0 | this.words[0];
                t = i === e ? 0 : i < e ? -1 : 1;
              }
              return 0 !== this.negative ? 0 | -t : t;
            }),
            (s.prototype.cmp = function (e) {
              if (0 !== this.negative && 0 === e.negative) return -1;
              if (0 === this.negative && 0 !== e.negative) return 1;
              var t = this.ucmp(e);
              return 0 !== this.negative ? 0 | -t : t;
            }),
            (s.prototype.ucmp = function (e) {
              if (this.length > e.length) return 1;
              if (this.length < e.length) return -1;
              for (var t = 0, r = this.length - 1; r >= 0; r--) {
                var n = 0 | this.words[r],
                  i = 0 | e.words[r];
                if (n !== i) {
                  n < i ? (t = -1) : n > i && (t = 1);
                  break;
                }
              }
              return t;
            }),
            (s.prototype.gtn = function (e) {
              return 1 === this.cmpn(e);
            }),
            (s.prototype.gt = function (e) {
              return 1 === this.cmp(e);
            }),
            (s.prototype.gten = function (e) {
              return this.cmpn(e) >= 0;
            }),
            (s.prototype.gte = function (e) {
              return this.cmp(e) >= 0;
            }),
            (s.prototype.ltn = function (e) {
              return -1 === this.cmpn(e);
            }),
            (s.prototype.lt = function (e) {
              return -1 === this.cmp(e);
            }),
            (s.prototype.lten = function (e) {
              return this.cmpn(e) <= 0;
            }),
            (s.prototype.lte = function (e) {
              return this.cmp(e) <= 0;
            }),
            (s.prototype.eqn = function (e) {
              return 0 === this.cmpn(e);
            }),
            (s.prototype.eq = function (e) {
              return 0 === this.cmp(e);
            }),
            (s.red = function (e) {
              return new I(e);
            }),
            (s.prototype.toRed = function (e) {
              return (
                n(!this.red, "Already a number in reduction context"),
                n(0 === this.negative, "red works only with positives"),
                e.convertTo(this)._forceRed(e)
              );
            }),
            (s.prototype.fromRed = function () {
              return (
                n(
                  this.red,
                  "fromRed works only with numbers in reduction context",
                ),
                this.red.convertFrom(this)
              );
            }),
            (s.prototype._forceRed = function (e) {
              return (this.red = e), this;
            }),
            (s.prototype.forceRed = function (e) {
              return (
                n(!this.red, "Already a number in reduction context"),
                this._forceRed(e)
              );
            }),
            (s.prototype.redAdd = function (e) {
              return (
                n(this.red, "redAdd works only with red numbers"),
                this.red.add(this, e)
              );
            }),
            (s.prototype.redIAdd = function (e) {
              return (
                n(this.red, "redIAdd works only with red numbers"),
                this.red.iadd(this, e)
              );
            }),
            (s.prototype.redSub = function (e) {
              return (
                n(this.red, "redSub works only with red numbers"),
                this.red.sub(this, e)
              );
            }),
            (s.prototype.redISub = function (e) {
              return (
                n(this.red, "redISub works only with red numbers"),
                this.red.isub(this, e)
              );
            }),
            (s.prototype.redShl = function (e) {
              return (
                n(this.red, "redShl works only with red numbers"),
                this.red.shl(this, e)
              );
            }),
            (s.prototype.redMul = function (e) {
              return (
                n(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, e),
                this.red.mul(this, e)
              );
            }),
            (s.prototype.redIMul = function (e) {
              return (
                n(this.red, "redMul works only with red numbers"),
                this.red._verify2(this, e),
                this.red.imul(this, e)
              );
            }),
            (s.prototype.redSqr = function () {
              return (
                n(this.red, "redSqr works only with red numbers"),
                this.red._verify1(this),
                this.red.sqr(this)
              );
            }),
            (s.prototype.redISqr = function () {
              return (
                n(this.red, "redISqr works only with red numbers"),
                this.red._verify1(this),
                this.red.isqr(this)
              );
            }),
            (s.prototype.redSqrt = function () {
              return (
                n(this.red, "redSqrt works only with red numbers"),
                this.red._verify1(this),
                this.red.sqrt(this)
              );
            }),
            (s.prototype.redInvm = function () {
              return (
                n(this.red, "redInvm works only with red numbers"),
                this.red._verify1(this),
                this.red.invm(this)
              );
            }),
            (s.prototype.redNeg = function () {
              return (
                n(this.red, "redNeg works only with red numbers"),
                this.red._verify1(this),
                this.red.neg(this)
              );
            }),
            (s.prototype.redPow = function (e) {
              return (
                n(this.red && !e.red, "redPow(normalNum)"),
                this.red._verify1(this),
                this.red.pow(this, e)
              );
            });
          var w = { k256: null, p224: null, p192: null, p25519: null };
          function E(e, t) {
            (this.name = e),
              (this.p = new s(t, 16)),
              (this.n = this.p.bitLength()),
              (this.k = new s(1).iushln(this.n).isub(this.p)),
              (this.tmp = this._tmp());
          }
          function A() {
            E.call(
              this,
              "k256",
              "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
            );
          }
          function _() {
            E.call(
              this,
              "p224",
              "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
            );
          }
          function T() {
            E.call(
              this,
              "p192",
              "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
            );
          }
          function R() {
            E.call(
              this,
              "25519",
              "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
            );
          }
          function I(e) {
            if ("string" == typeof e) {
              var t = s._prime(e);
              (this.m = t.p), (this.prime = t);
            } else
              n(e.gtn(1), "modulus must be greater than 1"),
                (this.m = e),
                (this.prime = null);
          }
          function S(e) {
            I.call(this, e),
              (this.shift = this.m.bitLength()),
              this.shift % 26 != 0 && (this.shift += 26 - (this.shift % 26)),
              (this.r = new s(1).iushln(this.shift)),
              (this.r2 = this.imod(this.r.sqr())),
              (this.rinv = this.r._invmp(this.m)),
              (this.minv = this.rinv.mul(this.r).isubn(1).div(this.m)),
              (this.minv = this.minv.umod(this.r)),
              (this.minv = this.r.sub(this.minv));
          }
          (E.prototype._tmp = function () {
            var e = new s(null);
            return (e.words = new Array(Math.ceil(this.n / 13))), e;
          }),
            (E.prototype.ireduce = function (e) {
              var t,
                r = e;
              do {
                this.split(r, this.tmp),
                  (t = (r = (r = this.imulK(r)).iadd(this.tmp)).bitLength());
              } while (t > this.n);
              var n = t < this.n ? -1 : r.ucmp(this.p);
              return (
                0 === n
                  ? ((r.words[0] = 0), (r.length = 1))
                  : n > 0
                  ? r.isub(this.p)
                  : void 0 !== r.strip
                  ? r.strip()
                  : r._strip(),
                r
              );
            }),
            (E.prototype.split = function (e, t) {
              e.iushrn(this.n, 0, t);
            }),
            (E.prototype.imulK = function (e) {
              return e.imul(this.k);
            }),
            i(A, E),
            (A.prototype.split = function (e, t) {
              for (
                var r = 4194303, n = Math.min(e.length, 9), i = 0;
                i < n;
                i++
              )
                t.words[i] = e.words[i];
              if (((t.length = n), e.length <= 9))
                return (e.words[0] = 0), void (e.length = 1);
              var s = e.words[9];
              for (t.words[t.length++] = s & r, i = 10; i < e.length; i++) {
                var o = 0 | e.words[i];
                (e.words[i - 10] = ((o & r) << 4) | (s >>> 22)), (s = o);
              }
              (s >>>= 22),
                (e.words[i - 10] = s),
                0 === s && e.length > 10 ? (e.length -= 10) : (e.length -= 9);
            }),
            (A.prototype.imulK = function (e) {
              (e.words[e.length] = 0),
                (e.words[e.length + 1] = 0),
                (e.length += 2);
              for (var t = 0, r = 0; r < e.length; r++) {
                var n = 0 | e.words[r];
                (t += 977 * n),
                  (e.words[r] = 67108863 & t),
                  (t = 64 * n + ((t / 67108864) | 0));
              }
              return (
                0 === e.words[e.length - 1] &&
                  (e.length--, 0 === e.words[e.length - 1] && e.length--),
                e
              );
            }),
            i(_, E),
            i(T, E),
            i(R, E),
            (R.prototype.imulK = function (e) {
              for (var t = 0, r = 0; r < e.length; r++) {
                var n = 19 * (0 | e.words[r]) + t,
                  i = 67108863 & n;
                (n >>>= 26), (e.words[r] = i), (t = n);
              }
              return 0 !== t && (e.words[e.length++] = t), e;
            }),
            (s._prime = function (e) {
              if (w[e]) return w[e];
              var t;
              if ("k256" === e) t = new A();
              else if ("p224" === e) t = new _();
              else if ("p192" === e) t = new T();
              else {
                if ("p25519" !== e) throw new Error("Unknown prime " + e);
                t = new R();
              }
              return (w[e] = t), t;
            }),
            (I.prototype._verify1 = function (e) {
              n(0 === e.negative, "red works only with positives"),
                n(e.red, "red works only with red numbers");
            }),
            (I.prototype._verify2 = function (e, t) {
              n(
                0 == (e.negative | t.negative),
                "red works only with positives",
              ),
                n(e.red && e.red === t.red, "red works only with red numbers");
            }),
            (I.prototype.imod = function (e) {
              return this.prime
                ? this.prime.ireduce(e)._forceRed(this)
                : (u(e, e.umod(this.m)._forceRed(this)), e);
            }),
            (I.prototype.neg = function (e) {
              return e.isZero() ? e.clone() : this.m.sub(e)._forceRed(this);
            }),
            (I.prototype.add = function (e, t) {
              this._verify2(e, t);
              var r = e.add(t);
              return r.cmp(this.m) >= 0 && r.isub(this.m), r._forceRed(this);
            }),
            (I.prototype.iadd = function (e, t) {
              this._verify2(e, t);
              var r = e.iadd(t);
              return r.cmp(this.m) >= 0 && r.isub(this.m), r;
            }),
            (I.prototype.sub = function (e, t) {
              this._verify2(e, t);
              var r = e.sub(t);
              return r.cmpn(0) < 0 && r.iadd(this.m), r._forceRed(this);
            }),
            (I.prototype.isub = function (e, t) {
              this._verify2(e, t);
              var r = e.isub(t);
              return r.cmpn(0) < 0 && r.iadd(this.m), r;
            }),
            (I.prototype.shl = function (e, t) {
              return this._verify1(e), this.imod(e.ushln(t));
            }),
            (I.prototype.imul = function (e, t) {
              return this._verify2(e, t), this.imod(e.imul(t));
            }),
            (I.prototype.mul = function (e, t) {
              return this._verify2(e, t), this.imod(e.mul(t));
            }),
            (I.prototype.isqr = function (e) {
              return this.imul(e, e.clone());
            }),
            (I.prototype.sqr = function (e) {
              return this.mul(e, e);
            }),
            (I.prototype.sqrt = function (e) {
              if (e.isZero()) return e.clone();
              var t = this.m.andln(3);
              if ((n(t % 2 == 1), 3 === t)) {
                var r = this.m.add(new s(1)).iushrn(2);
                return this.pow(e, r);
              }
              for (
                var i = this.m.subn(1), o = 0;
                !i.isZero() && 0 === i.andln(1);

              )
                o++, i.iushrn(1);
              n(!i.isZero());
              var a = new s(1).toRed(this),
                c = a.redNeg(),
                d = this.m.subn(1).iushrn(1),
                u = this.m.bitLength();
              for (
                u = new s(2 * u * u).toRed(this);
                0 !== this.pow(u, d).cmp(c);

              )
                u.redIAdd(c);
              for (
                var l = this.pow(u, i),
                  h = this.pow(e, i.addn(1).iushrn(1)),
                  f = this.pow(e, i),
                  p = o;
                0 !== f.cmp(a);

              ) {
                for (var m = f, y = 0; 0 !== m.cmp(a); y++) m = m.redSqr();
                n(y < p);
                var g = this.pow(l, new s(1).iushln(p - y - 1));
                (h = h.redMul(g)), (l = g.redSqr()), (f = f.redMul(l)), (p = y);
              }
              return h;
            }),
            (I.prototype.invm = function (e) {
              var t = e._invmp(this.m);
              return 0 !== t.negative
                ? ((t.negative = 0), this.imod(t).redNeg())
                : this.imod(t);
            }),
            (I.prototype.pow = function (e, t) {
              if (t.isZero()) return new s(1).toRed(this);
              if (0 === t.cmpn(1)) return e.clone();
              var r = new Array(16);
              (r[0] = new s(1).toRed(this)), (r[1] = e);
              for (var n = 2; n < r.length; n++) r[n] = this.mul(r[n - 1], e);
              var i = r[0],
                o = 0,
                a = 0,
                c = t.bitLength() % 26;
              for (0 === c && (c = 26), n = t.length - 1; n >= 0; n--) {
                for (var d = t.words[n], u = c - 1; u >= 0; u--) {
                  var l = (d >> u) & 1;
                  i !== r[0] && (i = this.sqr(i)),
                    0 !== l || 0 !== o
                      ? ((o <<= 1),
                        (o |= l),
                        (4 == ++a || (0 === n && 0 === u)) &&
                          ((i = this.mul(i, r[o])), (a = 0), (o = 0)))
                      : (a = 0);
                }
                c = 26;
              }
              return i;
            }),
            (I.prototype.convertTo = function (e) {
              var t = e.umod(this.m);
              return t === e ? t.clone() : t;
            }),
            (I.prototype.convertFrom = function (e) {
              var t = e.clone();
              return (t.red = null), t;
            }),
            (s.mont = function (e) {
              return new S(e);
            }),
            i(S, I),
            (S.prototype.convertTo = function (e) {
              return this.imod(e.ushln(this.shift));
            }),
            (S.prototype.convertFrom = function (e) {
              var t = this.imod(e.mul(this.rinv));
              return (t.red = null), t;
            }),
            (S.prototype.imul = function (e, t) {
              if (e.isZero() || t.isZero())
                return (e.words[0] = 0), (e.length = 1), e;
              var r = e.imul(t),
                n = r
                  .maskn(this.shift)
                  .mul(this.minv)
                  .imaskn(this.shift)
                  .mul(this.m),
                i = r.isub(n).iushrn(this.shift),
                s = i;
              return (
                i.cmp(this.m) >= 0
                  ? (s = i.isub(this.m))
                  : i.cmpn(0) < 0 && (s = i.iadd(this.m)),
                s._forceRed(this)
              );
            }),
            (S.prototype.mul = function (e, t) {
              if (e.isZero() || t.isZero()) return new s(0)._forceRed(this);
              var r = e.mul(t),
                n = r
                  .maskn(this.shift)
                  .mul(this.minv)
                  .imaskn(this.shift)
                  .mul(this.m),
                i = r.isub(n).iushrn(this.shift),
                o = i;
              return (
                i.cmp(this.m) >= 0
                  ? (o = i.isub(this.m))
                  : i.cmpn(0) < 0 && (o = i.iadd(this.m)),
                o._forceRed(this)
              );
            }),
            (S.prototype.invm = function (e) {
              return this.imod(e._invmp(this.m).mul(this.r2))._forceRed(this);
            });
        })((e = r.nmd(e)), this);
      },
      4606: (e, t) => {
        var r;
        (r = function (e) {
          e.version = "1.2.2";
          var t = (function () {
              for (var e = 0, t = new Array(256), r = 0; 256 != r; ++r)
                (e =
                  1 &
                  (e =
                    1 &
                    (e =
                      1 &
                      (e =
                        1 &
                        (e =
                          1 &
                          (e =
                            1 &
                            (e =
                              1 &
                              (e =
                                1 & (e = r) ? -306674912 ^ (e >>> 1) : e >>> 1)
                                ? -306674912 ^ (e >>> 1)
                                : e >>> 1)
                              ? -306674912 ^ (e >>> 1)
                              : e >>> 1)
                            ? -306674912 ^ (e >>> 1)
                            : e >>> 1)
                          ? -306674912 ^ (e >>> 1)
                          : e >>> 1)
                        ? -306674912 ^ (e >>> 1)
                        : e >>> 1)
                      ? -306674912 ^ (e >>> 1)
                      : e >>> 1)
                    ? -306674912 ^ (e >>> 1)
                    : e >>> 1),
                  (t[r] = e);
              return "undefined" != typeof Int32Array ? new Int32Array(t) : t;
            })(),
            r = (function (e) {
              var t = 0,
                r = 0,
                n = 0,
                i =
                  "undefined" != typeof Int32Array
                    ? new Int32Array(4096)
                    : new Array(4096);
              for (n = 0; 256 != n; ++n) i[n] = e[n];
              for (n = 0; 256 != n; ++n)
                for (r = e[n], t = 256 + n; t < 4096; t += 256)
                  r = i[t] = (r >>> 8) ^ e[255 & r];
              var s = [];
              for (n = 1; 16 != n; ++n)
                s[n - 1] =
                  "undefined" != typeof Int32Array
                    ? i.subarray(256 * n, 256 * n + 256)
                    : i.slice(256 * n, 256 * n + 256);
              return s;
            })(t),
            n = r[0],
            i = r[1],
            s = r[2],
            o = r[3],
            a = r[4],
            c = r[5],
            d = r[6],
            u = r[7],
            l = r[8],
            h = r[9],
            f = r[10],
            p = r[11],
            m = r[12],
            y = r[13],
            g = r[14];
          (e.table = t),
            (e.bstr = function (e, r) {
              for (var n = -1 ^ r, i = 0, s = e.length; i < s; )
                n = (n >>> 8) ^ t[255 & (n ^ e.charCodeAt(i++))];
              return ~n;
            }),
            (e.buf = function (e, r) {
              for (var v = -1 ^ r, b = e.length - 15, w = 0; w < b; )
                v =
                  g[e[w++] ^ (255 & v)] ^
                  y[e[w++] ^ ((v >> 8) & 255)] ^
                  m[e[w++] ^ ((v >> 16) & 255)] ^
                  p[e[w++] ^ (v >>> 24)] ^
                  f[e[w++]] ^
                  h[e[w++]] ^
                  l[e[w++]] ^
                  u[e[w++]] ^
                  d[e[w++]] ^
                  c[e[w++]] ^
                  a[e[w++]] ^
                  o[e[w++]] ^
                  s[e[w++]] ^
                  i[e[w++]] ^
                  n[e[w++]] ^
                  t[e[w++]];
              for (b += 15; w < b; ) v = (v >>> 8) ^ t[255 & (v ^ e[w++])];
              return ~v;
            }),
            (e.str = function (e, r) {
              for (var n = -1 ^ r, i = 0, s = e.length, o = 0, a = 0; i < s; )
                (o = e.charCodeAt(i++)) < 128
                  ? (n = (n >>> 8) ^ t[255 & (n ^ o)])
                  : o < 2048
                  ? (n =
                      ((n =
                        (n >>> 8) ^ t[255 & (n ^ (192 | ((o >> 6) & 31)))]) >>>
                        8) ^
                      t[255 & (n ^ (128 | (63 & o)))])
                  : o >= 55296 && o < 57344
                  ? ((o = 64 + (1023 & o)),
                    (a = 1023 & e.charCodeAt(i++)),
                    (n =
                      ((n =
                        ((n =
                          ((n =
                            (n >>> 8) ^
                            t[255 & (n ^ (240 | ((o >> 8) & 7)))]) >>>
                            8) ^
                          t[255 & (n ^ (128 | ((o >> 2) & 63)))]) >>>
                          8) ^
                        t[
                          255 & (n ^ (128 | ((a >> 6) & 15) | ((3 & o) << 4)))
                        ]) >>>
                        8) ^
                      t[255 & (n ^ (128 | (63 & a)))]))
                  : (n =
                      ((n =
                        ((n =
                          (n >>> 8) ^
                          t[255 & (n ^ (224 | ((o >> 12) & 15)))]) >>>
                          8) ^
                        t[255 & (n ^ (128 | ((o >> 6) & 63)))]) >>>
                        8) ^
                      t[255 & (n ^ (128 | (63 & o)))]);
              return ~n;
            });
        }),
          "undefined" == typeof DO_NOT_EXPORT_CRC ? r(t) : r({});
      },
      4098: function (e, t) {
        var r = "undefined" != typeof self ? self : this,
          n = (function () {
            function e() {
              (this.fetch = !1), (this.DOMException = r.DOMException);
            }
            return (e.prototype = r), new e();
          })();
        !(function (e) {
          !(function (t) {
            var r = "URLSearchParams" in e,
              n = "Symbol" in e && "iterator" in Symbol,
              i =
                "FileReader" in e &&
                "Blob" in e &&
                (function () {
                  try {
                    return new Blob(), !0;
                  } catch (e) {
                    return !1;
                  }
                })(),
              s = "FormData" in e,
              o = "ArrayBuffer" in e;
            if (o)
              var a = [
                  "[object Int8Array]",
                  "[object Uint8Array]",
                  "[object Uint8ClampedArray]",
                  "[object Int16Array]",
                  "[object Uint16Array]",
                  "[object Int32Array]",
                  "[object Uint32Array]",
                  "[object Float32Array]",
                  "[object Float64Array]",
                ],
                c =
                  ArrayBuffer.isView ||
                  function (e) {
                    return (
                      e && a.indexOf(Object.prototype.toString.call(e)) > -1
                    );
                  };
            function d(e) {
              if (
                ("string" != typeof e && (e = String(e)),
                /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(e))
              )
                throw new TypeError("Invalid character in header field name");
              return e.toLowerCase();
            }
            function u(e) {
              return "string" != typeof e && (e = String(e)), e;
            }
            function l(e) {
              var t = {
                next: function () {
                  var t = e.shift();
                  return { done: void 0 === t, value: t };
                },
              };
              return (
                n &&
                  (t[Symbol.iterator] = function () {
                    return t;
                  }),
                t
              );
            }
            function h(e) {
              (this.map = {}),
                e instanceof h
                  ? e.forEach(function (e, t) {
                      this.append(t, e);
                    }, this)
                  : Array.isArray(e)
                  ? e.forEach(function (e) {
                      this.append(e[0], e[1]);
                    }, this)
                  : e &&
                    Object.getOwnPropertyNames(e).forEach(function (t) {
                      this.append(t, e[t]);
                    }, this);
            }
            function f(e) {
              if (e.bodyUsed)
                return Promise.reject(new TypeError("Already read"));
              e.bodyUsed = !0;
            }
            function p(e) {
              return new Promise(function (t, r) {
                (e.onload = function () {
                  t(e.result);
                }),
                  (e.onerror = function () {
                    r(e.error);
                  });
              });
            }
            function m(e) {
              var t = new FileReader(),
                r = p(t);
              return t.readAsArrayBuffer(e), r;
            }
            function y(e) {
              if (e.slice) return e.slice(0);
              var t = new Uint8Array(e.byteLength);
              return t.set(new Uint8Array(e)), t.buffer;
            }
            function g() {
              return (
                (this.bodyUsed = !1),
                (this._initBody = function (e) {
                  var t;
                  (this._bodyInit = e),
                    e
                      ? "string" == typeof e
                        ? (this._bodyText = e)
                        : i && Blob.prototype.isPrototypeOf(e)
                        ? (this._bodyBlob = e)
                        : s && FormData.prototype.isPrototypeOf(e)
                        ? (this._bodyFormData = e)
                        : r && URLSearchParams.prototype.isPrototypeOf(e)
                        ? (this._bodyText = e.toString())
                        : o &&
                          i &&
                          (t = e) &&
                          DataView.prototype.isPrototypeOf(t)
                        ? ((this._bodyArrayBuffer = y(e.buffer)),
                          (this._bodyInit = new Blob([this._bodyArrayBuffer])))
                        : o && (ArrayBuffer.prototype.isPrototypeOf(e) || c(e))
                        ? (this._bodyArrayBuffer = y(e))
                        : (this._bodyText = e =
                            Object.prototype.toString.call(e))
                      : (this._bodyText = ""),
                    this.headers.get("content-type") ||
                      ("string" == typeof e
                        ? this.headers.set(
                            "content-type",
                            "text/plain;charset=UTF-8",
                          )
                        : this._bodyBlob && this._bodyBlob.type
                        ? this.headers.set("content-type", this._bodyBlob.type)
                        : r &&
                          URLSearchParams.prototype.isPrototypeOf(e) &&
                          this.headers.set(
                            "content-type",
                            "application/x-www-form-urlencoded;charset=UTF-8",
                          ));
                }),
                i &&
                  ((this.blob = function () {
                    var e = f(this);
                    if (e) return e;
                    if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
                    if (this._bodyArrayBuffer)
                      return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                    if (this._bodyFormData)
                      throw new Error("could not read FormData body as blob");
                    return Promise.resolve(new Blob([this._bodyText]));
                  }),
                  (this.arrayBuffer = function () {
                    return this._bodyArrayBuffer
                      ? f(this) || Promise.resolve(this._bodyArrayBuffer)
                      : this.blob().then(m);
                  })),
                (this.text = function () {
                  var e,
                    t,
                    r,
                    n = f(this);
                  if (n) return n;
                  if (this._bodyBlob)
                    return (
                      (e = this._bodyBlob),
                      (r = p((t = new FileReader()))),
                      t.readAsText(e),
                      r
                    );
                  if (this._bodyArrayBuffer)
                    return Promise.resolve(
                      (function (e) {
                        for (
                          var t = new Uint8Array(e),
                            r = new Array(t.length),
                            n = 0;
                          n < t.length;
                          n++
                        )
                          r[n] = String.fromCharCode(t[n]);
                        return r.join("");
                      })(this._bodyArrayBuffer),
                    );
                  if (this._bodyFormData)
                    throw new Error("could not read FormData body as text");
                  return Promise.resolve(this._bodyText);
                }),
                s &&
                  (this.formData = function () {
                    return this.text().then(w);
                  }),
                (this.json = function () {
                  return this.text().then(JSON.parse);
                }),
                this
              );
            }
            (h.prototype.append = function (e, t) {
              (e = d(e)), (t = u(t));
              var r = this.map[e];
              this.map[e] = r ? r + ", " + t : t;
            }),
              (h.prototype.delete = function (e) {
                delete this.map[d(e)];
              }),
              (h.prototype.get = function (e) {
                return (e = d(e)), this.has(e) ? this.map[e] : null;
              }),
              (h.prototype.has = function (e) {
                return this.map.hasOwnProperty(d(e));
              }),
              (h.prototype.set = function (e, t) {
                this.map[d(e)] = u(t);
              }),
              (h.prototype.forEach = function (e, t) {
                for (var r in this.map)
                  this.map.hasOwnProperty(r) && e.call(t, this.map[r], r, this);
              }),
              (h.prototype.keys = function () {
                var e = [];
                return (
                  this.forEach(function (t, r) {
                    e.push(r);
                  }),
                  l(e)
                );
              }),
              (h.prototype.values = function () {
                var e = [];
                return (
                  this.forEach(function (t) {
                    e.push(t);
                  }),
                  l(e)
                );
              }),
              (h.prototype.entries = function () {
                var e = [];
                return (
                  this.forEach(function (t, r) {
                    e.push([r, t]);
                  }),
                  l(e)
                );
              }),
              n && (h.prototype[Symbol.iterator] = h.prototype.entries);
            var v = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
            function b(e, t) {
              var r,
                n,
                i = (t = t || {}).body;
              if (e instanceof b) {
                if (e.bodyUsed) throw new TypeError("Already read");
                (this.url = e.url),
                  (this.credentials = e.credentials),
                  t.headers || (this.headers = new h(e.headers)),
                  (this.method = e.method),
                  (this.mode = e.mode),
                  (this.signal = e.signal),
                  i ||
                    null == e._bodyInit ||
                    ((i = e._bodyInit), (e.bodyUsed = !0));
              } else this.url = String(e);
              if (
                ((this.credentials =
                  t.credentials || this.credentials || "same-origin"),
                (!t.headers && this.headers) ||
                  (this.headers = new h(t.headers)),
                (this.method =
                  ((n = (r = t.method || this.method || "GET").toUpperCase()),
                  v.indexOf(n) > -1 ? n : r)),
                (this.mode = t.mode || this.mode || null),
                (this.signal = t.signal || this.signal),
                (this.referrer = null),
                ("GET" === this.method || "HEAD" === this.method) && i)
              )
                throw new TypeError(
                  "Body not allowed for GET or HEAD requests",
                );
              this._initBody(i);
            }
            function w(e) {
              var t = new FormData();
              return (
                e
                  .trim()
                  .split("&")
                  .forEach(function (e) {
                    if (e) {
                      var r = e.split("="),
                        n = r.shift().replace(/\+/g, " "),
                        i = r.join("=").replace(/\+/g, " ");
                      t.append(decodeURIComponent(n), decodeURIComponent(i));
                    }
                  }),
                t
              );
            }
            function E(e, t) {
              t || (t = {}),
                (this.type = "default"),
                (this.status = void 0 === t.status ? 200 : t.status),
                (this.ok = this.status >= 200 && this.status < 300),
                (this.statusText = "statusText" in t ? t.statusText : "OK"),
                (this.headers = new h(t.headers)),
                (this.url = t.url || ""),
                this._initBody(e);
            }
            (b.prototype.clone = function () {
              return new b(this, { body: this._bodyInit });
            }),
              g.call(b.prototype),
              g.call(E.prototype),
              (E.prototype.clone = function () {
                return new E(this._bodyInit, {
                  status: this.status,
                  statusText: this.statusText,
                  headers: new h(this.headers),
                  url: this.url,
                });
              }),
              (E.error = function () {
                var e = new E(null, { status: 0, statusText: "" });
                return (e.type = "error"), e;
              });
            var A = [301, 302, 303, 307, 308];
            (E.redirect = function (e, t) {
              if (-1 === A.indexOf(t))
                throw new RangeError("Invalid status code");
              return new E(null, { status: t, headers: { location: e } });
            }),
              (t.DOMException = e.DOMException);
            try {
              new t.DOMException();
            } catch (e) {
              (t.DOMException = function (e, t) {
                (this.message = e), (this.name = t);
                var r = Error(e);
                this.stack = r.stack;
              }),
                (t.DOMException.prototype = Object.create(Error.prototype)),
                (t.DOMException.prototype.constructor = t.DOMException);
            }
            function _(e, r) {
              return new Promise(function (n, s) {
                var o = new b(e, r);
                if (o.signal && o.signal.aborted)
                  return s(new t.DOMException("Aborted", "AbortError"));
                var a = new XMLHttpRequest();
                function c() {
                  a.abort();
                }
                (a.onload = function () {
                  var e,
                    t,
                    r = {
                      status: a.status,
                      statusText: a.statusText,
                      headers:
                        ((e = a.getAllResponseHeaders() || ""),
                        (t = new h()),
                        e
                          .replace(/\r?\n[\t ]+/g, " ")
                          .split(/\r?\n/)
                          .forEach(function (e) {
                            var r = e.split(":"),
                              n = r.shift().trim();
                            if (n) {
                              var i = r.join(":").trim();
                              t.append(n, i);
                            }
                          }),
                        t),
                    };
                  r.url =
                    "responseURL" in a
                      ? a.responseURL
                      : r.headers.get("X-Request-URL");
                  var i = "response" in a ? a.response : a.responseText;
                  n(new E(i, r));
                }),
                  (a.onerror = function () {
                    s(new TypeError("Network request failed"));
                  }),
                  (a.ontimeout = function () {
                    s(new TypeError("Network request failed"));
                  }),
                  (a.onabort = function () {
                    s(new t.DOMException("Aborted", "AbortError"));
                  }),
                  a.open(o.method, o.url, !0),
                  "include" === o.credentials
                    ? (a.withCredentials = !0)
                    : "omit" === o.credentials && (a.withCredentials = !1),
                  "responseType" in a && i && (a.responseType = "blob"),
                  o.headers.forEach(function (e, t) {
                    a.setRequestHeader(t, e);
                  }),
                  o.signal &&
                    (o.signal.addEventListener("abort", c),
                    (a.onreadystatechange = function () {
                      4 === a.readyState &&
                        o.signal.removeEventListener("abort", c);
                    })),
                  a.send(void 0 === o._bodyInit ? null : o._bodyInit);
              });
            }
            (_.polyfill = !0),
              e.fetch ||
                ((e.fetch = _),
                (e.Headers = h),
                (e.Request = b),
                (e.Response = E)),
              (t.Headers = h),
              (t.Request = b),
              (t.Response = E),
              (t.fetch = _),
              Object.defineProperty(t, "__esModule", { value: !0 });
          })({});
        })(n),
          (n.fetch.ponyfill = !0),
          delete n.fetch.polyfill;
        var i = n;
        ((t = i.fetch).default = i.fetch),
          (t.fetch = i.fetch),
          (t.Headers = i.Headers),
          (t.Request = i.Request),
          (t.Response = i.Response),
          (e.exports = t);
      },
      1465: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.decrypt = t.encrypt = void 0);
        const n = r(1945),
          i = r(8040),
          s = { web: n.crypto };
        function o(e, t, r) {
          if (!r.startsWith("aes-"))
            throw new Error(`AES submodule doesn't support mode ${r}`);
          if (16 !== t.length) throw new Error("AES: wrong IV length");
          if (
            (r.startsWith("aes-128") && 16 !== e.length) ||
            (r.startsWith("aes-256") && 32 !== e.length)
          )
            throw new Error("AES: wrong key length");
        }
        async function a(e, t, r) {
          if (!s.web) throw new Error("Browser crypto not available.");
          let n;
          if (
            (["aes-128-cbc", "aes-256-cbc"].includes(e) && (n = "cbc"),
            ["aes-128-ctr", "aes-256-ctr"].includes(e) && (n = "ctr"),
            !n)
          )
            throw new Error("AES: unsupported mode");
          return [
            await s.web.subtle.importKey(
              "raw",
              t,
              { name: `AES-${n.toUpperCase()}`, length: 8 * t.length },
              !0,
              ["encrypt", "decrypt"],
            ),
            { name: `aes-${n}`, iv: r, counter: r, length: 128 },
          ];
        }
        async function c(e, t, r, n = "aes-128-ctr", c = !0) {
          if ((o(t, r, n), s.web)) {
            const [i, o] = await a(n, t, r),
              d = await s.web.subtle.encrypt(o, i, e);
            let u = new Uint8Array(d);
            return (
              c ||
                "aes-cbc" !== o.name ||
                e.length % 16 ||
                (u = u.slice(0, -16)),
              u
            );
          }
          if (s.node) {
            const o = s.node.createCipheriv(n, t, r);
            return (
              o.setAutoPadding(c), (0, i.concatBytes)(o.update(e), o.final())
            );
          }
          throw new Error("The environment doesn't have AES module");
        }
        (t.encrypt = c),
          (t.decrypt = async function (e, t, r, n = "aes-128-ctr", d = !0) {
            if ((o(t, r, n), s.web)) {
              const [o, u] = await a(n, t, r);
              if (!d && "aes-cbc" === u.name) {
                const s = await (async function (e, t, r, n) {
                  const i = e.slice(-16);
                  for (let e = 0; e < 16; e++) i[e] ^= 16 ^ r[e];
                  return (await c(i, t, r, n)).slice(0, 16);
                })(e, t, r, n);
                e = (0, i.concatBytes)(e, s);
              }
              const l = await s.web.subtle.decrypt(u, o, e),
                h = new Uint8Array(l);
              if ("aes-cbc" === u.name) {
                const s = await c(h, t, r, n);
                if (!(0, i.equalsBytes)(s, e))
                  throw new Error("AES: wrong padding");
              }
              return h;
            }
            if (s.node) {
              const o = s.node.createDecipheriv(n, t, r);
              return (
                o.setAutoPadding(d), (0, i.concatBytes)(o.update(e), o.final())
              );
            }
            throw new Error("The environment doesn't have AES module");
          });
      },
      2192: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.keccak512 = t.keccak384 = t.keccak256 = t.keccak224 = void 0);
        const n = r(5426),
          i = r(8040);
        (t.keccak224 = (0, i.wrapHash)(n.keccak_224)),
          (t.keccak256 = (() => {
            const e = (0, i.wrapHash)(n.keccak_256);
            return (e.create = n.keccak_256.create), e;
          })()),
          (t.keccak384 = (0, i.wrapHash)(n.keccak_384)),
          (t.keccak512 = (0, i.wrapHash)(n.keccak_512));
      },
      8791: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.pbkdf2Sync = t.pbkdf2 = void 0);
        const n = r(9023),
          i = r(3061),
          s = r(6262),
          o = r(8040);
        (t.pbkdf2 = async function (e, t, r, a, c) {
          if (!["sha256", "sha512"].includes(c))
            throw new Error("Only sha256 and sha512 are supported");
          return (
            (0, o.assertBytes)(e),
            (0, o.assertBytes)(t),
            (0, n.pbkdf2Async)("sha256" === c ? i.sha256 : s.sha512, e, t, {
              c: r,
              dkLen: a,
            })
          );
        }),
          (t.pbkdf2Sync = function (e, t, r, a, c) {
            if (!["sha256", "sha512"].includes(c))
              throw new Error("Only sha256 and sha512 are supported");
            return (
              (0, o.assertBytes)(e),
              (0, o.assertBytes)(t),
              (0, n.pbkdf2)("sha256" === c ? i.sha256 : s.sha512, e, t, {
                c: r,
                dkLen: a,
              })
            );
          });
      },
      472: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getRandomBytes = t.getRandomBytesSync = void 0);
        const n = r(8089);
        (t.getRandomBytesSync = function (e) {
          return (0, n.randomBytes)(e);
        }),
          (t.getRandomBytes = async function (e) {
            return (0, n.randomBytes)(e);
          });
      },
      2535: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.scryptSync = t.scrypt = void 0);
        const n = r(9514),
          i = r(8040);
        (t.scrypt = async function (e, t, r, s, o, a, c) {
          return (
            (0, i.assertBytes)(e),
            (0, i.assertBytes)(t),
            (0, n.scryptAsync)(e, t, {
              N: r,
              r: o,
              p: s,
              dkLen: a,
              onProgress: c,
            })
          );
        }),
          (t.scryptSync = function (e, t, r, s, o, a, c) {
            return (
              (0, i.assertBytes)(e),
              (0, i.assertBytes)(t),
              (0, n.scrypt)(e, t, { N: r, r: o, p: s, dkLen: a, onProgress: c })
            );
          });
      },
      5053: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.secp256k1 = void 0);
        var n = r(3497);
        Object.defineProperty(t, "secp256k1", {
          enumerable: !0,
          get: function () {
            return n.secp256k1;
          },
        });
      },
      8040: function (e, t, r) {
        "use strict";
        e = r.nmd(e);
        var n =
          (this && this.__importDefault) ||
          function (e) {
            return e && e.__esModule ? e : { default: e };
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.crypto =
            t.wrapHash =
            t.equalsBytes =
            t.hexToBytes =
            t.bytesToUtf8 =
            t.utf8ToBytes =
            t.createView =
            t.concatBytes =
            t.toHex =
            t.bytesToHex =
            t.assertBytes =
            t.assertBool =
              void 0);
        const i = n(r(7320)),
          s = r(8089),
          o = i.default.bool;
        t.assertBool = o;
        const a = i.default.bytes;
        t.assertBytes = a;
        var c = r(8089);
        Object.defineProperty(t, "bytesToHex", {
          enumerable: !0,
          get: function () {
            return c.bytesToHex;
          },
        }),
          Object.defineProperty(t, "toHex", {
            enumerable: !0,
            get: function () {
              return c.bytesToHex;
            },
          }),
          Object.defineProperty(t, "concatBytes", {
            enumerable: !0,
            get: function () {
              return c.concatBytes;
            },
          }),
          Object.defineProperty(t, "createView", {
            enumerable: !0,
            get: function () {
              return c.createView;
            },
          }),
          Object.defineProperty(t, "utf8ToBytes", {
            enumerable: !0,
            get: function () {
              return c.utf8ToBytes;
            },
          }),
          (t.bytesToUtf8 = function (e) {
            if (!(e instanceof Uint8Array))
              throw new TypeError(
                "bytesToUtf8 expected Uint8Array, got " + typeof e,
              );
            return new TextDecoder().decode(e);
          }),
          (t.hexToBytes = function (e) {
            const t = e.startsWith("0x") ? e.substring(2) : e;
            return (0, s.hexToBytes)(t);
          }),
          (t.equalsBytes = function (e, t) {
            if (e.length !== t.length) return !1;
            for (let r = 0; r < e.length; r++) if (e[r] !== t[r]) return !1;
            return !0;
          }),
          (t.wrapHash = function (e) {
            return (t) => (i.default.bytes(t), e(t));
          }),
          (t.crypto = (() => {
            const t =
                "object" == typeof globalThis && "crypto" in globalThis
                  ? globalThis.crypto
                  : void 0,
              r = "function" == typeof e.require && e.require.bind(e);
            return { node: r && !t ? r("crypto") : void 0, web: t };
          })());
      },
      7187: (e) => {
        "use strict";
        var t,
          r = "object" == typeof Reflect ? Reflect : null,
          n =
            r && "function" == typeof r.apply
              ? r.apply
              : function (e, t, r) {
                  return Function.prototype.apply.call(e, t, r);
                };
        t =
          r && "function" == typeof r.ownKeys
            ? r.ownKeys
            : Object.getOwnPropertySymbols
            ? function (e) {
                return Object.getOwnPropertyNames(e).concat(
                  Object.getOwnPropertySymbols(e),
                );
              }
            : function (e) {
                return Object.getOwnPropertyNames(e);
              };
        var i =
          Number.isNaN ||
          function (e) {
            return e != e;
          };
        function s() {
          s.init.call(this);
        }
        (e.exports = s),
          (e.exports.once = function (e, t) {
            return new Promise(function (r, n) {
              function i(r) {
                e.removeListener(t, s), n(r);
              }
              function s() {
                "function" == typeof e.removeListener &&
                  e.removeListener("error", i),
                  r([].slice.call(arguments));
              }
              m(e, t, s, { once: !0 }),
                "error" !== t &&
                  (function (e, t, r) {
                    "function" == typeof e.on && m(e, "error", t, { once: !0 });
                  })(e, i);
            });
          }),
          (s.EventEmitter = s),
          (s.prototype._events = void 0),
          (s.prototype._eventsCount = 0),
          (s.prototype._maxListeners = void 0);
        var o = 10;
        function a(e) {
          if ("function" != typeof e)
            throw new TypeError(
              'The "listener" argument must be of type Function. Received type ' +
                typeof e,
            );
        }
        function c(e) {
          return void 0 === e._maxListeners
            ? s.defaultMaxListeners
            : e._maxListeners;
        }
        function d(e, t, r, n) {
          var i, s, o, d;
          if (
            (a(r),
            void 0 === (s = e._events)
              ? ((s = e._events = Object.create(null)), (e._eventsCount = 0))
              : (void 0 !== s.newListener &&
                  (e.emit("newListener", t, r.listener ? r.listener : r),
                  (s = e._events)),
                (o = s[t])),
            void 0 === o)
          )
            (o = s[t] = r), ++e._eventsCount;
          else if (
            ("function" == typeof o
              ? (o = s[t] = n ? [r, o] : [o, r])
              : n
              ? o.unshift(r)
              : o.push(r),
            (i = c(e)) > 0 && o.length > i && !o.warned)
          ) {
            o.warned = !0;
            var u = new Error(
              "Possible EventEmitter memory leak detected. " +
                o.length +
                " " +
                String(t) +
                " listeners added. Use emitter.setMaxListeners() to increase limit",
            );
            (u.name = "MaxListenersExceededWarning"),
              (u.emitter = e),
              (u.type = t),
              (u.count = o.length),
              (d = u),
              console && console.warn && console.warn(d);
          }
          return e;
        }
        function u() {
          if (!this.fired)
            return (
              this.target.removeListener(this.type, this.wrapFn),
              (this.fired = !0),
              0 === arguments.length
                ? this.listener.call(this.target)
                : this.listener.apply(this.target, arguments)
            );
        }
        function l(e, t, r) {
          var n = {
              fired: !1,
              wrapFn: void 0,
              target: e,
              type: t,
              listener: r,
            },
            i = u.bind(n);
          return (i.listener = r), (n.wrapFn = i), i;
        }
        function h(e, t, r) {
          var n = e._events;
          if (void 0 === n) return [];
          var i = n[t];
          return void 0 === i
            ? []
            : "function" == typeof i
            ? r
              ? [i.listener || i]
              : [i]
            : r
            ? (function (e) {
                for (var t = new Array(e.length), r = 0; r < t.length; ++r)
                  t[r] = e[r].listener || e[r];
                return t;
              })(i)
            : p(i, i.length);
        }
        function f(e) {
          var t = this._events;
          if (void 0 !== t) {
            var r = t[e];
            if ("function" == typeof r) return 1;
            if (void 0 !== r) return r.length;
          }
          return 0;
        }
        function p(e, t) {
          for (var r = new Array(t), n = 0; n < t; ++n) r[n] = e[n];
          return r;
        }
        function m(e, t, r, n) {
          if ("function" == typeof e.on) n.once ? e.once(t, r) : e.on(t, r);
          else {
            if ("function" != typeof e.addEventListener)
              throw new TypeError(
                'The "emitter" argument must be of type EventEmitter. Received type ' +
                  typeof e,
              );
            e.addEventListener(t, function i(s) {
              n.once && e.removeEventListener(t, i), r(s);
            });
          }
        }
        Object.defineProperty(s, "defaultMaxListeners", {
          enumerable: !0,
          get: function () {
            return o;
          },
          set: function (e) {
            if ("number" != typeof e || e < 0 || i(e))
              throw new RangeError(
                'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
                  e +
                  ".",
              );
            o = e;
          },
        }),
          (s.init = function () {
            (void 0 !== this._events &&
              this._events !== Object.getPrototypeOf(this)._events) ||
              ((this._events = Object.create(null)), (this._eventsCount = 0)),
              (this._maxListeners = this._maxListeners || void 0);
          }),
          (s.prototype.setMaxListeners = function (e) {
            if ("number" != typeof e || e < 0 || i(e))
              throw new RangeError(
                'The value of "n" is out of range. It must be a non-negative number. Received ' +
                  e +
                  ".",
              );
            return (this._maxListeners = e), this;
          }),
          (s.prototype.getMaxListeners = function () {
            return c(this);
          }),
          (s.prototype.emit = function (e) {
            for (var t = [], r = 1; r < arguments.length; r++)
              t.push(arguments[r]);
            var i = "error" === e,
              s = this._events;
            if (void 0 !== s) i = i && void 0 === s.error;
            else if (!i) return !1;
            if (i) {
              var o;
              if ((t.length > 0 && (o = t[0]), o instanceof Error)) throw o;
              var a = new Error(
                "Unhandled error." + (o ? " (" + o.message + ")" : ""),
              );
              throw ((a.context = o), a);
            }
            var c = s[e];
            if (void 0 === c) return !1;
            if ("function" == typeof c) n(c, this, t);
            else {
              var d = c.length,
                u = p(c, d);
              for (r = 0; r < d; ++r) n(u[r], this, t);
            }
            return !0;
          }),
          (s.prototype.addListener = function (e, t) {
            return d(this, e, t, !1);
          }),
          (s.prototype.on = s.prototype.addListener),
          (s.prototype.prependListener = function (e, t) {
            return d(this, e, t, !0);
          }),
          (s.prototype.once = function (e, t) {
            return a(t), this.on(e, l(this, e, t)), this;
          }),
          (s.prototype.prependOnceListener = function (e, t) {
            return a(t), this.prependListener(e, l(this, e, t)), this;
          }),
          (s.prototype.removeListener = function (e, t) {
            var r, n, i, s, o;
            if ((a(t), void 0 === (n = this._events))) return this;
            if (void 0 === (r = n[e])) return this;
            if (r === t || r.listener === t)
              0 == --this._eventsCount
                ? (this._events = Object.create(null))
                : (delete n[e],
                  n.removeListener &&
                    this.emit("removeListener", e, r.listener || t));
            else if ("function" != typeof r) {
              for (i = -1, s = r.length - 1; s >= 0; s--)
                if (r[s] === t || r[s].listener === t) {
                  (o = r[s].listener), (i = s);
                  break;
                }
              if (i < 0) return this;
              0 === i
                ? r.shift()
                : (function (e, t) {
                    for (; t + 1 < e.length; t++) e[t] = e[t + 1];
                    e.pop();
                  })(r, i),
                1 === r.length && (n[e] = r[0]),
                void 0 !== n.removeListener &&
                  this.emit("removeListener", e, o || t);
            }
            return this;
          }),
          (s.prototype.off = s.prototype.removeListener),
          (s.prototype.removeAllListeners = function (e) {
            var t, r, n;
            if (void 0 === (r = this._events)) return this;
            if (void 0 === r.removeListener)
              return (
                0 === arguments.length
                  ? ((this._events = Object.create(null)),
                    (this._eventsCount = 0))
                  : void 0 !== r[e] &&
                    (0 == --this._eventsCount
                      ? (this._events = Object.create(null))
                      : delete r[e]),
                this
              );
            if (0 === arguments.length) {
              var i,
                s = Object.keys(r);
              for (n = 0; n < s.length; ++n)
                "removeListener" !== (i = s[n]) && this.removeAllListeners(i);
              return (
                this.removeAllListeners("removeListener"),
                (this._events = Object.create(null)),
                (this._eventsCount = 0),
                this
              );
            }
            if ("function" == typeof (t = r[e])) this.removeListener(e, t);
            else if (void 0 !== t)
              for (n = t.length - 1; n >= 0; n--) this.removeListener(e, t[n]);
            return this;
          }),
          (s.prototype.listeners = function (e) {
            return h(this, e, !0);
          }),
          (s.prototype.rawListeners = function (e) {
            return h(this, e, !1);
          }),
          (s.listenerCount = function (e, t) {
            return "function" == typeof e.listenerCount
              ? e.listenerCount(t)
              : f.call(e, t);
          }),
          (s.prototype.listenerCount = f),
          (s.prototype.eventNames = function () {
            return this._eventsCount > 0 ? t(this._events) : [];
          });
      },
      1094: (e, t, r) => {
        var n;
        !(function () {
          "use strict";
          var i = "input is invalid type",
            s = "object" == typeof window,
            o = s ? window : {};
          o.JS_SHA3_NO_WINDOW && (s = !1);
          var a = !s && "object" == typeof self;
          !o.JS_SHA3_NO_NODE_JS &&
          "object" == typeof process &&
          process.versions &&
          process.versions.node
            ? (o = r.g)
            : a && (o = self);
          var c = !o.JS_SHA3_NO_COMMON_JS && e.exports,
            d = r.amdO,
            u = !o.JS_SHA3_NO_ARRAY_BUFFER && "undefined" != typeof ArrayBuffer,
            l = "0123456789abcdef".split(""),
            h = [4, 1024, 262144, 67108864],
            f = [0, 8, 16, 24],
            p = [
              1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907,
              0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138,
              0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139,
              2147483648, 32905, 2147483648, 32771, 2147483648, 32770,
              2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648,
              2147516545, 2147483648, 32896, 2147483648, 2147483649, 0,
              2147516424, 2147483648,
            ],
            m = [224, 256, 384, 512],
            y = [128, 256],
            g = ["hex", "buffer", "arrayBuffer", "array", "digest"],
            v = { 128: 168, 256: 136 };
          (!o.JS_SHA3_NO_NODE_JS && Array.isArray) ||
            (Array.isArray = function (e) {
              return "[object Array]" === Object.prototype.toString.call(e);
            }),
            !u ||
              (!o.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW && ArrayBuffer.isView) ||
              (ArrayBuffer.isView = function (e) {
                return (
                  "object" == typeof e &&
                  e.buffer &&
                  e.buffer.constructor === ArrayBuffer
                );
              });
          for (
            var b = function (e, t, r) {
                return function (n) {
                  return new N(e, t, e).update(n)[r]();
                };
              },
              w = function (e, t, r) {
                return function (n, i) {
                  return new N(e, t, i).update(n)[r]();
                };
              },
              E = function (e, t, r) {
                return function (t, n, i, s) {
                  return I["cshake" + e].update(t, n, i, s)[r]();
                };
              },
              A = function (e, t, r) {
                return function (t, n, i, s) {
                  return I["kmac" + e].update(t, n, i, s)[r]();
                };
              },
              _ = function (e, t, r, n) {
                for (var i = 0; i < g.length; ++i) {
                  var s = g[i];
                  e[s] = t(r, n, s);
                }
                return e;
              },
              T = function (e, t) {
                var r = b(e, t, "hex");
                return (
                  (r.create = function () {
                    return new N(e, t, e);
                  }),
                  (r.update = function (e) {
                    return r.create().update(e);
                  }),
                  _(r, b, e, t)
                );
              },
              R = [
                {
                  name: "keccak",
                  padding: [1, 256, 65536, 16777216],
                  bits: m,
                  createMethod: T,
                },
                {
                  name: "sha3",
                  padding: [6, 1536, 393216, 100663296],
                  bits: m,
                  createMethod: T,
                },
                {
                  name: "shake",
                  padding: [31, 7936, 2031616, 520093696],
                  bits: y,
                  createMethod: function (e, t) {
                    var r = w(e, t, "hex");
                    return (
                      (r.create = function (r) {
                        return new N(e, t, r);
                      }),
                      (r.update = function (e, t) {
                        return r.create(t).update(e);
                      }),
                      _(r, w, e, t)
                    );
                  },
                },
                {
                  name: "cshake",
                  padding: h,
                  bits: y,
                  createMethod: function (e, t) {
                    var r = v[e],
                      n = E(e, 0, "hex");
                    return (
                      (n.create = function (n, i, s) {
                        return i || s
                          ? new N(e, t, n).bytepad([i, s], r)
                          : I["shake" + e].create(n);
                      }),
                      (n.update = function (e, t, r, i) {
                        return n.create(t, r, i).update(e);
                      }),
                      _(n, E, e, t)
                    );
                  },
                },
                {
                  name: "kmac",
                  padding: h,
                  bits: y,
                  createMethod: function (e, t) {
                    var r = v[e],
                      n = A(e, 0, "hex");
                    return (
                      (n.create = function (n, i, s) {
                        return new B(e, t, i)
                          .bytepad(["KMAC", s], r)
                          .bytepad([n], r);
                      }),
                      (n.update = function (e, t, r, i) {
                        return n.create(e, r, i).update(t);
                      }),
                      _(n, A, e, t)
                    );
                  },
                },
              ],
              I = {},
              S = [],
              x = 0;
            x < R.length;
            ++x
          )
            for (var P = R[x], O = P.bits, C = 0; C < O.length; ++C) {
              var k = P.name + "_" + O[C];
              if (
                (S.push(k),
                (I[k] = P.createMethod(O[C], P.padding)),
                "sha3" !== P.name)
              ) {
                var M = P.name + O[C];
                S.push(M), (I[M] = I[k]);
              }
            }
          function N(e, t, r) {
            (this.blocks = []),
              (this.s = []),
              (this.padding = t),
              (this.outputBits = r),
              (this.reset = !0),
              (this.finalized = !1),
              (this.block = 0),
              (this.start = 0),
              (this.blockCount = (1600 - (e << 1)) >> 5),
              (this.byteCount = this.blockCount << 2),
              (this.outputBlocks = r >> 5),
              (this.extraBytes = (31 & r) >> 3);
            for (var n = 0; n < 50; ++n) this.s[n] = 0;
          }
          function B(e, t, r) {
            N.call(this, e, t, r);
          }
          (N.prototype.update = function (e) {
            if (this.finalized) throw new Error("finalize already called");
            var t,
              r = typeof e;
            if ("string" !== r) {
              if ("object" !== r) throw new Error(i);
              if (null === e) throw new Error(i);
              if (u && e.constructor === ArrayBuffer) e = new Uint8Array(e);
              else if (!(Array.isArray(e) || (u && ArrayBuffer.isView(e))))
                throw new Error(i);
              t = !0;
            }
            for (
              var n,
                s,
                o = this.blocks,
                a = this.byteCount,
                c = e.length,
                d = this.blockCount,
                l = 0,
                h = this.s;
              l < c;

            ) {
              if (this.reset)
                for (this.reset = !1, o[0] = this.block, n = 1; n < d + 1; ++n)
                  o[n] = 0;
              if (t)
                for (n = this.start; l < c && n < a; ++l)
                  o[n >> 2] |= e[l] << f[3 & n++];
              else
                for (n = this.start; l < c && n < a; ++l)
                  (s = e.charCodeAt(l)) < 128
                    ? (o[n >> 2] |= s << f[3 & n++])
                    : s < 2048
                    ? ((o[n >> 2] |= (192 | (s >> 6)) << f[3 & n++]),
                      (o[n >> 2] |= (128 | (63 & s)) << f[3 & n++]))
                    : s < 55296 || s >= 57344
                    ? ((o[n >> 2] |= (224 | (s >> 12)) << f[3 & n++]),
                      (o[n >> 2] |= (128 | ((s >> 6) & 63)) << f[3 & n++]),
                      (o[n >> 2] |= (128 | (63 & s)) << f[3 & n++]))
                    : ((s =
                        65536 +
                        (((1023 & s) << 10) | (1023 & e.charCodeAt(++l)))),
                      (o[n >> 2] |= (240 | (s >> 18)) << f[3 & n++]),
                      (o[n >> 2] |= (128 | ((s >> 12) & 63)) << f[3 & n++]),
                      (o[n >> 2] |= (128 | ((s >> 6) & 63)) << f[3 & n++]),
                      (o[n >> 2] |= (128 | (63 & s)) << f[3 & n++]));
              if (((this.lastByteIndex = n), n >= a)) {
                for (this.start = n - a, this.block = o[d], n = 0; n < d; ++n)
                  h[n] ^= o[n];
                D(h), (this.reset = !0);
              } else this.start = n;
            }
            return this;
          }),
            (N.prototype.encode = function (e, t) {
              var r = 255 & e,
                n = 1,
                i = [r];
              for (r = 255 & (e >>= 8); r > 0; )
                i.unshift(r), (r = 255 & (e >>= 8)), ++n;
              return t ? i.push(n) : i.unshift(n), this.update(i), i.length;
            }),
            (N.prototype.encodeString = function (e) {
              var t,
                r = typeof e;
              if ("string" !== r) {
                if ("object" !== r) throw new Error(i);
                if (null === e) throw new Error(i);
                if (u && e.constructor === ArrayBuffer) e = new Uint8Array(e);
                else if (!(Array.isArray(e) || (u && ArrayBuffer.isView(e))))
                  throw new Error(i);
                t = !0;
              }
              var n = 0,
                s = e.length;
              if (t) n = s;
              else
                for (var o = 0; o < e.length; ++o) {
                  var a = e.charCodeAt(o);
                  a < 128
                    ? (n += 1)
                    : a < 2048
                    ? (n += 2)
                    : a < 55296 || a >= 57344
                    ? (n += 3)
                    : ((a =
                        65536 +
                        (((1023 & a) << 10) | (1023 & e.charCodeAt(++o)))),
                      (n += 4));
                }
              return (n += this.encode(8 * n)), this.update(e), n;
            }),
            (N.prototype.bytepad = function (e, t) {
              for (var r = this.encode(t), n = 0; n < e.length; ++n)
                r += this.encodeString(e[n]);
              var i = t - (r % t),
                s = [];
              return (s.length = i), this.update(s), this;
            }),
            (N.prototype.finalize = function () {
              if (!this.finalized) {
                this.finalized = !0;
                var e = this.blocks,
                  t = this.lastByteIndex,
                  r = this.blockCount,
                  n = this.s;
                if (
                  ((e[t >> 2] |= this.padding[3 & t]),
                  this.lastByteIndex === this.byteCount)
                )
                  for (e[0] = e[r], t = 1; t < r + 1; ++t) e[t] = 0;
                for (e[r - 1] |= 2147483648, t = 0; t < r; ++t) n[t] ^= e[t];
                D(n);
              }
            }),
            (N.prototype.toString = N.prototype.hex =
              function () {
                this.finalize();
                for (
                  var e,
                    t = this.blockCount,
                    r = this.s,
                    n = this.outputBlocks,
                    i = this.extraBytes,
                    s = 0,
                    o = 0,
                    a = "";
                  o < n;

                ) {
                  for (s = 0; s < t && o < n; ++s, ++o)
                    (e = r[s]),
                      (a +=
                        l[(e >> 4) & 15] +
                        l[15 & e] +
                        l[(e >> 12) & 15] +
                        l[(e >> 8) & 15] +
                        l[(e >> 20) & 15] +
                        l[(e >> 16) & 15] +
                        l[(e >> 28) & 15] +
                        l[(e >> 24) & 15]);
                  o % t == 0 && (D(r), (s = 0));
                }
                return (
                  i &&
                    ((e = r[s]),
                    (a += l[(e >> 4) & 15] + l[15 & e]),
                    i > 1 && (a += l[(e >> 12) & 15] + l[(e >> 8) & 15]),
                    i > 2 && (a += l[(e >> 20) & 15] + l[(e >> 16) & 15])),
                  a
                );
              }),
            (N.prototype.arrayBuffer = function () {
              this.finalize();
              var e,
                t = this.blockCount,
                r = this.s,
                n = this.outputBlocks,
                i = this.extraBytes,
                s = 0,
                o = 0,
                a = this.outputBits >> 3;
              e = i ? new ArrayBuffer((n + 1) << 2) : new ArrayBuffer(a);
              for (var c = new Uint32Array(e); o < n; ) {
                for (s = 0; s < t && o < n; ++s, ++o) c[o] = r[s];
                o % t == 0 && D(r);
              }
              return i && ((c[s] = r[s]), (e = e.slice(0, a))), e;
            }),
            (N.prototype.buffer = N.prototype.arrayBuffer),
            (N.prototype.digest = N.prototype.array =
              function () {
                this.finalize();
                for (
                  var e,
                    t,
                    r = this.blockCount,
                    n = this.s,
                    i = this.outputBlocks,
                    s = this.extraBytes,
                    o = 0,
                    a = 0,
                    c = [];
                  a < i;

                ) {
                  for (o = 0; o < r && a < i; ++o, ++a)
                    (e = a << 2),
                      (t = n[o]),
                      (c[e] = 255 & t),
                      (c[e + 1] = (t >> 8) & 255),
                      (c[e + 2] = (t >> 16) & 255),
                      (c[e + 3] = (t >> 24) & 255);
                  a % r == 0 && D(n);
                }
                return (
                  s &&
                    ((e = a << 2),
                    (t = n[o]),
                    (c[e] = 255 & t),
                    s > 1 && (c[e + 1] = (t >> 8) & 255),
                    s > 2 && (c[e + 2] = (t >> 16) & 255)),
                  c
                );
              }),
            (B.prototype = new N()),
            (B.prototype.finalize = function () {
              return (
                this.encode(this.outputBits, !0),
                N.prototype.finalize.call(this)
              );
            });
          var D = function (e) {
            var t,
              r,
              n,
              i,
              s,
              o,
              a,
              c,
              d,
              u,
              l,
              h,
              f,
              m,
              y,
              g,
              v,
              b,
              w,
              E,
              A,
              _,
              T,
              R,
              I,
              S,
              x,
              P,
              O,
              C,
              k,
              M,
              N,
              B,
              D,
              j,
              L,
              U,
              F,
              H,
              G,
              V,
              W,
              q,
              Z,
              z,
              K,
              J,
              X,
              Q,
              $,
              Y,
              ee,
              te,
              re,
              ne,
              ie,
              se,
              oe,
              ae,
              ce,
              de,
              ue;
            for (n = 0; n < 48; n += 2)
              (i = e[0] ^ e[10] ^ e[20] ^ e[30] ^ e[40]),
                (s = e[1] ^ e[11] ^ e[21] ^ e[31] ^ e[41]),
                (o = e[2] ^ e[12] ^ e[22] ^ e[32] ^ e[42]),
                (a = e[3] ^ e[13] ^ e[23] ^ e[33] ^ e[43]),
                (c = e[4] ^ e[14] ^ e[24] ^ e[34] ^ e[44]),
                (d = e[5] ^ e[15] ^ e[25] ^ e[35] ^ e[45]),
                (u = e[6] ^ e[16] ^ e[26] ^ e[36] ^ e[46]),
                (l = e[7] ^ e[17] ^ e[27] ^ e[37] ^ e[47]),
                (t =
                  (h = e[8] ^ e[18] ^ e[28] ^ e[38] ^ e[48]) ^
                  ((o << 1) | (a >>> 31))),
                (r =
                  (f = e[9] ^ e[19] ^ e[29] ^ e[39] ^ e[49]) ^
                  ((a << 1) | (o >>> 31))),
                (e[0] ^= t),
                (e[1] ^= r),
                (e[10] ^= t),
                (e[11] ^= r),
                (e[20] ^= t),
                (e[21] ^= r),
                (e[30] ^= t),
                (e[31] ^= r),
                (e[40] ^= t),
                (e[41] ^= r),
                (t = i ^ ((c << 1) | (d >>> 31))),
                (r = s ^ ((d << 1) | (c >>> 31))),
                (e[2] ^= t),
                (e[3] ^= r),
                (e[12] ^= t),
                (e[13] ^= r),
                (e[22] ^= t),
                (e[23] ^= r),
                (e[32] ^= t),
                (e[33] ^= r),
                (e[42] ^= t),
                (e[43] ^= r),
                (t = o ^ ((u << 1) | (l >>> 31))),
                (r = a ^ ((l << 1) | (u >>> 31))),
                (e[4] ^= t),
                (e[5] ^= r),
                (e[14] ^= t),
                (e[15] ^= r),
                (e[24] ^= t),
                (e[25] ^= r),
                (e[34] ^= t),
                (e[35] ^= r),
                (e[44] ^= t),
                (e[45] ^= r),
                (t = c ^ ((h << 1) | (f >>> 31))),
                (r = d ^ ((f << 1) | (h >>> 31))),
                (e[6] ^= t),
                (e[7] ^= r),
                (e[16] ^= t),
                (e[17] ^= r),
                (e[26] ^= t),
                (e[27] ^= r),
                (e[36] ^= t),
                (e[37] ^= r),
                (e[46] ^= t),
                (e[47] ^= r),
                (t = u ^ ((i << 1) | (s >>> 31))),
                (r = l ^ ((s << 1) | (i >>> 31))),
                (e[8] ^= t),
                (e[9] ^= r),
                (e[18] ^= t),
                (e[19] ^= r),
                (e[28] ^= t),
                (e[29] ^= r),
                (e[38] ^= t),
                (e[39] ^= r),
                (e[48] ^= t),
                (e[49] ^= r),
                (m = e[0]),
                (y = e[1]),
                (z = (e[11] << 4) | (e[10] >>> 28)),
                (K = (e[10] << 4) | (e[11] >>> 28)),
                (P = (e[20] << 3) | (e[21] >>> 29)),
                (O = (e[21] << 3) | (e[20] >>> 29)),
                (ae = (e[31] << 9) | (e[30] >>> 23)),
                (ce = (e[30] << 9) | (e[31] >>> 23)),
                (V = (e[40] << 18) | (e[41] >>> 14)),
                (W = (e[41] << 18) | (e[40] >>> 14)),
                (B = (e[2] << 1) | (e[3] >>> 31)),
                (D = (e[3] << 1) | (e[2] >>> 31)),
                (g = (e[13] << 12) | (e[12] >>> 20)),
                (v = (e[12] << 12) | (e[13] >>> 20)),
                (J = (e[22] << 10) | (e[23] >>> 22)),
                (X = (e[23] << 10) | (e[22] >>> 22)),
                (C = (e[33] << 13) | (e[32] >>> 19)),
                (k = (e[32] << 13) | (e[33] >>> 19)),
                (de = (e[42] << 2) | (e[43] >>> 30)),
                (ue = (e[43] << 2) | (e[42] >>> 30)),
                (te = (e[5] << 30) | (e[4] >>> 2)),
                (re = (e[4] << 30) | (e[5] >>> 2)),
                (j = (e[14] << 6) | (e[15] >>> 26)),
                (L = (e[15] << 6) | (e[14] >>> 26)),
                (b = (e[25] << 11) | (e[24] >>> 21)),
                (w = (e[24] << 11) | (e[25] >>> 21)),
                (Q = (e[34] << 15) | (e[35] >>> 17)),
                ($ = (e[35] << 15) | (e[34] >>> 17)),
                (M = (e[45] << 29) | (e[44] >>> 3)),
                (N = (e[44] << 29) | (e[45] >>> 3)),
                (R = (e[6] << 28) | (e[7] >>> 4)),
                (I = (e[7] << 28) | (e[6] >>> 4)),
                (ne = (e[17] << 23) | (e[16] >>> 9)),
                (ie = (e[16] << 23) | (e[17] >>> 9)),
                (U = (e[26] << 25) | (e[27] >>> 7)),
                (F = (e[27] << 25) | (e[26] >>> 7)),
                (E = (e[36] << 21) | (e[37] >>> 11)),
                (A = (e[37] << 21) | (e[36] >>> 11)),
                (Y = (e[47] << 24) | (e[46] >>> 8)),
                (ee = (e[46] << 24) | (e[47] >>> 8)),
                (q = (e[8] << 27) | (e[9] >>> 5)),
                (Z = (e[9] << 27) | (e[8] >>> 5)),
                (S = (e[18] << 20) | (e[19] >>> 12)),
                (x = (e[19] << 20) | (e[18] >>> 12)),
                (se = (e[29] << 7) | (e[28] >>> 25)),
                (oe = (e[28] << 7) | (e[29] >>> 25)),
                (H = (e[38] << 8) | (e[39] >>> 24)),
                (G = (e[39] << 8) | (e[38] >>> 24)),
                (_ = (e[48] << 14) | (e[49] >>> 18)),
                (T = (e[49] << 14) | (e[48] >>> 18)),
                (e[0] = m ^ (~g & b)),
                (e[1] = y ^ (~v & w)),
                (e[10] = R ^ (~S & P)),
                (e[11] = I ^ (~x & O)),
                (e[20] = B ^ (~j & U)),
                (e[21] = D ^ (~L & F)),
                (e[30] = q ^ (~z & J)),
                (e[31] = Z ^ (~K & X)),
                (e[40] = te ^ (~ne & se)),
                (e[41] = re ^ (~ie & oe)),
                (e[2] = g ^ (~b & E)),
                (e[3] = v ^ (~w & A)),
                (e[12] = S ^ (~P & C)),
                (e[13] = x ^ (~O & k)),
                (e[22] = j ^ (~U & H)),
                (e[23] = L ^ (~F & G)),
                (e[32] = z ^ (~J & Q)),
                (e[33] = K ^ (~X & $)),
                (e[42] = ne ^ (~se & ae)),
                (e[43] = ie ^ (~oe & ce)),
                (e[4] = b ^ (~E & _)),
                (e[5] = w ^ (~A & T)),
                (e[14] = P ^ (~C & M)),
                (e[15] = O ^ (~k & N)),
                (e[24] = U ^ (~H & V)),
                (e[25] = F ^ (~G & W)),
                (e[34] = J ^ (~Q & Y)),
                (e[35] = X ^ (~$ & ee)),
                (e[44] = se ^ (~ae & de)),
                (e[45] = oe ^ (~ce & ue)),
                (e[6] = E ^ (~_ & m)),
                (e[7] = A ^ (~T & y)),
                (e[16] = C ^ (~M & R)),
                (e[17] = k ^ (~N & I)),
                (e[26] = H ^ (~V & B)),
                (e[27] = G ^ (~W & D)),
                (e[36] = Q ^ (~Y & q)),
                (e[37] = $ ^ (~ee & Z)),
                (e[46] = ae ^ (~de & te)),
                (e[47] = ce ^ (~ue & re)),
                (e[8] = _ ^ (~m & g)),
                (e[9] = T ^ (~y & v)),
                (e[18] = M ^ (~R & S)),
                (e[19] = N ^ (~I & x)),
                (e[28] = V ^ (~B & j)),
                (e[29] = W ^ (~D & L)),
                (e[38] = Y ^ (~q & z)),
                (e[39] = ee ^ (~Z & K)),
                (e[48] = de ^ (~te & ne)),
                (e[49] = ue ^ (~re & ie)),
                (e[0] ^= p[n]),
                (e[1] ^= p[n + 1]);
          };
          if (c) e.exports = I;
          else {
            for (x = 0; x < S.length; ++x) o[S[x]] = I[S[x]];
            d &&
              (void 0 ===
                (n = function () {
                  return I;
                }.call(t, r, t, e)) ||
                (e.exports = n));
          }
        })();
      },
      4889: function (e, t, r) {
        !(function (e, t) {
          "use strict";
          if (!e.setImmediate) {
            var r,
              n,
              i,
              s,
              o,
              a = 1,
              c = {},
              d = !1,
              u = e.document,
              l = Object.getPrototypeOf && Object.getPrototypeOf(e);
            (l = l && l.setTimeout ? l : e),
              "[object process]" === {}.toString.call(e.process)
                ? (r = function (e) {
                    process.nextTick(function () {
                      f(e);
                    });
                  })
                : (function () {
                    if (e.postMessage && !e.importScripts) {
                      var t = !0,
                        r = e.onmessage;
                      return (
                        (e.onmessage = function () {
                          t = !1;
                        }),
                        e.postMessage("", "*"),
                        (e.onmessage = r),
                        t
                      );
                    }
                  })()
                ? ((s = "setImmediate$" + Math.random() + "$"),
                  (o = function (t) {
                    t.source === e &&
                      "string" == typeof t.data &&
                      0 === t.data.indexOf(s) &&
                      f(+t.data.slice(s.length));
                  }),
                  e.addEventListener
                    ? e.addEventListener("message", o, !1)
                    : e.attachEvent("onmessage", o),
                  (r = function (t) {
                    e.postMessage(s + t, "*");
                  }))
                : e.MessageChannel
                ? (((i = new MessageChannel()).port1.onmessage = function (e) {
                    f(e.data);
                  }),
                  (r = function (e) {
                    i.port2.postMessage(e);
                  }))
                : u && "onreadystatechange" in u.createElement("script")
                ? ((n = u.documentElement),
                  (r = function (e) {
                    var t = u.createElement("script");
                    (t.onreadystatechange = function () {
                      f(e),
                        (t.onreadystatechange = null),
                        n.removeChild(t),
                        (t = null);
                    }),
                      n.appendChild(t);
                  }))
                : (r = function (e) {
                    setTimeout(f, 0, e);
                  }),
              (l.setImmediate = function (e) {
                "function" != typeof e && (e = new Function("" + e));
                for (
                  var t = new Array(arguments.length - 1), n = 0;
                  n < t.length;
                  n++
                )
                  t[n] = arguments[n + 1];
                var i = { callback: e, args: t };
                return (c[a] = i), r(a), a++;
              }),
              (l.clearImmediate = h);
          }
          function h(e) {
            delete c[e];
          }
          function f(e) {
            if (d) setTimeout(f, 0, e);
            else {
              var t = c[e];
              if (t) {
                d = !0;
                try {
                  !(function (e) {
                    var t = e.callback,
                      r = e.args;
                    switch (r.length) {
                      case 0:
                        t();
                        break;
                      case 1:
                        t(r[0]);
                        break;
                      case 2:
                        t(r[0], r[1]);
                        break;
                      case 3:
                        t(r[0], r[1], r[2]);
                        break;
                      default:
                        t.apply(undefined, r);
                    }
                  })(t);
                } finally {
                  h(e), (d = !1);
                }
              }
            }
          }
        })("undefined" == typeof self ? (void 0 === r.g ? this : r.g) : self);
      },
      1625: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Chacha20 = void 0);
        var r = (function () {
          function e(e, t, r) {
            if (
              ((this.key = e),
              (this.nonce = t),
              (this.counter = r),
              (this._rounds = 20),
              (this._sigma = [1634760805, 857760878, 2036477234, 1797285236]),
              (this._byteCounter = 0),
              !(e instanceof Uint8Array) || 32 !== e.length)
            )
              throw new Error("Key should be 32 byte array!");
            if (!(t instanceof Uint8Array) || 12 !== t.length)
              throw new Error("Nonce should be 12 byte array!");
            r || (this.counter = 0),
              (this._param = [
                this._sigma[0],
                this._sigma[1],
                this._sigma[2],
                this._sigma[3],
                this._get32(e, 0),
                this._get32(e, 4),
                this._get32(e, 8),
                this._get32(e, 12),
                this._get32(e, 16),
                this._get32(e, 20),
                this._get32(e, 24),
                this._get32(e, 28),
                this.counter,
                this._get32(t, 0),
                this._get32(t, 4),
                this._get32(t, 8),
              ]),
              (this._keystream = [
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0,
              ]);
          }
          return (
            (e.prototype._chacha = function () {
              var e = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                t = 0,
                r = 0;
              for (t = 0; t < 16; t++) e[t] = this._param[t];
              for (t = 0; t < this._rounds; t += 2)
                this._quarterround(e, 0, 4, 8, 12),
                  this._quarterround(e, 1, 5, 9, 13),
                  this._quarterround(e, 2, 6, 10, 14),
                  this._quarterround(e, 3, 7, 11, 15),
                  this._quarterround(e, 0, 5, 10, 15),
                  this._quarterround(e, 1, 6, 11, 12),
                  this._quarterround(e, 2, 7, 8, 13),
                  this._quarterround(e, 3, 4, 9, 14);
              for (t = 0; t < 16; t++)
                (e[t] += this._param[t]),
                  (this._keystream[r++] = 255 & e[t]),
                  (this._keystream[r++] = (e[t] >>> 8) & 255),
                  (this._keystream[r++] = (e[t] >>> 16) & 255),
                  (this._keystream[r++] = (e[t] >>> 24) & 255);
            }),
            (e.prototype._quarterround = function (e, t, r, n, i) {
              (e[i] = this._rotl(e[i] ^ (e[t] += e[r]), 16)),
                (e[r] = this._rotl(e[r] ^ (e[n] += e[i]), 12)),
                (e[i] = this._rotl(e[i] ^ (e[t] += e[r]), 8)),
                (e[r] = this._rotl(e[r] ^ (e[n] += e[i]), 7)),
                (e[t] >>>= 0),
                (e[r] >>>= 0),
                (e[n] >>>= 0),
                (e[i] >>>= 0);
            }),
            (e.prototype._get32 = function (e, t) {
              return e[t++] ^ (e[t++] << 8) ^ (e[t++] << 16) ^ (e[t] << 24);
            }),
            (e.prototype._rotl = function (e, t) {
              return (e << t) | (e >>> (32 - t));
            }),
            (e.prototype.encrypt = function (e) {
              return this._update(e);
            }),
            (e.prototype.decrypt = function (e) {
              return this._update(e);
            }),
            (e.prototype._update = function (e) {
              if (!(e instanceof Uint8Array) || 0 === e.length)
                throw new Error(
                  "Data should be type of bytes (Uint8Array) and not empty!",
                );
              for (var t = new Uint8Array(e.length), r = 0; r < e.length; r++)
                (0 !== this._byteCounter && 64 !== this._byteCounter) ||
                  (this._chacha(), this._param[12]++, (this._byteCounter = 0)),
                  (t[r] = e[r] ^ this._keystream[this._byteCounter++]);
              return t;
            }),
            e
          );
        })();
        t.Chacha20 = r;
      },
      8923: (e, t, r) => {
        "use strict";
        r.r(t), r.d(t, { default: () => i });
        var n = null;
        "undefined" != typeof WebSocket
          ? (n = WebSocket)
          : "undefined" != typeof MozWebSocket
          ? (n = MozWebSocket)
          : void 0 !== r.g
          ? (n = r.g.WebSocket || r.g.MozWebSocket)
          : "undefined" != typeof window
          ? (n = window.WebSocket || window.MozWebSocket)
          : "undefined" != typeof self &&
            (n = self.WebSocket || self.MozWebSocket);
        const i = n;
      },
      8280: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ZodError = t.quotelessJson = t.ZodIssueCode = void 0);
        const n = r(9110);
        (t.ZodIssueCode = n.util.arrayToEnum([
          "invalid_type",
          "invalid_literal",
          "custom",
          "invalid_union",
          "invalid_union_discriminator",
          "invalid_enum_value",
          "unrecognized_keys",
          "invalid_arguments",
          "invalid_return_type",
          "invalid_date",
          "invalid_string",
          "too_small",
          "too_big",
          "invalid_intersection_types",
          "not_multiple_of",
          "not_finite",
        ])),
          (t.quotelessJson = (e) =>
            JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:"));
        class i extends Error {
          constructor(e) {
            super(),
              (this.issues = []),
              (this.addIssue = (e) => {
                this.issues = [...this.issues, e];
              }),
              (this.addIssues = (e = []) => {
                this.issues = [...this.issues, ...e];
              });
            const t = new.target.prototype;
            Object.setPrototypeOf
              ? Object.setPrototypeOf(this, t)
              : (this.__proto__ = t),
              (this.name = "ZodError"),
              (this.issues = e);
          }
          get errors() {
            return this.issues;
          }
          format(e) {
            const t =
                e ||
                function (e) {
                  return e.message;
                },
              r = { _errors: [] },
              n = (e) => {
                for (const i of e.issues)
                  if ("invalid_union" === i.code) i.unionErrors.map(n);
                  else if ("invalid_return_type" === i.code)
                    n(i.returnTypeError);
                  else if ("invalid_arguments" === i.code) n(i.argumentsError);
                  else if (0 === i.path.length) r._errors.push(t(i));
                  else {
                    let e = r,
                      n = 0;
                    for (; n < i.path.length; ) {
                      const r = i.path[n];
                      n === i.path.length - 1
                        ? ((e[r] = e[r] || { _errors: [] }),
                          e[r]._errors.push(t(i)))
                        : (e[r] = e[r] || { _errors: [] }),
                        (e = e[r]),
                        n++;
                    }
                  }
              };
            return n(this), r;
          }
          toString() {
            return this.message;
          }
          get message() {
            return JSON.stringify(this.issues, n.util.jsonStringifyReplacer, 2);
          }
          get isEmpty() {
            return 0 === this.issues.length;
          }
          flatten(e = (e) => e.message) {
            const t = {},
              r = [];
            for (const n of this.issues)
              n.path.length > 0
                ? ((t[n.path[0]] = t[n.path[0]] || []), t[n.path[0]].push(e(n)))
                : r.push(e(n));
            return { formErrors: r, fieldErrors: t };
          }
          get formErrors() {
            return this.flatten();
          }
        }
        (t.ZodError = i), (i.create = (e) => new i(e));
      },
      6996: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__importDefault) ||
          function (e) {
            return e && e.__esModule ? e : { default: e };
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getErrorMap = t.setErrorMap = t.defaultErrorMap = void 0);
        const i = n(r(9349));
        t.defaultErrorMap = i.default;
        let s = i.default;
        (t.setErrorMap = function (e) {
          s = e;
        }),
          (t.getErrorMap = function () {
            return s;
          });
      },
      6349: function (e, t, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (e, t, r, n) {
                  void 0 === n && (n = r),
                    Object.defineProperty(e, n, {
                      enumerable: !0,
                      get: function () {
                        return t[r];
                      },
                    });
                }
              : function (e, t, r, n) {
                  void 0 === n && (n = r), (e[n] = t[r]);
                }),
          i =
            (this && this.__exportStar) ||
            function (e, t) {
              for (var r in e)
                "default" === r ||
                  Object.prototype.hasOwnProperty.call(t, r) ||
                  n(t, e, r);
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          i(r(6996), t),
          i(r(3187), t),
          i(r(116), t),
          i(r(9110), t),
          i(r(5433), t),
          i(r(8280), t);
      },
      8762: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.errorUtil = void 0),
          ((r = t.errorUtil || (t.errorUtil = {})).errToObj = (e) =>
            "string" == typeof e ? { message: e } : e || {}),
          (r.toString = (e) =>
            "string" == typeof e ? e : null == e ? void 0 : e.message);
      },
      3187: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__importDefault) ||
          function (e) {
            return e && e.__esModule ? e : { default: e };
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.isAsync =
            t.isValid =
            t.isDirty =
            t.isAborted =
            t.OK =
            t.DIRTY =
            t.INVALID =
            t.ParseStatus =
            t.addIssueToContext =
            t.EMPTY_PATH =
            t.makeIssue =
              void 0);
        const i = r(6996),
          s = n(r(9349));
        (t.makeIssue = (e) => {
          const { data: t, path: r, errorMaps: n, issueData: i } = e,
            s = [...r, ...(i.path || [])],
            o = { ...i, path: s };
          let a = "";
          const c = n
            .filter((e) => !!e)
            .slice()
            .reverse();
          for (const e of c) a = e(o, { data: t, defaultError: a }).message;
          return { ...i, path: s, message: i.message || a };
        }),
          (t.EMPTY_PATH = []),
          (t.addIssueToContext = function (e, r) {
            const n = (0, t.makeIssue)({
              issueData: r,
              data: e.data,
              path: e.path,
              errorMaps: [
                e.common.contextualErrorMap,
                e.schemaErrorMap,
                (0, i.getErrorMap)(),
                s.default,
              ].filter((e) => !!e),
            });
            e.common.issues.push(n);
          });
        class o {
          constructor() {
            this.value = "valid";
          }
          dirty() {
            "valid" === this.value && (this.value = "dirty");
          }
          abort() {
            "aborted" !== this.value && (this.value = "aborted");
          }
          static mergeArray(e, r) {
            const n = [];
            for (const i of r) {
              if ("aborted" === i.status) return t.INVALID;
              "dirty" === i.status && e.dirty(), n.push(i.value);
            }
            return { status: e.value, value: n };
          }
          static async mergeObjectAsync(e, t) {
            const r = [];
            for (const e of t)
              r.push({ key: await e.key, value: await e.value });
            return o.mergeObjectSync(e, r);
          }
          static mergeObjectSync(e, r) {
            const n = {};
            for (const i of r) {
              const { key: r, value: s } = i;
              if ("aborted" === r.status) return t.INVALID;
              if ("aborted" === s.status) return t.INVALID;
              "dirty" === r.status && e.dirty(),
                "dirty" === s.status && e.dirty(),
                "__proto__" === r.value ||
                  (void 0 === s.value && !i.alwaysSet) ||
                  (n[r.value] = s.value);
            }
            return { status: e.value, value: n };
          }
        }
        (t.ParseStatus = o),
          (t.INVALID = Object.freeze({ status: "aborted" })),
          (t.DIRTY = (e) => ({ status: "dirty", value: e })),
          (t.OK = (e) => ({ status: "valid", value: e })),
          (t.isAborted = (e) => "aborted" === e.status),
          (t.isDirty = (e) => "dirty" === e.status),
          (t.isValid = (e) => "valid" === e.status),
          (t.isAsync = (e) =>
            "undefined" != typeof Promise && e instanceof Promise);
      },
      116: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
      },
      9110: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getParsedType = t.ZodParsedType = t.objectUtil = t.util = void 0),
          (function (e) {
            (e.assertEqual = (e) => e),
              (e.assertIs = function (e) {}),
              (e.assertNever = function (e) {
                throw new Error();
              }),
              (e.arrayToEnum = (e) => {
                const t = {};
                for (const r of e) t[r] = r;
                return t;
              }),
              (e.getValidEnumValues = (t) => {
                const r = e
                    .objectKeys(t)
                    .filter((e) => "number" != typeof t[t[e]]),
                  n = {};
                for (const e of r) n[e] = t[e];
                return e.objectValues(n);
              }),
              (e.objectValues = (t) =>
                e.objectKeys(t).map(function (e) {
                  return t[e];
                })),
              (e.objectKeys =
                "function" == typeof Object.keys
                  ? (e) => Object.keys(e)
                  : (e) => {
                      const t = [];
                      for (const r in e)
                        Object.prototype.hasOwnProperty.call(e, r) && t.push(r);
                      return t;
                    }),
              (e.find = (e, t) => {
                for (const r of e) if (t(r)) return r;
              }),
              (e.isInteger =
                "function" == typeof Number.isInteger
                  ? (e) => Number.isInteger(e)
                  : (e) =>
                      "number" == typeof e &&
                      isFinite(e) &&
                      Math.floor(e) === e),
              (e.joinValues = function (e, t = " | ") {
                return e
                  .map((e) => ("string" == typeof e ? `'${e}'` : e))
                  .join(t);
              }),
              (e.jsonStringifyReplacer = (e, t) =>
                "bigint" == typeof t ? t.toString() : t);
          })((r = t.util || (t.util = {}))),
          ((t.objectUtil || (t.objectUtil = {})).mergeShapes = (e, t) => ({
            ...e,
            ...t,
          })),
          (t.ZodParsedType = r.arrayToEnum([
            "string",
            "nan",
            "number",
            "integer",
            "float",
            "boolean",
            "date",
            "bigint",
            "symbol",
            "function",
            "undefined",
            "null",
            "array",
            "object",
            "unknown",
            "promise",
            "void",
            "never",
            "map",
            "set",
          ])),
          (t.getParsedType = (e) => {
            switch (typeof e) {
              case "undefined":
                return t.ZodParsedType.undefined;
              case "string":
                return t.ZodParsedType.string;
              case "number":
                return isNaN(e) ? t.ZodParsedType.nan : t.ZodParsedType.number;
              case "boolean":
                return t.ZodParsedType.boolean;
              case "function":
                return t.ZodParsedType.function;
              case "bigint":
                return t.ZodParsedType.bigint;
              case "symbol":
                return t.ZodParsedType.symbol;
              case "object":
                return Array.isArray(e)
                  ? t.ZodParsedType.array
                  : null === e
                  ? t.ZodParsedType.null
                  : e.then &&
                    "function" == typeof e.then &&
                    e.catch &&
                    "function" == typeof e.catch
                  ? t.ZodParsedType.promise
                  : "undefined" != typeof Map && e instanceof Map
                  ? t.ZodParsedType.map
                  : "undefined" != typeof Set && e instanceof Set
                  ? t.ZodParsedType.set
                  : "undefined" != typeof Date && e instanceof Date
                  ? t.ZodParsedType.date
                  : t.ZodParsedType.object;
              default:
                return t.ZodParsedType.unknown;
            }
          });
      },
      8754: function (e, t, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (e, t, r, n) {
                  void 0 === n && (n = r),
                    Object.defineProperty(e, n, {
                      enumerable: !0,
                      get: function () {
                        return t[r];
                      },
                    });
                }
              : function (e, t, r, n) {
                  void 0 === n && (n = r), (e[n] = t[r]);
                }),
          i =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (e, t) {
                  Object.defineProperty(e, "default", {
                    enumerable: !0,
                    value: t,
                  });
                }
              : function (e, t) {
                  e.default = t;
                }),
          s =
            (this && this.__importStar) ||
            function (e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(e, r) &&
                    n(t, e, r);
              return i(t, e), t;
            },
          o =
            (this && this.__exportStar) ||
            function (e, t) {
              for (var r in e)
                "default" === r ||
                  Object.prototype.hasOwnProperty.call(t, r) ||
                  n(t, e, r);
            };
        Object.defineProperty(t, "__esModule", { value: !0 }), (t.z = void 0);
        const a = s(r(6349));
        (t.z = a), o(r(6349), t), (t.default = a);
      },
      9349: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
        const n = r(9110),
          i = r(8280);
        t.default = (e, t) => {
          let r;
          switch (e.code) {
            case i.ZodIssueCode.invalid_type:
              r =
                e.received === n.ZodParsedType.undefined
                  ? "Required"
                  : `Expected ${e.expected}, received ${e.received}`;
              break;
            case i.ZodIssueCode.invalid_literal:
              r = `Invalid literal value, expected ${JSON.stringify(
                e.expected,
                n.util.jsonStringifyReplacer,
              )}`;
              break;
            case i.ZodIssueCode.unrecognized_keys:
              r = `Unrecognized key(s) in object: ${n.util.joinValues(
                e.keys,
                ", ",
              )}`;
              break;
            case i.ZodIssueCode.invalid_union:
              r = "Invalid input";
              break;
            case i.ZodIssueCode.invalid_union_discriminator:
              r = `Invalid discriminator value. Expected ${n.util.joinValues(
                e.options,
              )}`;
              break;
            case i.ZodIssueCode.invalid_enum_value:
              r = `Invalid enum value. Expected ${n.util.joinValues(
                e.options,
              )}, received '${e.received}'`;
              break;
            case i.ZodIssueCode.invalid_arguments:
              r = "Invalid function arguments";
              break;
            case i.ZodIssueCode.invalid_return_type:
              r = "Invalid function return type";
              break;
            case i.ZodIssueCode.invalid_date:
              r = "Invalid date";
              break;
            case i.ZodIssueCode.invalid_string:
              "object" == typeof e.validation
                ? "includes" in e.validation
                  ? ((r = `Invalid input: must include "${e.validation.includes}"`),
                    "number" == typeof e.validation.position &&
                      (r = `${r} at one or more positions greater than or equal to ${e.validation.position}`))
                  : "startsWith" in e.validation
                  ? (r = `Invalid input: must start with "${e.validation.startsWith}"`)
                  : "endsWith" in e.validation
                  ? (r = `Invalid input: must end with "${e.validation.endsWith}"`)
                  : n.util.assertNever(e.validation)
                : (r =
                    "regex" !== e.validation
                      ? `Invalid ${e.validation}`
                      : "Invalid");
              break;
            case i.ZodIssueCode.too_small:
              r =
                "array" === e.type
                  ? `Array must contain ${
                      e.exact
                        ? "exactly"
                        : e.inclusive
                        ? "at least"
                        : "more than"
                    } ${e.minimum} element(s)`
                  : "string" === e.type
                  ? `String must contain ${
                      e.exact ? "exactly" : e.inclusive ? "at least" : "over"
                    } ${e.minimum} character(s)`
                  : "number" === e.type
                  ? `Number must be ${
                      e.exact
                        ? "exactly equal to "
                        : e.inclusive
                        ? "greater than or equal to "
                        : "greater than "
                    }${e.minimum}`
                  : "date" === e.type
                  ? `Date must be ${
                      e.exact
                        ? "exactly equal to "
                        : e.inclusive
                        ? "greater than or equal to "
                        : "greater than "
                    }${new Date(Number(e.minimum))}`
                  : "Invalid input";
              break;
            case i.ZodIssueCode.too_big:
              r =
                "array" === e.type
                  ? `Array must contain ${
                      e.exact
                        ? "exactly"
                        : e.inclusive
                        ? "at most"
                        : "less than"
                    } ${e.maximum} element(s)`
                  : "string" === e.type
                  ? `String must contain ${
                      e.exact ? "exactly" : e.inclusive ? "at most" : "under"
                    } ${e.maximum} character(s)`
                  : "number" === e.type
                  ? `Number must be ${
                      e.exact
                        ? "exactly"
                        : e.inclusive
                        ? "less than or equal to"
                        : "less than"
                    } ${e.maximum}`
                  : "bigint" === e.type
                  ? `BigInt must be ${
                      e.exact
                        ? "exactly"
                        : e.inclusive
                        ? "less than or equal to"
                        : "less than"
                    } ${e.maximum}`
                  : "date" === e.type
                  ? `Date must be ${
                      e.exact
                        ? "exactly"
                        : e.inclusive
                        ? "smaller than or equal to"
                        : "smaller than"
                    } ${new Date(Number(e.maximum))}`
                  : "Invalid input";
              break;
            case i.ZodIssueCode.custom:
              r = "Invalid input";
              break;
            case i.ZodIssueCode.invalid_intersection_types:
              r = "Intersection results could not be merged";
              break;
            case i.ZodIssueCode.not_multiple_of:
              r = `Number must be a multiple of ${e.multipleOf}`;
              break;
            case i.ZodIssueCode.not_finite:
              r = "Number must be finite";
              break;
            default:
              (r = t.defaultError), n.util.assertNever(e);
          }
          return { message: r };
        };
      },
      5433: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.date =
            t.boolean =
            t.bigint =
            t.array =
            t.any =
            t.coerce =
            t.ZodFirstPartyTypeKind =
            t.late =
            t.ZodSchema =
            t.Schema =
            t.custom =
            t.ZodReadonly =
            t.ZodPipeline =
            t.ZodBranded =
            t.BRAND =
            t.ZodNaN =
            t.ZodCatch =
            t.ZodDefault =
            t.ZodNullable =
            t.ZodOptional =
            t.ZodTransformer =
            t.ZodEffects =
            t.ZodPromise =
            t.ZodNativeEnum =
            t.ZodEnum =
            t.ZodLiteral =
            t.ZodLazy =
            t.ZodFunction =
            t.ZodSet =
            t.ZodMap =
            t.ZodRecord =
            t.ZodTuple =
            t.ZodIntersection =
            t.ZodDiscriminatedUnion =
            t.ZodUnion =
            t.ZodObject =
            t.ZodArray =
            t.ZodVoid =
            t.ZodNever =
            t.ZodUnknown =
            t.ZodAny =
            t.ZodNull =
            t.ZodUndefined =
            t.ZodSymbol =
            t.ZodDate =
            t.ZodBoolean =
            t.ZodBigInt =
            t.ZodNumber =
            t.ZodString =
            t.ZodType =
              void 0),
          (t.NEVER =
            t.void =
            t.unknown =
            t.union =
            t.undefined =
            t.tuple =
            t.transformer =
            t.symbol =
            t.string =
            t.strictObject =
            t.set =
            t.record =
            t.promise =
            t.preprocess =
            t.pipeline =
            t.ostring =
            t.optional =
            t.onumber =
            t.oboolean =
            t.object =
            t.number =
            t.nullable =
            t.null =
            t.never =
            t.nativeEnum =
            t.nan =
            t.map =
            t.literal =
            t.lazy =
            t.intersection =
            t.instanceof =
            t.function =
            t.enum =
            t.effect =
            t.discriminatedUnion =
              void 0);
        const n = r(6996),
          i = r(8762),
          s = r(3187),
          o = r(9110),
          a = r(8280);
        class c {
          constructor(e, t, r, n) {
            (this._cachedPath = []),
              (this.parent = e),
              (this.data = t),
              (this._path = r),
              (this._key = n);
          }
          get path() {
            return (
              this._cachedPath.length ||
                (this._key instanceof Array
                  ? this._cachedPath.push(...this._path, ...this._key)
                  : this._cachedPath.push(...this._path, this._key)),
              this._cachedPath
            );
          }
        }
        const d = (e, t) => {
          if ((0, s.isValid)(t)) return { success: !0, data: t.value };
          if (!e.common.issues.length)
            throw new Error("Validation failed but no issues detected.");
          return {
            success: !1,
            get error() {
              if (this._error) return this._error;
              const t = new a.ZodError(e.common.issues);
              return (this._error = t), this._error;
            },
          };
        };
        function u(e) {
          if (!e) return {};
          const {
            errorMap: t,
            invalid_type_error: r,
            required_error: n,
            description: i,
          } = e;
          if (t && (r || n))
            throw new Error(
              'Can\'t use "invalid_type_error" or "required_error" in conjunction with custom error map.',
            );
          return t
            ? { errorMap: t, description: i }
            : {
                errorMap: (e, t) =>
                  "invalid_type" !== e.code
                    ? { message: t.defaultError }
                    : void 0 === t.data
                    ? { message: null != n ? n : t.defaultError }
                    : { message: null != r ? r : t.defaultError },
                description: i,
              };
        }
        class l {
          constructor(e) {
            (this.spa = this.safeParseAsync),
              (this._def = e),
              (this.parse = this.parse.bind(this)),
              (this.safeParse = this.safeParse.bind(this)),
              (this.parseAsync = this.parseAsync.bind(this)),
              (this.safeParseAsync = this.safeParseAsync.bind(this)),
              (this.spa = this.spa.bind(this)),
              (this.refine = this.refine.bind(this)),
              (this.refinement = this.refinement.bind(this)),
              (this.superRefine = this.superRefine.bind(this)),
              (this.optional = this.optional.bind(this)),
              (this.nullable = this.nullable.bind(this)),
              (this.nullish = this.nullish.bind(this)),
              (this.array = this.array.bind(this)),
              (this.promise = this.promise.bind(this)),
              (this.or = this.or.bind(this)),
              (this.and = this.and.bind(this)),
              (this.transform = this.transform.bind(this)),
              (this.brand = this.brand.bind(this)),
              (this.default = this.default.bind(this)),
              (this.catch = this.catch.bind(this)),
              (this.describe = this.describe.bind(this)),
              (this.pipe = this.pipe.bind(this)),
              (this.readonly = this.readonly.bind(this)),
              (this.isNullable = this.isNullable.bind(this)),
              (this.isOptional = this.isOptional.bind(this));
          }
          get description() {
            return this._def.description;
          }
          _getType(e) {
            return (0, o.getParsedType)(e.data);
          }
          _getOrReturnCtx(e, t) {
            return (
              t || {
                common: e.parent.common,
                data: e.data,
                parsedType: (0, o.getParsedType)(e.data),
                schemaErrorMap: this._def.errorMap,
                path: e.path,
                parent: e.parent,
              }
            );
          }
          _processInputParams(e) {
            return {
              status: new s.ParseStatus(),
              ctx: {
                common: e.parent.common,
                data: e.data,
                parsedType: (0, o.getParsedType)(e.data),
                schemaErrorMap: this._def.errorMap,
                path: e.path,
                parent: e.parent,
              },
            };
          }
          _parseSync(e) {
            const t = this._parse(e);
            if ((0, s.isAsync)(t))
              throw new Error("Synchronous parse encountered promise.");
            return t;
          }
          _parseAsync(e) {
            const t = this._parse(e);
            return Promise.resolve(t);
          }
          parse(e, t) {
            const r = this.safeParse(e, t);
            if (r.success) return r.data;
            throw r.error;
          }
          safeParse(e, t) {
            var r;
            const n = {
                common: {
                  issues: [],
                  async:
                    null !== (r = null == t ? void 0 : t.async) &&
                    void 0 !== r &&
                    r,
                  contextualErrorMap: null == t ? void 0 : t.errorMap,
                },
                path: (null == t ? void 0 : t.path) || [],
                schemaErrorMap: this._def.errorMap,
                parent: null,
                data: e,
                parsedType: (0, o.getParsedType)(e),
              },
              i = this._parseSync({ data: e, path: n.path, parent: n });
            return d(n, i);
          }
          async parseAsync(e, t) {
            const r = await this.safeParseAsync(e, t);
            if (r.success) return r.data;
            throw r.error;
          }
          async safeParseAsync(e, t) {
            const r = {
                common: {
                  issues: [],
                  contextualErrorMap: null == t ? void 0 : t.errorMap,
                  async: !0,
                },
                path: (null == t ? void 0 : t.path) || [],
                schemaErrorMap: this._def.errorMap,
                parent: null,
                data: e,
                parsedType: (0, o.getParsedType)(e),
              },
              n = this._parse({ data: e, path: r.path, parent: r }),
              i = await ((0, s.isAsync)(n) ? n : Promise.resolve(n));
            return d(r, i);
          }
          refine(e, t) {
            const r = (e) =>
              "string" == typeof t || void 0 === t
                ? { message: t }
                : "function" == typeof t
                ? t(e)
                : t;
            return this._refinement((t, n) => {
              const i = e(t),
                s = () => n.addIssue({ code: a.ZodIssueCode.custom, ...r(t) });
              return "undefined" != typeof Promise && i instanceof Promise
                ? i.then((e) => !!e || (s(), !1))
                : !!i || (s(), !1);
            });
          }
          refinement(e, t) {
            return this._refinement(
              (r, n) =>
                !!e(r) ||
                (n.addIssue("function" == typeof t ? t(r, n) : t), !1),
            );
          }
          _refinement(e) {
            return new $({
              schema: this,
              typeName: ae.ZodEffects,
              effect: { type: "refinement", refinement: e },
            });
          }
          superRefine(e) {
            return this._refinement(e);
          }
          optional() {
            return Y.create(this, this._def);
          }
          nullable() {
            return ee.create(this, this._def);
          }
          nullish() {
            return this.nullable().optional();
          }
          array() {
            return M.create(this, this._def);
          }
          promise() {
            return Q.create(this, this._def);
          }
          or(e) {
            return D.create([this, e], this._def);
          }
          and(e) {
            return F.create(this, e, this._def);
          }
          transform(e) {
            return new $({
              ...u(this._def),
              schema: this,
              typeName: ae.ZodEffects,
              effect: { type: "transform", transform: e },
            });
          }
          default(e) {
            const t = "function" == typeof e ? e : () => e;
            return new te({
              ...u(this._def),
              innerType: this,
              defaultValue: t,
              typeName: ae.ZodDefault,
            });
          }
          brand() {
            return new ie({
              typeName: ae.ZodBranded,
              type: this,
              ...u(this._def),
            });
          }
          catch(e) {
            const t = "function" == typeof e ? e : () => e;
            return new re({
              ...u(this._def),
              innerType: this,
              catchValue: t,
              typeName: ae.ZodCatch,
            });
          }
          describe(e) {
            return new (0, this.constructor)({ ...this._def, description: e });
          }
          pipe(e) {
            return se.create(this, e);
          }
          readonly() {
            return oe.create(this);
          }
          isOptional() {
            return this.safeParse(void 0).success;
          }
          isNullable() {
            return this.safeParse(null).success;
          }
        }
        (t.ZodType = l), (t.Schema = l), (t.ZodSchema = l);
        const h = /^c[^\s-]{8,}$/i,
          f = /^[a-z][a-z0-9]*$/,
          p = /[0-9A-HJKMNP-TV-Z]{26}/,
          m =
            /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
          y =
            /^([A-Z0-9_+-]+\.?)*[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,
          g = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u,
          v =
            /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/,
          b =
            /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
        class w extends l {
          constructor() {
            super(...arguments),
              (this._regex = (e, t, r) =>
                this.refinement((t) => e.test(t), {
                  validation: t,
                  code: a.ZodIssueCode.invalid_string,
                  ...i.errorUtil.errToObj(r),
                })),
              (this.nonempty = (e) => this.min(1, i.errorUtil.errToObj(e))),
              (this.trim = () =>
                new w({
                  ...this._def,
                  checks: [...this._def.checks, { kind: "trim" }],
                })),
              (this.toLowerCase = () =>
                new w({
                  ...this._def,
                  checks: [...this._def.checks, { kind: "toLowerCase" }],
                })),
              (this.toUpperCase = () =>
                new w({
                  ...this._def,
                  checks: [...this._def.checks, { kind: "toUpperCase" }],
                }));
          }
          _parse(e) {
            if (
              (this._def.coerce && (e.data = String(e.data)),
              this._getType(e) !== o.ZodParsedType.string)
            ) {
              const t = this._getOrReturnCtx(e);
              return (
                (0, s.addIssueToContext)(t, {
                  code: a.ZodIssueCode.invalid_type,
                  expected: o.ZodParsedType.string,
                  received: t.parsedType,
                }),
                s.INVALID
              );
            }
            const t = new s.ParseStatus();
            let r;
            for (const d of this._def.checks)
              if ("min" === d.kind)
                e.data.length < d.value &&
                  ((r = this._getOrReturnCtx(e, r)),
                  (0, s.addIssueToContext)(r, {
                    code: a.ZodIssueCode.too_small,
                    minimum: d.value,
                    type: "string",
                    inclusive: !0,
                    exact: !1,
                    message: d.message,
                  }),
                  t.dirty());
              else if ("max" === d.kind)
                e.data.length > d.value &&
                  ((r = this._getOrReturnCtx(e, r)),
                  (0, s.addIssueToContext)(r, {
                    code: a.ZodIssueCode.too_big,
                    maximum: d.value,
                    type: "string",
                    inclusive: !0,
                    exact: !1,
                    message: d.message,
                  }),
                  t.dirty());
              else if ("length" === d.kind) {
                const n = e.data.length > d.value,
                  i = e.data.length < d.value;
                (n || i) &&
                  ((r = this._getOrReturnCtx(e, r)),
                  n
                    ? (0, s.addIssueToContext)(r, {
                        code: a.ZodIssueCode.too_big,
                        maximum: d.value,
                        type: "string",
                        inclusive: !0,
                        exact: !0,
                        message: d.message,
                      })
                    : i &&
                      (0, s.addIssueToContext)(r, {
                        code: a.ZodIssueCode.too_small,
                        minimum: d.value,
                        type: "string",
                        inclusive: !0,
                        exact: !0,
                        message: d.message,
                      }),
                  t.dirty());
              } else if ("email" === d.kind)
                y.test(e.data) ||
                  ((r = this._getOrReturnCtx(e, r)),
                  (0, s.addIssueToContext)(r, {
                    validation: "email",
                    code: a.ZodIssueCode.invalid_string,
                    message: d.message,
                  }),
                  t.dirty());
              else if ("emoji" === d.kind)
                g.test(e.data) ||
                  ((r = this._getOrReturnCtx(e, r)),
                  (0, s.addIssueToContext)(r, {
                    validation: "emoji",
                    code: a.ZodIssueCode.invalid_string,
                    message: d.message,
                  }),
                  t.dirty());
              else if ("uuid" === d.kind)
                m.test(e.data) ||
                  ((r = this._getOrReturnCtx(e, r)),
                  (0, s.addIssueToContext)(r, {
                    validation: "uuid",
                    code: a.ZodIssueCode.invalid_string,
                    message: d.message,
                  }),
                  t.dirty());
              else if ("cuid" === d.kind)
                h.test(e.data) ||
                  ((r = this._getOrReturnCtx(e, r)),
                  (0, s.addIssueToContext)(r, {
                    validation: "cuid",
                    code: a.ZodIssueCode.invalid_string,
                    message: d.message,
                  }),
                  t.dirty());
              else if ("cuid2" === d.kind)
                f.test(e.data) ||
                  ((r = this._getOrReturnCtx(e, r)),
                  (0, s.addIssueToContext)(r, {
                    validation: "cuid2",
                    code: a.ZodIssueCode.invalid_string,
                    message: d.message,
                  }),
                  t.dirty());
              else if ("ulid" === d.kind)
                p.test(e.data) ||
                  ((r = this._getOrReturnCtx(e, r)),
                  (0, s.addIssueToContext)(r, {
                    validation: "ulid",
                    code: a.ZodIssueCode.invalid_string,
                    message: d.message,
                  }),
                  t.dirty());
              else if ("url" === d.kind)
                try {
                  new URL(e.data);
                } catch (n) {
                  (r = this._getOrReturnCtx(e, r)),
                    (0, s.addIssueToContext)(r, {
                      validation: "url",
                      code: a.ZodIssueCode.invalid_string,
                      message: d.message,
                    }),
                    t.dirty();
                }
              else
                "regex" === d.kind
                  ? ((d.regex.lastIndex = 0),
                    d.regex.test(e.data) ||
                      ((r = this._getOrReturnCtx(e, r)),
                      (0, s.addIssueToContext)(r, {
                        validation: "regex",
                        code: a.ZodIssueCode.invalid_string,
                        message: d.message,
                      }),
                      t.dirty()))
                  : "trim" === d.kind
                  ? (e.data = e.data.trim())
                  : "includes" === d.kind
                  ? e.data.includes(d.value, d.position) ||
                    ((r = this._getOrReturnCtx(e, r)),
                    (0, s.addIssueToContext)(r, {
                      code: a.ZodIssueCode.invalid_string,
                      validation: { includes: d.value, position: d.position },
                      message: d.message,
                    }),
                    t.dirty())
                  : "toLowerCase" === d.kind
                  ? (e.data = e.data.toLowerCase())
                  : "toUpperCase" === d.kind
                  ? (e.data = e.data.toUpperCase())
                  : "startsWith" === d.kind
                  ? e.data.startsWith(d.value) ||
                    ((r = this._getOrReturnCtx(e, r)),
                    (0, s.addIssueToContext)(r, {
                      code: a.ZodIssueCode.invalid_string,
                      validation: { startsWith: d.value },
                      message: d.message,
                    }),
                    t.dirty())
                  : "endsWith" === d.kind
                  ? e.data.endsWith(d.value) ||
                    ((r = this._getOrReturnCtx(e, r)),
                    (0, s.addIssueToContext)(r, {
                      code: a.ZodIssueCode.invalid_string,
                      validation: { endsWith: d.value },
                      message: d.message,
                    }),
                    t.dirty())
                  : "datetime" === d.kind
                  ? ((c = d).precision
                      ? c.offset
                        ? new RegExp(
                            `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${c.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`,
                          )
                        : new RegExp(
                            `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${c.precision}}Z$`,
                          )
                      : 0 === c.precision
                      ? c.offset
                        ? new RegExp(
                            "^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$",
                          )
                        : new RegExp(
                            "^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$",
                          )
                      : c.offset
                      ? new RegExp(
                          "^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$",
                        )
                      : new RegExp(
                          "^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$",
                        )
                    ).test(e.data) ||
                    ((r = this._getOrReturnCtx(e, r)),
                    (0, s.addIssueToContext)(r, {
                      code: a.ZodIssueCode.invalid_string,
                      validation: "datetime",
                      message: d.message,
                    }),
                    t.dirty())
                  : "ip" === d.kind
                  ? ((n = e.data),
                    (("v4" !== (i = d.version) && i) || !v.test(n)) &&
                      (("v6" !== i && i) || !b.test(n)) &&
                      ((r = this._getOrReturnCtx(e, r)),
                      (0, s.addIssueToContext)(r, {
                        validation: "ip",
                        code: a.ZodIssueCode.invalid_string,
                        message: d.message,
                      }),
                      t.dirty()))
                  : o.util.assertNever(d);
            var n, i, c;
            return { status: t.value, value: e.data };
          }
          _addCheck(e) {
            return new w({ ...this._def, checks: [...this._def.checks, e] });
          }
          email(e) {
            return this._addCheck({
              kind: "email",
              ...i.errorUtil.errToObj(e),
            });
          }
          url(e) {
            return this._addCheck({ kind: "url", ...i.errorUtil.errToObj(e) });
          }
          emoji(e) {
            return this._addCheck({
              kind: "emoji",
              ...i.errorUtil.errToObj(e),
            });
          }
          uuid(e) {
            return this._addCheck({ kind: "uuid", ...i.errorUtil.errToObj(e) });
          }
          cuid(e) {
            return this._addCheck({ kind: "cuid", ...i.errorUtil.errToObj(e) });
          }
          cuid2(e) {
            return this._addCheck({
              kind: "cuid2",
              ...i.errorUtil.errToObj(e),
            });
          }
          ulid(e) {
            return this._addCheck({ kind: "ulid", ...i.errorUtil.errToObj(e) });
          }
          ip(e) {
            return this._addCheck({ kind: "ip", ...i.errorUtil.errToObj(e) });
          }
          datetime(e) {
            var t;
            return "string" == typeof e
              ? this._addCheck({
                  kind: "datetime",
                  precision: null,
                  offset: !1,
                  message: e,
                })
              : this._addCheck({
                  kind: "datetime",
                  precision:
                    void 0 === (null == e ? void 0 : e.precision)
                      ? null
                      : null == e
                      ? void 0
                      : e.precision,
                  offset:
                    null !== (t = null == e ? void 0 : e.offset) &&
                    void 0 !== t &&
                    t,
                  ...i.errorUtil.errToObj(null == e ? void 0 : e.message),
                });
          }
          regex(e, t) {
            return this._addCheck({
              kind: "regex",
              regex: e,
              ...i.errorUtil.errToObj(t),
            });
          }
          includes(e, t) {
            return this._addCheck({
              kind: "includes",
              value: e,
              position: null == t ? void 0 : t.position,
              ...i.errorUtil.errToObj(null == t ? void 0 : t.message),
            });
          }
          startsWith(e, t) {
            return this._addCheck({
              kind: "startsWith",
              value: e,
              ...i.errorUtil.errToObj(t),
            });
          }
          endsWith(e, t) {
            return this._addCheck({
              kind: "endsWith",
              value: e,
              ...i.errorUtil.errToObj(t),
            });
          }
          min(e, t) {
            return this._addCheck({
              kind: "min",
              value: e,
              ...i.errorUtil.errToObj(t),
            });
          }
          max(e, t) {
            return this._addCheck({
              kind: "max",
              value: e,
              ...i.errorUtil.errToObj(t),
            });
          }
          length(e, t) {
            return this._addCheck({
              kind: "length",
              value: e,
              ...i.errorUtil.errToObj(t),
            });
          }
          get isDatetime() {
            return !!this._def.checks.find((e) => "datetime" === e.kind);
          }
          get isEmail() {
            return !!this._def.checks.find((e) => "email" === e.kind);
          }
          get isURL() {
            return !!this._def.checks.find((e) => "url" === e.kind);
          }
          get isEmoji() {
            return !!this._def.checks.find((e) => "emoji" === e.kind);
          }
          get isUUID() {
            return !!this._def.checks.find((e) => "uuid" === e.kind);
          }
          get isCUID() {
            return !!this._def.checks.find((e) => "cuid" === e.kind);
          }
          get isCUID2() {
            return !!this._def.checks.find((e) => "cuid2" === e.kind);
          }
          get isULID() {
            return !!this._def.checks.find((e) => "ulid" === e.kind);
          }
          get isIP() {
            return !!this._def.checks.find((e) => "ip" === e.kind);
          }
          get minLength() {
            let e = null;
            for (const t of this._def.checks)
              "min" === t.kind && (null === e || t.value > e) && (e = t.value);
            return e;
          }
          get maxLength() {
            let e = null;
            for (const t of this._def.checks)
              "max" === t.kind && (null === e || t.value < e) && (e = t.value);
            return e;
          }
        }
        function E(e, t) {
          const r = (e.toString().split(".")[1] || "").length,
            n = (t.toString().split(".")[1] || "").length,
            i = r > n ? r : n;
          return (
            (parseInt(e.toFixed(i).replace(".", "")) %
              parseInt(t.toFixed(i).replace(".", ""))) /
            Math.pow(10, i)
          );
        }
        (t.ZodString = w),
          (w.create = (e) => {
            var t;
            return new w({
              checks: [],
              typeName: ae.ZodString,
              coerce:
                null !== (t = null == e ? void 0 : e.coerce) &&
                void 0 !== t &&
                t,
              ...u(e),
            });
          });
        class A extends l {
          constructor() {
            super(...arguments),
              (this.min = this.gte),
              (this.max = this.lte),
              (this.step = this.multipleOf);
          }
          _parse(e) {
            if (
              (this._def.coerce && (e.data = Number(e.data)),
              this._getType(e) !== o.ZodParsedType.number)
            ) {
              const t = this._getOrReturnCtx(e);
              return (
                (0, s.addIssueToContext)(t, {
                  code: a.ZodIssueCode.invalid_type,
                  expected: o.ZodParsedType.number,
                  received: t.parsedType,
                }),
                s.INVALID
              );
            }
            let t;
            const r = new s.ParseStatus();
            for (const n of this._def.checks)
              "int" === n.kind
                ? o.util.isInteger(e.data) ||
                  ((t = this._getOrReturnCtx(e, t)),
                  (0, s.addIssueToContext)(t, {
                    code: a.ZodIssueCode.invalid_type,
                    expected: "integer",
                    received: "float",
                    message: n.message,
                  }),
                  r.dirty())
                : "min" === n.kind
                ? (n.inclusive ? e.data < n.value : e.data <= n.value) &&
                  ((t = this._getOrReturnCtx(e, t)),
                  (0, s.addIssueToContext)(t, {
                    code: a.ZodIssueCode.too_small,
                    minimum: n.value,
                    type: "number",
                    inclusive: n.inclusive,
                    exact: !1,
                    message: n.message,
                  }),
                  r.dirty())
                : "max" === n.kind
                ? (n.inclusive ? e.data > n.value : e.data >= n.value) &&
                  ((t = this._getOrReturnCtx(e, t)),
                  (0, s.addIssueToContext)(t, {
                    code: a.ZodIssueCode.too_big,
                    maximum: n.value,
                    type: "number",
                    inclusive: n.inclusive,
                    exact: !1,
                    message: n.message,
                  }),
                  r.dirty())
                : "multipleOf" === n.kind
                ? 0 !== E(e.data, n.value) &&
                  ((t = this._getOrReturnCtx(e, t)),
                  (0, s.addIssueToContext)(t, {
                    code: a.ZodIssueCode.not_multiple_of,
                    multipleOf: n.value,
                    message: n.message,
                  }),
                  r.dirty())
                : "finite" === n.kind
                ? Number.isFinite(e.data) ||
                  ((t = this._getOrReturnCtx(e, t)),
                  (0, s.addIssueToContext)(t, {
                    code: a.ZodIssueCode.not_finite,
                    message: n.message,
                  }),
                  r.dirty())
                : o.util.assertNever(n);
            return { status: r.value, value: e.data };
          }
          gte(e, t) {
            return this.setLimit("min", e, !0, i.errorUtil.toString(t));
          }
          gt(e, t) {
            return this.setLimit("min", e, !1, i.errorUtil.toString(t));
          }
          lte(e, t) {
            return this.setLimit("max", e, !0, i.errorUtil.toString(t));
          }
          lt(e, t) {
            return this.setLimit("max", e, !1, i.errorUtil.toString(t));
          }
          setLimit(e, t, r, n) {
            return new A({
              ...this._def,
              checks: [
                ...this._def.checks,
                {
                  kind: e,
                  value: t,
                  inclusive: r,
                  message: i.errorUtil.toString(n),
                },
              ],
            });
          }
          _addCheck(e) {
            return new A({ ...this._def, checks: [...this._def.checks, e] });
          }
          int(e) {
            return this._addCheck({
              kind: "int",
              message: i.errorUtil.toString(e),
            });
          }
          positive(e) {
            return this._addCheck({
              kind: "min",
              value: 0,
              inclusive: !1,
              message: i.errorUtil.toString(e),
            });
          }
          negative(e) {
            return this._addCheck({
              kind: "max",
              value: 0,
              inclusive: !1,
              message: i.errorUtil.toString(e),
            });
          }
          nonpositive(e) {
            return this._addCheck({
              kind: "max",
              value: 0,
              inclusive: !0,
              message: i.errorUtil.toString(e),
            });
          }
          nonnegative(e) {
            return this._addCheck({
              kind: "min",
              value: 0,
              inclusive: !0,
              message: i.errorUtil.toString(e),
            });
          }
          multipleOf(e, t) {
            return this._addCheck({
              kind: "multipleOf",
              value: e,
              message: i.errorUtil.toString(t),
            });
          }
          finite(e) {
            return this._addCheck({
              kind: "finite",
              message: i.errorUtil.toString(e),
            });
          }
          safe(e) {
            return this._addCheck({
              kind: "min",
              inclusive: !0,
              value: Number.MIN_SAFE_INTEGER,
              message: i.errorUtil.toString(e),
            })._addCheck({
              kind: "max",
              inclusive: !0,
              value: Number.MAX_SAFE_INTEGER,
              message: i.errorUtil.toString(e),
            });
          }
          get minValue() {
            let e = null;
            for (const t of this._def.checks)
              "min" === t.kind && (null === e || t.value > e) && (e = t.value);
            return e;
          }
          get maxValue() {
            let e = null;
            for (const t of this._def.checks)
              "max" === t.kind && (null === e || t.value < e) && (e = t.value);
            return e;
          }
          get isInt() {
            return !!this._def.checks.find(
              (e) =>
                "int" === e.kind ||
                ("multipleOf" === e.kind && o.util.isInteger(e.value)),
            );
          }
          get isFinite() {
            let e = null,
              t = null;
            for (const r of this._def.checks) {
              if (
                "finite" === r.kind ||
                "int" === r.kind ||
                "multipleOf" === r.kind
              )
                return !0;
              "min" === r.kind
                ? (null === t || r.value > t) && (t = r.value)
                : "max" === r.kind &&
                  (null === e || r.value < e) &&
                  (e = r.value);
            }
            return Number.isFinite(t) && Number.isFinite(e);
          }
        }
        (t.ZodNumber = A),
          (A.create = (e) =>
            new A({
              checks: [],
              typeName: ae.ZodNumber,
              coerce: (null == e ? void 0 : e.coerce) || !1,
              ...u(e),
            }));
        class _ extends l {
          constructor() {
            super(...arguments), (this.min = this.gte), (this.max = this.lte);
          }
          _parse(e) {
            if (
              (this._def.coerce && (e.data = BigInt(e.data)),
              this._getType(e) !== o.ZodParsedType.bigint)
            ) {
              const t = this._getOrReturnCtx(e);
              return (
                (0, s.addIssueToContext)(t, {
                  code: a.ZodIssueCode.invalid_type,
                  expected: o.ZodParsedType.bigint,
                  received: t.parsedType,
                }),
                s.INVALID
              );
            }
            let t;
            const r = new s.ParseStatus();
            for (const n of this._def.checks)
              "min" === n.kind
                ? (n.inclusive ? e.data < n.value : e.data <= n.value) &&
                  ((t = this._getOrReturnCtx(e, t)),
                  (0, s.addIssueToContext)(t, {
                    code: a.ZodIssueCode.too_small,
                    type: "bigint",
                    minimum: n.value,
                    inclusive: n.inclusive,
                    message: n.message,
                  }),
                  r.dirty())
                : "max" === n.kind
                ? (n.inclusive ? e.data > n.value : e.data >= n.value) &&
                  ((t = this._getOrReturnCtx(e, t)),
                  (0, s.addIssueToContext)(t, {
                    code: a.ZodIssueCode.too_big,
                    type: "bigint",
                    maximum: n.value,
                    inclusive: n.inclusive,
                    message: n.message,
                  }),
                  r.dirty())
                : "multipleOf" === n.kind
                ? e.data % n.value !== BigInt(0) &&
                  ((t = this._getOrReturnCtx(e, t)),
                  (0, s.addIssueToContext)(t, {
                    code: a.ZodIssueCode.not_multiple_of,
                    multipleOf: n.value,
                    message: n.message,
                  }),
                  r.dirty())
                : o.util.assertNever(n);
            return { status: r.value, value: e.data };
          }
          gte(e, t) {
            return this.setLimit("min", e, !0, i.errorUtil.toString(t));
          }
          gt(e, t) {
            return this.setLimit("min", e, !1, i.errorUtil.toString(t));
          }
          lte(e, t) {
            return this.setLimit("max", e, !0, i.errorUtil.toString(t));
          }
          lt(e, t) {
            return this.setLimit("max", e, !1, i.errorUtil.toString(t));
          }
          setLimit(e, t, r, n) {
            return new _({
              ...this._def,
              checks: [
                ...this._def.checks,
                {
                  kind: e,
                  value: t,
                  inclusive: r,
                  message: i.errorUtil.toString(n),
                },
              ],
            });
          }
          _addCheck(e) {
            return new _({ ...this._def, checks: [...this._def.checks, e] });
          }
          positive(e) {
            return this._addCheck({
              kind: "min",
              value: BigInt(0),
              inclusive: !1,
              message: i.errorUtil.toString(e),
            });
          }
          negative(e) {
            return this._addCheck({
              kind: "max",
              value: BigInt(0),
              inclusive: !1,
              message: i.errorUtil.toString(e),
            });
          }
          nonpositive(e) {
            return this._addCheck({
              kind: "max",
              value: BigInt(0),
              inclusive: !0,
              message: i.errorUtil.toString(e),
            });
          }
          nonnegative(e) {
            return this._addCheck({
              kind: "min",
              value: BigInt(0),
              inclusive: !0,
              message: i.errorUtil.toString(e),
            });
          }
          multipleOf(e, t) {
            return this._addCheck({
              kind: "multipleOf",
              value: e,
              message: i.errorUtil.toString(t),
            });
          }
          get minValue() {
            let e = null;
            for (const t of this._def.checks)
              "min" === t.kind && (null === e || t.value > e) && (e = t.value);
            return e;
          }
          get maxValue() {
            let e = null;
            for (const t of this._def.checks)
              "max" === t.kind && (null === e || t.value < e) && (e = t.value);
            return e;
          }
        }
        (t.ZodBigInt = _),
          (_.create = (e) => {
            var t;
            return new _({
              checks: [],
              typeName: ae.ZodBigInt,
              coerce:
                null !== (t = null == e ? void 0 : e.coerce) &&
                void 0 !== t &&
                t,
              ...u(e),
            });
          });
        class T extends l {
          _parse(e) {
            if (
              (this._def.coerce && (e.data = Boolean(e.data)),
              this._getType(e) !== o.ZodParsedType.boolean)
            ) {
              const t = this._getOrReturnCtx(e);
              return (
                (0, s.addIssueToContext)(t, {
                  code: a.ZodIssueCode.invalid_type,
                  expected: o.ZodParsedType.boolean,
                  received: t.parsedType,
                }),
                s.INVALID
              );
            }
            return (0, s.OK)(e.data);
          }
        }
        (t.ZodBoolean = T),
          (T.create = (e) =>
            new T({
              typeName: ae.ZodBoolean,
              coerce: (null == e ? void 0 : e.coerce) || !1,
              ...u(e),
            }));
        class R extends l {
          _parse(e) {
            if (
              (this._def.coerce && (e.data = new Date(e.data)),
              this._getType(e) !== o.ZodParsedType.date)
            ) {
              const t = this._getOrReturnCtx(e);
              return (
                (0, s.addIssueToContext)(t, {
                  code: a.ZodIssueCode.invalid_type,
                  expected: o.ZodParsedType.date,
                  received: t.parsedType,
                }),
                s.INVALID
              );
            }
            if (isNaN(e.data.getTime())) {
              const t = this._getOrReturnCtx(e);
              return (
                (0, s.addIssueToContext)(t, {
                  code: a.ZodIssueCode.invalid_date,
                }),
                s.INVALID
              );
            }
            const t = new s.ParseStatus();
            let r;
            for (const n of this._def.checks)
              "min" === n.kind
                ? e.data.getTime() < n.value &&
                  ((r = this._getOrReturnCtx(e, r)),
                  (0, s.addIssueToContext)(r, {
                    code: a.ZodIssueCode.too_small,
                    message: n.message,
                    inclusive: !0,
                    exact: !1,
                    minimum: n.value,
                    type: "date",
                  }),
                  t.dirty())
                : "max" === n.kind
                ? e.data.getTime() > n.value &&
                  ((r = this._getOrReturnCtx(e, r)),
                  (0, s.addIssueToContext)(r, {
                    code: a.ZodIssueCode.too_big,
                    message: n.message,
                    inclusive: !0,
                    exact: !1,
                    maximum: n.value,
                    type: "date",
                  }),
                  t.dirty())
                : o.util.assertNever(n);
            return { status: t.value, value: new Date(e.data.getTime()) };
          }
          _addCheck(e) {
            return new R({ ...this._def, checks: [...this._def.checks, e] });
          }
          min(e, t) {
            return this._addCheck({
              kind: "min",
              value: e.getTime(),
              message: i.errorUtil.toString(t),
            });
          }
          max(e, t) {
            return this._addCheck({
              kind: "max",
              value: e.getTime(),
              message: i.errorUtil.toString(t),
            });
          }
          get minDate() {
            let e = null;
            for (const t of this._def.checks)
              "min" === t.kind && (null === e || t.value > e) && (e = t.value);
            return null != e ? new Date(e) : null;
          }
          get maxDate() {
            let e = null;
            for (const t of this._def.checks)
              "max" === t.kind && (null === e || t.value < e) && (e = t.value);
            return null != e ? new Date(e) : null;
          }
        }
        (t.ZodDate = R),
          (R.create = (e) =>
            new R({
              checks: [],
              coerce: (null == e ? void 0 : e.coerce) || !1,
              typeName: ae.ZodDate,
              ...u(e),
            }));
        class I extends l {
          _parse(e) {
            if (this._getType(e) !== o.ZodParsedType.symbol) {
              const t = this._getOrReturnCtx(e);
              return (
                (0, s.addIssueToContext)(t, {
                  code: a.ZodIssueCode.invalid_type,
                  expected: o.ZodParsedType.symbol,
                  received: t.parsedType,
                }),
                s.INVALID
              );
            }
            return (0, s.OK)(e.data);
          }
        }
        (t.ZodSymbol = I),
          (I.create = (e) => new I({ typeName: ae.ZodSymbol, ...u(e) }));
        class S extends l {
          _parse(e) {
            if (this._getType(e) !== o.ZodParsedType.undefined) {
              const t = this._getOrReturnCtx(e);
              return (
                (0, s.addIssueToContext)(t, {
                  code: a.ZodIssueCode.invalid_type,
                  expected: o.ZodParsedType.undefined,
                  received: t.parsedType,
                }),
                s.INVALID
              );
            }
            return (0, s.OK)(e.data);
          }
        }
        (t.ZodUndefined = S),
          (S.create = (e) => new S({ typeName: ae.ZodUndefined, ...u(e) }));
        class x extends l {
          _parse(e) {
            if (this._getType(e) !== o.ZodParsedType.null) {
              const t = this._getOrReturnCtx(e);
              return (
                (0, s.addIssueToContext)(t, {
                  code: a.ZodIssueCode.invalid_type,
                  expected: o.ZodParsedType.null,
                  received: t.parsedType,
                }),
                s.INVALID
              );
            }
            return (0, s.OK)(e.data);
          }
        }
        (t.ZodNull = x),
          (x.create = (e) => new x({ typeName: ae.ZodNull, ...u(e) }));
        class P extends l {
          constructor() {
            super(...arguments), (this._any = !0);
          }
          _parse(e) {
            return (0, s.OK)(e.data);
          }
        }
        (t.ZodAny = P),
          (P.create = (e) => new P({ typeName: ae.ZodAny, ...u(e) }));
        class O extends l {
          constructor() {
            super(...arguments), (this._unknown = !0);
          }
          _parse(e) {
            return (0, s.OK)(e.data);
          }
        }
        (t.ZodUnknown = O),
          (O.create = (e) => new O({ typeName: ae.ZodUnknown, ...u(e) }));
        class C extends l {
          _parse(e) {
            const t = this._getOrReturnCtx(e);
            return (
              (0, s.addIssueToContext)(t, {
                code: a.ZodIssueCode.invalid_type,
                expected: o.ZodParsedType.never,
                received: t.parsedType,
              }),
              s.INVALID
            );
          }
        }
        (t.ZodNever = C),
          (C.create = (e) => new C({ typeName: ae.ZodNever, ...u(e) }));
        class k extends l {
          _parse(e) {
            if (this._getType(e) !== o.ZodParsedType.undefined) {
              const t = this._getOrReturnCtx(e);
              return (
                (0, s.addIssueToContext)(t, {
                  code: a.ZodIssueCode.invalid_type,
                  expected: o.ZodParsedType.void,
                  received: t.parsedType,
                }),
                s.INVALID
              );
            }
            return (0, s.OK)(e.data);
          }
        }
        (t.ZodVoid = k),
          (k.create = (e) => new k({ typeName: ae.ZodVoid, ...u(e) }));
        class M extends l {
          _parse(e) {
            const { ctx: t, status: r } = this._processInputParams(e),
              n = this._def;
            if (t.parsedType !== o.ZodParsedType.array)
              return (
                (0, s.addIssueToContext)(t, {
                  code: a.ZodIssueCode.invalid_type,
                  expected: o.ZodParsedType.array,
                  received: t.parsedType,
                }),
                s.INVALID
              );
            if (null !== n.exactLength) {
              const e = t.data.length > n.exactLength.value,
                i = t.data.length < n.exactLength.value;
              (e || i) &&
                ((0, s.addIssueToContext)(t, {
                  code: e ? a.ZodIssueCode.too_big : a.ZodIssueCode.too_small,
                  minimum: i ? n.exactLength.value : void 0,
                  maximum: e ? n.exactLength.value : void 0,
                  type: "array",
                  inclusive: !0,
                  exact: !0,
                  message: n.exactLength.message,
                }),
                r.dirty());
            }
            if (
              (null !== n.minLength &&
                t.data.length < n.minLength.value &&
                ((0, s.addIssueToContext)(t, {
                  code: a.ZodIssueCode.too_small,
                  minimum: n.minLength.value,
                  type: "array",
                  inclusive: !0,
                  exact: !1,
                  message: n.minLength.message,
                }),
                r.dirty()),
              null !== n.maxLength &&
                t.data.length > n.maxLength.value &&
                ((0, s.addIssueToContext)(t, {
                  code: a.ZodIssueCode.too_big,
                  maximum: n.maxLength.value,
                  type: "array",
                  inclusive: !0,
                  exact: !1,
                  message: n.maxLength.message,
                }),
                r.dirty()),
              t.common.async)
            )
              return Promise.all(
                [...t.data].map((e, r) =>
                  n.type._parseAsync(new c(t, e, t.path, r)),
                ),
              ).then((e) => s.ParseStatus.mergeArray(r, e));
            const i = [...t.data].map((e, r) =>
              n.type._parseSync(new c(t, e, t.path, r)),
            );
            return s.ParseStatus.mergeArray(r, i);
          }
          get element() {
            return this._def.type;
          }
          min(e, t) {
            return new M({
              ...this._def,
              minLength: { value: e, message: i.errorUtil.toString(t) },
            });
          }
          max(e, t) {
            return new M({
              ...this._def,
              maxLength: { value: e, message: i.errorUtil.toString(t) },
            });
          }
          length(e, t) {
            return new M({
              ...this._def,
              exactLength: { value: e, message: i.errorUtil.toString(t) },
            });
          }
          nonempty(e) {
            return this.min(1, e);
          }
        }
        function N(e) {
          if (e instanceof B) {
            const t = {};
            for (const r in e.shape) {
              const n = e.shape[r];
              t[r] = Y.create(N(n));
            }
            return new B({ ...e._def, shape: () => t });
          }
          return e instanceof M
            ? new M({ ...e._def, type: N(e.element) })
            : e instanceof Y
            ? Y.create(N(e.unwrap()))
            : e instanceof ee
            ? ee.create(N(e.unwrap()))
            : e instanceof H
            ? H.create(e.items.map((e) => N(e)))
            : e;
        }
        (t.ZodArray = M),
          (M.create = (e, t) =>
            new M({
              type: e,
              minLength: null,
              maxLength: null,
              exactLength: null,
              typeName: ae.ZodArray,
              ...u(t),
            }));
        class B extends l {
          constructor() {
            super(...arguments),
              (this._cached = null),
              (this.nonstrict = this.passthrough),
              (this.augment = this.extend);
          }
          _getCached() {
            if (null !== this._cached) return this._cached;
            const e = this._def.shape(),
              t = o.util.objectKeys(e);
            return (this._cached = { shape: e, keys: t });
          }
          _parse(e) {
            if (this._getType(e) !== o.ZodParsedType.object) {
              const t = this._getOrReturnCtx(e);
              return (
                (0, s.addIssueToContext)(t, {
                  code: a.ZodIssueCode.invalid_type,
                  expected: o.ZodParsedType.object,
                  received: t.parsedType,
                }),
                s.INVALID
              );
            }
            const { status: t, ctx: r } = this._processInputParams(e),
              { shape: n, keys: i } = this._getCached(),
              d = [];
            if (
              !(
                this._def.catchall instanceof C &&
                "strip" === this._def.unknownKeys
              )
            )
              for (const e in r.data) i.includes(e) || d.push(e);
            const u = [];
            for (const e of i) {
              const t = n[e],
                i = r.data[e];
              u.push({
                key: { status: "valid", value: e },
                value: t._parse(new c(r, i, r.path, e)),
                alwaysSet: e in r.data,
              });
            }
            if (this._def.catchall instanceof C) {
              const e = this._def.unknownKeys;
              if ("passthrough" === e)
                for (const e of d)
                  u.push({
                    key: { status: "valid", value: e },
                    value: { status: "valid", value: r.data[e] },
                  });
              else if ("strict" === e)
                d.length > 0 &&
                  ((0, s.addIssueToContext)(r, {
                    code: a.ZodIssueCode.unrecognized_keys,
                    keys: d,
                  }),
                  t.dirty());
              else if ("strip" !== e)
                throw new Error(
                  "Internal ZodObject error: invalid unknownKeys value.",
                );
            } else {
              const e = this._def.catchall;
              for (const t of d) {
                const n = r.data[t];
                u.push({
                  key: { status: "valid", value: t },
                  value: e._parse(new c(r, n, r.path, t)),
                  alwaysSet: t in r.data,
                });
              }
            }
            return r.common.async
              ? Promise.resolve()
                  .then(async () => {
                    const e = [];
                    for (const t of u) {
                      const r = await t.key;
                      e.push({
                        key: r,
                        value: await t.value,
                        alwaysSet: t.alwaysSet,
                      });
                    }
                    return e;
                  })
                  .then((e) => s.ParseStatus.mergeObjectSync(t, e))
              : s.ParseStatus.mergeObjectSync(t, u);
          }
          get shape() {
            return this._def.shape();
          }
          strict(e) {
            return (
              i.errorUtil.errToObj,
              new B({
                ...this._def,
                unknownKeys: "strict",
                ...(void 0 !== e
                  ? {
                      errorMap: (t, r) => {
                        var n, s, o, a;
                        const c =
                          null !==
                            (o =
                              null === (s = (n = this._def).errorMap) ||
                              void 0 === s
                                ? void 0
                                : s.call(n, t, r).message) && void 0 !== o
                            ? o
                            : r.defaultError;
                        return "unrecognized_keys" === t.code
                          ? {
                              message:
                                null !==
                                  (a = i.errorUtil.errToObj(e).message) &&
                                void 0 !== a
                                  ? a
                                  : c,
                            }
                          : { message: c };
                      },
                    }
                  : {}),
              })
            );
          }
          strip() {
            return new B({ ...this._def, unknownKeys: "strip" });
          }
          passthrough() {
            return new B({ ...this._def, unknownKeys: "passthrough" });
          }
          extend(e) {
            return new B({
              ...this._def,
              shape: () => ({ ...this._def.shape(), ...e }),
            });
          }
          merge(e) {
            return new B({
              unknownKeys: e._def.unknownKeys,
              catchall: e._def.catchall,
              shape: () => ({ ...this._def.shape(), ...e._def.shape() }),
              typeName: ae.ZodObject,
            });
          }
          setKey(e, t) {
            return this.augment({ [e]: t });
          }
          catchall(e) {
            return new B({ ...this._def, catchall: e });
          }
          pick(e) {
            const t = {};
            return (
              o.util.objectKeys(e).forEach((r) => {
                e[r] && this.shape[r] && (t[r] = this.shape[r]);
              }),
              new B({ ...this._def, shape: () => t })
            );
          }
          omit(e) {
            const t = {};
            return (
              o.util.objectKeys(this.shape).forEach((r) => {
                e[r] || (t[r] = this.shape[r]);
              }),
              new B({ ...this._def, shape: () => t })
            );
          }
          deepPartial() {
            return N(this);
          }
          partial(e) {
            const t = {};
            return (
              o.util.objectKeys(this.shape).forEach((r) => {
                const n = this.shape[r];
                e && !e[r] ? (t[r] = n) : (t[r] = n.optional());
              }),
              new B({ ...this._def, shape: () => t })
            );
          }
          required(e) {
            const t = {};
            return (
              o.util.objectKeys(this.shape).forEach((r) => {
                if (e && !e[r]) t[r] = this.shape[r];
                else {
                  let e = this.shape[r];
                  for (; e instanceof Y; ) e = e._def.innerType;
                  t[r] = e;
                }
              }),
              new B({ ...this._def, shape: () => t })
            );
          }
          keyof() {
            return K(o.util.objectKeys(this.shape));
          }
        }
        (t.ZodObject = B),
          (B.create = (e, t) =>
            new B({
              shape: () => e,
              unknownKeys: "strip",
              catchall: C.create(),
              typeName: ae.ZodObject,
              ...u(t),
            })),
          (B.strictCreate = (e, t) =>
            new B({
              shape: () => e,
              unknownKeys: "strict",
              catchall: C.create(),
              typeName: ae.ZodObject,
              ...u(t),
            })),
          (B.lazycreate = (e, t) =>
            new B({
              shape: e,
              unknownKeys: "strip",
              catchall: C.create(),
              typeName: ae.ZodObject,
              ...u(t),
            }));
        class D extends l {
          _parse(e) {
            const { ctx: t } = this._processInputParams(e),
              r = this._def.options;
            if (t.common.async)
              return Promise.all(
                r.map(async (e) => {
                  const r = {
                    ...t,
                    common: { ...t.common, issues: [] },
                    parent: null,
                  };
                  return {
                    result: await e._parseAsync({
                      data: t.data,
                      path: t.path,
                      parent: r,
                    }),
                    ctx: r,
                  };
                }),
              ).then(function (e) {
                for (const t of e)
                  if ("valid" === t.result.status) return t.result;
                for (const r of e)
                  if ("dirty" === r.result.status)
                    return (
                      t.common.issues.push(...r.ctx.common.issues), r.result
                    );
                const r = e.map((e) => new a.ZodError(e.ctx.common.issues));
                return (
                  (0, s.addIssueToContext)(t, {
                    code: a.ZodIssueCode.invalid_union,
                    unionErrors: r,
                  }),
                  s.INVALID
                );
              });
            {
              let e;
              const n = [];
              for (const i of r) {
                const r = {
                    ...t,
                    common: { ...t.common, issues: [] },
                    parent: null,
                  },
                  s = i._parseSync({ data: t.data, path: t.path, parent: r });
                if ("valid" === s.status) return s;
                "dirty" !== s.status || e || (e = { result: s, ctx: r }),
                  r.common.issues.length && n.push(r.common.issues);
              }
              if (e)
                return t.common.issues.push(...e.ctx.common.issues), e.result;
              const i = n.map((e) => new a.ZodError(e));
              return (
                (0, s.addIssueToContext)(t, {
                  code: a.ZodIssueCode.invalid_union,
                  unionErrors: i,
                }),
                s.INVALID
              );
            }
          }
          get options() {
            return this._def.options;
          }
        }
        (t.ZodUnion = D),
          (D.create = (e, t) =>
            new D({ options: e, typeName: ae.ZodUnion, ...u(t) }));
        const j = (e) =>
          e instanceof Z
            ? j(e.schema)
            : e instanceof $
            ? j(e.innerType())
            : e instanceof z
            ? [e.value]
            : e instanceof J
            ? e.options
            : e instanceof X
            ? Object.keys(e.enum)
            : e instanceof te
            ? j(e._def.innerType)
            : e instanceof S
            ? [void 0]
            : e instanceof x
            ? [null]
            : null;
        class L extends l {
          _parse(e) {
            const { ctx: t } = this._processInputParams(e);
            if (t.parsedType !== o.ZodParsedType.object)
              return (
                (0, s.addIssueToContext)(t, {
                  code: a.ZodIssueCode.invalid_type,
                  expected: o.ZodParsedType.object,
                  received: t.parsedType,
                }),
                s.INVALID
              );
            const r = this.discriminator,
              n = t.data[r],
              i = this.optionsMap.get(n);
            return i
              ? t.common.async
                ? i._parseAsync({ data: t.data, path: t.path, parent: t })
                : i._parseSync({ data: t.data, path: t.path, parent: t })
              : ((0, s.addIssueToContext)(t, {
                  code: a.ZodIssueCode.invalid_union_discriminator,
                  options: Array.from(this.optionsMap.keys()),
                  path: [r],
                }),
                s.INVALID);
          }
          get discriminator() {
            return this._def.discriminator;
          }
          get options() {
            return this._def.options;
          }
          get optionsMap() {
            return this._def.optionsMap;
          }
          static create(e, t, r) {
            const n = new Map();
            for (const r of t) {
              const t = j(r.shape[e]);
              if (!t)
                throw new Error(
                  `A discriminator value for key \`${e}\` could not be extracted from all schema options`,
                );
              for (const i of t) {
                if (n.has(i))
                  throw new Error(
                    `Discriminator property ${String(
                      e,
                    )} has duplicate value ${String(i)}`,
                  );
                n.set(i, r);
              }
            }
            return new L({
              typeName: ae.ZodDiscriminatedUnion,
              discriminator: e,
              options: t,
              optionsMap: n,
              ...u(r),
            });
          }
        }
        function U(e, t) {
          const r = (0, o.getParsedType)(e),
            n = (0, o.getParsedType)(t);
          if (e === t) return { valid: !0, data: e };
          if (r === o.ZodParsedType.object && n === o.ZodParsedType.object) {
            const r = o.util.objectKeys(t),
              n = o.util.objectKeys(e).filter((e) => -1 !== r.indexOf(e)),
              i = { ...e, ...t };
            for (const r of n) {
              const n = U(e[r], t[r]);
              if (!n.valid) return { valid: !1 };
              i[r] = n.data;
            }
            return { valid: !0, data: i };
          }
          if (r === o.ZodParsedType.array && n === o.ZodParsedType.array) {
            if (e.length !== t.length) return { valid: !1 };
            const r = [];
            for (let n = 0; n < e.length; n++) {
              const i = U(e[n], t[n]);
              if (!i.valid) return { valid: !1 };
              r.push(i.data);
            }
            return { valid: !0, data: r };
          }
          return r === o.ZodParsedType.date &&
            n === o.ZodParsedType.date &&
            +e == +t
            ? { valid: !0, data: e }
            : { valid: !1 };
        }
        t.ZodDiscriminatedUnion = L;
        class F extends l {
          _parse(e) {
            const { status: t, ctx: r } = this._processInputParams(e),
              n = (e, n) => {
                if ((0, s.isAborted)(e) || (0, s.isAborted)(n))
                  return s.INVALID;
                const i = U(e.value, n.value);
                return i.valid
                  ? (((0, s.isDirty)(e) || (0, s.isDirty)(n)) && t.dirty(),
                    { status: t.value, value: i.data })
                  : ((0, s.addIssueToContext)(r, {
                      code: a.ZodIssueCode.invalid_intersection_types,
                    }),
                    s.INVALID);
              };
            return r.common.async
              ? Promise.all([
                  this._def.left._parseAsync({
                    data: r.data,
                    path: r.path,
                    parent: r,
                  }),
                  this._def.right._parseAsync({
                    data: r.data,
                    path: r.path,
                    parent: r,
                  }),
                ]).then(([e, t]) => n(e, t))
              : n(
                  this._def.left._parseSync({
                    data: r.data,
                    path: r.path,
                    parent: r,
                  }),
                  this._def.right._parseSync({
                    data: r.data,
                    path: r.path,
                    parent: r,
                  }),
                );
          }
        }
        (t.ZodIntersection = F),
          (F.create = (e, t, r) =>
            new F({
              left: e,
              right: t,
              typeName: ae.ZodIntersection,
              ...u(r),
            }));
        class H extends l {
          _parse(e) {
            const { status: t, ctx: r } = this._processInputParams(e);
            if (r.parsedType !== o.ZodParsedType.array)
              return (
                (0, s.addIssueToContext)(r, {
                  code: a.ZodIssueCode.invalid_type,
                  expected: o.ZodParsedType.array,
                  received: r.parsedType,
                }),
                s.INVALID
              );
            if (r.data.length < this._def.items.length)
              return (
                (0, s.addIssueToContext)(r, {
                  code: a.ZodIssueCode.too_small,
                  minimum: this._def.items.length,
                  inclusive: !0,
                  exact: !1,
                  type: "array",
                }),
                s.INVALID
              );
            !this._def.rest &&
              r.data.length > this._def.items.length &&
              ((0, s.addIssueToContext)(r, {
                code: a.ZodIssueCode.too_big,
                maximum: this._def.items.length,
                inclusive: !0,
                exact: !1,
                type: "array",
              }),
              t.dirty());
            const n = [...r.data]
              .map((e, t) => {
                const n = this._def.items[t] || this._def.rest;
                return n ? n._parse(new c(r, e, r.path, t)) : null;
              })
              .filter((e) => !!e);
            return r.common.async
              ? Promise.all(n).then((e) => s.ParseStatus.mergeArray(t, e))
              : s.ParseStatus.mergeArray(t, n);
          }
          get items() {
            return this._def.items;
          }
          rest(e) {
            return new H({ ...this._def, rest: e });
          }
        }
        (t.ZodTuple = H),
          (H.create = (e, t) => {
            if (!Array.isArray(e))
              throw new Error(
                "You must pass an array of schemas to z.tuple([ ... ])",
              );
            return new H({
              items: e,
              typeName: ae.ZodTuple,
              rest: null,
              ...u(t),
            });
          });
        class G extends l {
          get keySchema() {
            return this._def.keyType;
          }
          get valueSchema() {
            return this._def.valueType;
          }
          _parse(e) {
            const { status: t, ctx: r } = this._processInputParams(e);
            if (r.parsedType !== o.ZodParsedType.object)
              return (
                (0, s.addIssueToContext)(r, {
                  code: a.ZodIssueCode.invalid_type,
                  expected: o.ZodParsedType.object,
                  received: r.parsedType,
                }),
                s.INVALID
              );
            const n = [],
              i = this._def.keyType,
              d = this._def.valueType;
            for (const e in r.data)
              n.push({
                key: i._parse(new c(r, e, r.path, e)),
                value: d._parse(new c(r, r.data[e], r.path, e)),
              });
            return r.common.async
              ? s.ParseStatus.mergeObjectAsync(t, n)
              : s.ParseStatus.mergeObjectSync(t, n);
          }
          get element() {
            return this._def.valueType;
          }
          static create(e, t, r) {
            return new G(
              t instanceof l
                ? { keyType: e, valueType: t, typeName: ae.ZodRecord, ...u(r) }
                : {
                    keyType: w.create(),
                    valueType: e,
                    typeName: ae.ZodRecord,
                    ...u(t),
                  },
            );
          }
        }
        t.ZodRecord = G;
        class V extends l {
          get keySchema() {
            return this._def.keyType;
          }
          get valueSchema() {
            return this._def.valueType;
          }
          _parse(e) {
            const { status: t, ctx: r } = this._processInputParams(e);
            if (r.parsedType !== o.ZodParsedType.map)
              return (
                (0, s.addIssueToContext)(r, {
                  code: a.ZodIssueCode.invalid_type,
                  expected: o.ZodParsedType.map,
                  received: r.parsedType,
                }),
                s.INVALID
              );
            const n = this._def.keyType,
              i = this._def.valueType,
              d = [...r.data.entries()].map(([e, t], s) => ({
                key: n._parse(new c(r, e, r.path, [s, "key"])),
                value: i._parse(new c(r, t, r.path, [s, "value"])),
              }));
            if (r.common.async) {
              const e = new Map();
              return Promise.resolve().then(async () => {
                for (const r of d) {
                  const n = await r.key,
                    i = await r.value;
                  if ("aborted" === n.status || "aborted" === i.status)
                    return s.INVALID;
                  ("dirty" !== n.status && "dirty" !== i.status) || t.dirty(),
                    e.set(n.value, i.value);
                }
                return { status: t.value, value: e };
              });
            }
            {
              const e = new Map();
              for (const r of d) {
                const n = r.key,
                  i = r.value;
                if ("aborted" === n.status || "aborted" === i.status)
                  return s.INVALID;
                ("dirty" !== n.status && "dirty" !== i.status) || t.dirty(),
                  e.set(n.value, i.value);
              }
              return { status: t.value, value: e };
            }
          }
        }
        (t.ZodMap = V),
          (V.create = (e, t, r) =>
            new V({ valueType: t, keyType: e, typeName: ae.ZodMap, ...u(r) }));
        class W extends l {
          _parse(e) {
            const { status: t, ctx: r } = this._processInputParams(e);
            if (r.parsedType !== o.ZodParsedType.set)
              return (
                (0, s.addIssueToContext)(r, {
                  code: a.ZodIssueCode.invalid_type,
                  expected: o.ZodParsedType.set,
                  received: r.parsedType,
                }),
                s.INVALID
              );
            const n = this._def;
            null !== n.minSize &&
              r.data.size < n.minSize.value &&
              ((0, s.addIssueToContext)(r, {
                code: a.ZodIssueCode.too_small,
                minimum: n.minSize.value,
                type: "set",
                inclusive: !0,
                exact: !1,
                message: n.minSize.message,
              }),
              t.dirty()),
              null !== n.maxSize &&
                r.data.size > n.maxSize.value &&
                ((0, s.addIssueToContext)(r, {
                  code: a.ZodIssueCode.too_big,
                  maximum: n.maxSize.value,
                  type: "set",
                  inclusive: !0,
                  exact: !1,
                  message: n.maxSize.message,
                }),
                t.dirty());
            const i = this._def.valueType;
            function d(e) {
              const r = new Set();
              for (const n of e) {
                if ("aborted" === n.status) return s.INVALID;
                "dirty" === n.status && t.dirty(), r.add(n.value);
              }
              return { status: t.value, value: r };
            }
            const u = [...r.data.values()].map((e, t) =>
              i._parse(new c(r, e, r.path, t)),
            );
            return r.common.async ? Promise.all(u).then((e) => d(e)) : d(u);
          }
          min(e, t) {
            return new W({
              ...this._def,
              minSize: { value: e, message: i.errorUtil.toString(t) },
            });
          }
          max(e, t) {
            return new W({
              ...this._def,
              maxSize: { value: e, message: i.errorUtil.toString(t) },
            });
          }
          size(e, t) {
            return this.min(e, t).max(e, t);
          }
          nonempty(e) {
            return this.min(1, e);
          }
        }
        (t.ZodSet = W),
          (W.create = (e, t) =>
            new W({
              valueType: e,
              minSize: null,
              maxSize: null,
              typeName: ae.ZodSet,
              ...u(t),
            }));
        class q extends l {
          constructor() {
            super(...arguments), (this.validate = this.implement);
          }
          _parse(e) {
            const { ctx: t } = this._processInputParams(e);
            if (t.parsedType !== o.ZodParsedType.function)
              return (
                (0, s.addIssueToContext)(t, {
                  code: a.ZodIssueCode.invalid_type,
                  expected: o.ZodParsedType.function,
                  received: t.parsedType,
                }),
                s.INVALID
              );
            function r(e, r) {
              return (0, s.makeIssue)({
                data: e,
                path: t.path,
                errorMaps: [
                  t.common.contextualErrorMap,
                  t.schemaErrorMap,
                  (0, n.getErrorMap)(),
                  n.defaultErrorMap,
                ].filter((e) => !!e),
                issueData: {
                  code: a.ZodIssueCode.invalid_arguments,
                  argumentsError: r,
                },
              });
            }
            function i(e, r) {
              return (0, s.makeIssue)({
                data: e,
                path: t.path,
                errorMaps: [
                  t.common.contextualErrorMap,
                  t.schemaErrorMap,
                  (0, n.getErrorMap)(),
                  n.defaultErrorMap,
                ].filter((e) => !!e),
                issueData: {
                  code: a.ZodIssueCode.invalid_return_type,
                  returnTypeError: r,
                },
              });
            }
            const c = { errorMap: t.common.contextualErrorMap },
              d = t.data;
            return this._def.returns instanceof Q
              ? (0, s.OK)(async (...e) => {
                  const t = new a.ZodError([]),
                    n = await this._def.args.parseAsync(e, c).catch((n) => {
                      throw (t.addIssue(r(e, n)), t);
                    }),
                    s = await d(...n);
                  return await this._def.returns._def.type
                    .parseAsync(s, c)
                    .catch((e) => {
                      throw (t.addIssue(i(s, e)), t);
                    });
                })
              : (0, s.OK)((...e) => {
                  const t = this._def.args.safeParse(e, c);
                  if (!t.success) throw new a.ZodError([r(e, t.error)]);
                  const n = d(...t.data),
                    s = this._def.returns.safeParse(n, c);
                  if (!s.success) throw new a.ZodError([i(n, s.error)]);
                  return s.data;
                });
          }
          parameters() {
            return this._def.args;
          }
          returnType() {
            return this._def.returns;
          }
          args(...e) {
            return new q({ ...this._def, args: H.create(e).rest(O.create()) });
          }
          returns(e) {
            return new q({ ...this._def, returns: e });
          }
          implement(e) {
            return this.parse(e);
          }
          strictImplement(e) {
            return this.parse(e);
          }
          static create(e, t, r) {
            return new q({
              args: e || H.create([]).rest(O.create()),
              returns: t || O.create(),
              typeName: ae.ZodFunction,
              ...u(r),
            });
          }
        }
        t.ZodFunction = q;
        class Z extends l {
          get schema() {
            return this._def.getter();
          }
          _parse(e) {
            const { ctx: t } = this._processInputParams(e);
            return this._def
              .getter()
              ._parse({ data: t.data, path: t.path, parent: t });
          }
        }
        (t.ZodLazy = Z),
          (Z.create = (e, t) =>
            new Z({ getter: e, typeName: ae.ZodLazy, ...u(t) }));
        class z extends l {
          _parse(e) {
            if (e.data !== this._def.value) {
              const t = this._getOrReturnCtx(e);
              return (
                (0, s.addIssueToContext)(t, {
                  received: t.data,
                  code: a.ZodIssueCode.invalid_literal,
                  expected: this._def.value,
                }),
                s.INVALID
              );
            }
            return { status: "valid", value: e.data };
          }
          get value() {
            return this._def.value;
          }
        }
        function K(e, t) {
          return new J({ values: e, typeName: ae.ZodEnum, ...u(t) });
        }
        (t.ZodLiteral = z),
          (z.create = (e, t) =>
            new z({ value: e, typeName: ae.ZodLiteral, ...u(t) }));
        class J extends l {
          _parse(e) {
            if ("string" != typeof e.data) {
              const t = this._getOrReturnCtx(e),
                r = this._def.values;
              return (
                (0, s.addIssueToContext)(t, {
                  expected: o.util.joinValues(r),
                  received: t.parsedType,
                  code: a.ZodIssueCode.invalid_type,
                }),
                s.INVALID
              );
            }
            if (-1 === this._def.values.indexOf(e.data)) {
              const t = this._getOrReturnCtx(e),
                r = this._def.values;
              return (
                (0, s.addIssueToContext)(t, {
                  received: t.data,
                  code: a.ZodIssueCode.invalid_enum_value,
                  options: r,
                }),
                s.INVALID
              );
            }
            return (0, s.OK)(e.data);
          }
          get options() {
            return this._def.values;
          }
          get enum() {
            const e = {};
            for (const t of this._def.values) e[t] = t;
            return e;
          }
          get Values() {
            const e = {};
            for (const t of this._def.values) e[t] = t;
            return e;
          }
          get Enum() {
            const e = {};
            for (const t of this._def.values) e[t] = t;
            return e;
          }
          extract(e) {
            return J.create(e);
          }
          exclude(e) {
            return J.create(this.options.filter((t) => !e.includes(t)));
          }
        }
        (t.ZodEnum = J), (J.create = K);
        class X extends l {
          _parse(e) {
            const t = o.util.getValidEnumValues(this._def.values),
              r = this._getOrReturnCtx(e);
            if (
              r.parsedType !== o.ZodParsedType.string &&
              r.parsedType !== o.ZodParsedType.number
            ) {
              const e = o.util.objectValues(t);
              return (
                (0, s.addIssueToContext)(r, {
                  expected: o.util.joinValues(e),
                  received: r.parsedType,
                  code: a.ZodIssueCode.invalid_type,
                }),
                s.INVALID
              );
            }
            if (-1 === t.indexOf(e.data)) {
              const e = o.util.objectValues(t);
              return (
                (0, s.addIssueToContext)(r, {
                  received: r.data,
                  code: a.ZodIssueCode.invalid_enum_value,
                  options: e,
                }),
                s.INVALID
              );
            }
            return (0, s.OK)(e.data);
          }
          get enum() {
            return this._def.values;
          }
        }
        (t.ZodNativeEnum = X),
          (X.create = (e, t) =>
            new X({ values: e, typeName: ae.ZodNativeEnum, ...u(t) }));
        class Q extends l {
          unwrap() {
            return this._def.type;
          }
          _parse(e) {
            const { ctx: t } = this._processInputParams(e);
            if (
              t.parsedType !== o.ZodParsedType.promise &&
              !1 === t.common.async
            )
              return (
                (0, s.addIssueToContext)(t, {
                  code: a.ZodIssueCode.invalid_type,
                  expected: o.ZodParsedType.promise,
                  received: t.parsedType,
                }),
                s.INVALID
              );
            const r =
              t.parsedType === o.ZodParsedType.promise
                ? t.data
                : Promise.resolve(t.data);
            return (0, s.OK)(
              r.then((e) =>
                this._def.type.parseAsync(e, {
                  path: t.path,
                  errorMap: t.common.contextualErrorMap,
                }),
              ),
            );
          }
        }
        (t.ZodPromise = Q),
          (Q.create = (e, t) =>
            new Q({ type: e, typeName: ae.ZodPromise, ...u(t) }));
        class $ extends l {
          innerType() {
            return this._def.schema;
          }
          sourceType() {
            return this._def.schema._def.typeName === ae.ZodEffects
              ? this._def.schema.sourceType()
              : this._def.schema;
          }
          _parse(e) {
            const { status: t, ctx: r } = this._processInputParams(e),
              n = this._def.effect || null,
              i = {
                addIssue: (e) => {
                  (0, s.addIssueToContext)(r, e),
                    e.fatal ? t.abort() : t.dirty();
                },
                get path() {
                  return r.path;
                },
              };
            if (((i.addIssue = i.addIssue.bind(i)), "preprocess" === n.type)) {
              const e = n.transform(r.data, i);
              return r.common.issues.length
                ? { status: "dirty", value: r.data }
                : r.common.async
                ? Promise.resolve(e).then((e) =>
                    this._def.schema._parseAsync({
                      data: e,
                      path: r.path,
                      parent: r,
                    }),
                  )
                : this._def.schema._parseSync({
                    data: e,
                    path: r.path,
                    parent: r,
                  });
            }
            if ("refinement" === n.type) {
              const e = (e) => {
                const t = n.refinement(e, i);
                if (r.common.async) return Promise.resolve(t);
                if (t instanceof Promise)
                  throw new Error(
                    "Async refinement encountered during synchronous parse operation. Use .parseAsync instead.",
                  );
                return e;
              };
              if (!1 === r.common.async) {
                const n = this._def.schema._parseSync({
                  data: r.data,
                  path: r.path,
                  parent: r,
                });
                return "aborted" === n.status
                  ? s.INVALID
                  : ("dirty" === n.status && t.dirty(),
                    e(n.value),
                    { status: t.value, value: n.value });
              }
              return this._def.schema
                ._parseAsync({ data: r.data, path: r.path, parent: r })
                .then((r) =>
                  "aborted" === r.status
                    ? s.INVALID
                    : ("dirty" === r.status && t.dirty(),
                      e(r.value).then(() => ({
                        status: t.value,
                        value: r.value,
                      }))),
                );
            }
            if ("transform" === n.type) {
              if (!1 === r.common.async) {
                const e = this._def.schema._parseSync({
                  data: r.data,
                  path: r.path,
                  parent: r,
                });
                if (!(0, s.isValid)(e)) return e;
                const o = n.transform(e.value, i);
                if (o instanceof Promise)
                  throw new Error(
                    "Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.",
                  );
                return { status: t.value, value: o };
              }
              return this._def.schema
                ._parseAsync({ data: r.data, path: r.path, parent: r })
                .then((e) =>
                  (0, s.isValid)(e)
                    ? Promise.resolve(n.transform(e.value, i)).then((e) => ({
                        status: t.value,
                        value: e,
                      }))
                    : e,
                );
            }
            o.util.assertNever(n);
          }
        }
        (t.ZodEffects = $),
          (t.ZodTransformer = $),
          ($.create = (e, t, r) =>
            new $({ schema: e, typeName: ae.ZodEffects, effect: t, ...u(r) })),
          ($.createWithPreprocess = (e, t, r) =>
            new $({
              schema: t,
              effect: { type: "preprocess", transform: e },
              typeName: ae.ZodEffects,
              ...u(r),
            }));
        class Y extends l {
          _parse(e) {
            return this._getType(e) === o.ZodParsedType.undefined
              ? (0, s.OK)(void 0)
              : this._def.innerType._parse(e);
          }
          unwrap() {
            return this._def.innerType;
          }
        }
        (t.ZodOptional = Y),
          (Y.create = (e, t) =>
            new Y({ innerType: e, typeName: ae.ZodOptional, ...u(t) }));
        class ee extends l {
          _parse(e) {
            return this._getType(e) === o.ZodParsedType.null
              ? (0, s.OK)(null)
              : this._def.innerType._parse(e);
          }
          unwrap() {
            return this._def.innerType;
          }
        }
        (t.ZodNullable = ee),
          (ee.create = (e, t) =>
            new ee({ innerType: e, typeName: ae.ZodNullable, ...u(t) }));
        class te extends l {
          _parse(e) {
            const { ctx: t } = this._processInputParams(e);
            let r = t.data;
            return (
              t.parsedType === o.ZodParsedType.undefined &&
                (r = this._def.defaultValue()),
              this._def.innerType._parse({ data: r, path: t.path, parent: t })
            );
          }
          removeDefault() {
            return this._def.innerType;
          }
        }
        (t.ZodDefault = te),
          (te.create = (e, t) =>
            new te({
              innerType: e,
              typeName: ae.ZodDefault,
              defaultValue:
                "function" == typeof t.default ? t.default : () => t.default,
              ...u(t),
            }));
        class re extends l {
          _parse(e) {
            const { ctx: t } = this._processInputParams(e),
              r = { ...t, common: { ...t.common, issues: [] } },
              n = this._def.innerType._parse({
                data: r.data,
                path: r.path,
                parent: { ...r },
              });
            return (0, s.isAsync)(n)
              ? n.then((e) => ({
                  status: "valid",
                  value:
                    "valid" === e.status
                      ? e.value
                      : this._def.catchValue({
                          get error() {
                            return new a.ZodError(r.common.issues);
                          },
                          input: r.data,
                        }),
                }))
              : {
                  status: "valid",
                  value:
                    "valid" === n.status
                      ? n.value
                      : this._def.catchValue({
                          get error() {
                            return new a.ZodError(r.common.issues);
                          },
                          input: r.data,
                        }),
                };
          }
          removeCatch() {
            return this._def.innerType;
          }
        }
        (t.ZodCatch = re),
          (re.create = (e, t) =>
            new re({
              innerType: e,
              typeName: ae.ZodCatch,
              catchValue:
                "function" == typeof t.catch ? t.catch : () => t.catch,
              ...u(t),
            }));
        class ne extends l {
          _parse(e) {
            if (this._getType(e) !== o.ZodParsedType.nan) {
              const t = this._getOrReturnCtx(e);
              return (
                (0, s.addIssueToContext)(t, {
                  code: a.ZodIssueCode.invalid_type,
                  expected: o.ZodParsedType.nan,
                  received: t.parsedType,
                }),
                s.INVALID
              );
            }
            return { status: "valid", value: e.data };
          }
        }
        (t.ZodNaN = ne),
          (ne.create = (e) => new ne({ typeName: ae.ZodNaN, ...u(e) })),
          (t.BRAND = Symbol("zod_brand"));
        class ie extends l {
          _parse(e) {
            const { ctx: t } = this._processInputParams(e),
              r = t.data;
            return this._def.type._parse({ data: r, path: t.path, parent: t });
          }
          unwrap() {
            return this._def.type;
          }
        }
        t.ZodBranded = ie;
        class se extends l {
          _parse(e) {
            const { status: t, ctx: r } = this._processInputParams(e);
            if (r.common.async)
              return (async () => {
                const e = await this._def.in._parseAsync({
                  data: r.data,
                  path: r.path,
                  parent: r,
                });
                return "aborted" === e.status
                  ? s.INVALID
                  : "dirty" === e.status
                  ? (t.dirty(), (0, s.DIRTY)(e.value))
                  : this._def.out._parseAsync({
                      data: e.value,
                      path: r.path,
                      parent: r,
                    });
              })();
            {
              const e = this._def.in._parseSync({
                data: r.data,
                path: r.path,
                parent: r,
              });
              return "aborted" === e.status
                ? s.INVALID
                : "dirty" === e.status
                ? (t.dirty(), { status: "dirty", value: e.value })
                : this._def.out._parseSync({
                    data: e.value,
                    path: r.path,
                    parent: r,
                  });
            }
          }
          static create(e, t) {
            return new se({ in: e, out: t, typeName: ae.ZodPipeline });
          }
        }
        t.ZodPipeline = se;
        class oe extends l {
          _parse(e) {
            const t = this._def.innerType._parse(e);
            return (0, s.isValid)(t) && (t.value = Object.freeze(t.value)), t;
          }
        }
        var ae;
        (t.ZodReadonly = oe),
          (oe.create = (e, t) =>
            new oe({ innerType: e, typeName: ae.ZodReadonly, ...u(t) })),
          (t.custom = (e, t = {}, r) =>
            e
              ? P.create().superRefine((n, i) => {
                  var s, o;
                  if (!e(n)) {
                    const e =
                        "function" == typeof t
                          ? t(n)
                          : "string" == typeof t
                          ? { message: t }
                          : t,
                      a =
                        null ===
                          (o =
                            null !== (s = e.fatal) && void 0 !== s ? s : r) ||
                        void 0 === o ||
                        o,
                      c = "string" == typeof e ? { message: e } : e;
                    i.addIssue({ code: "custom", ...c, fatal: a });
                  }
                })
              : P.create()),
          (t.late = { object: B.lazycreate }),
          (function (e) {
            (e.ZodString = "ZodString"),
              (e.ZodNumber = "ZodNumber"),
              (e.ZodNaN = "ZodNaN"),
              (e.ZodBigInt = "ZodBigInt"),
              (e.ZodBoolean = "ZodBoolean"),
              (e.ZodDate = "ZodDate"),
              (e.ZodSymbol = "ZodSymbol"),
              (e.ZodUndefined = "ZodUndefined"),
              (e.ZodNull = "ZodNull"),
              (e.ZodAny = "ZodAny"),
              (e.ZodUnknown = "ZodUnknown"),
              (e.ZodNever = "ZodNever"),
              (e.ZodVoid = "ZodVoid"),
              (e.ZodArray = "ZodArray"),
              (e.ZodObject = "ZodObject"),
              (e.ZodUnion = "ZodUnion"),
              (e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion"),
              (e.ZodIntersection = "ZodIntersection"),
              (e.ZodTuple = "ZodTuple"),
              (e.ZodRecord = "ZodRecord"),
              (e.ZodMap = "ZodMap"),
              (e.ZodSet = "ZodSet"),
              (e.ZodFunction = "ZodFunction"),
              (e.ZodLazy = "ZodLazy"),
              (e.ZodLiteral = "ZodLiteral"),
              (e.ZodEnum = "ZodEnum"),
              (e.ZodEffects = "ZodEffects"),
              (e.ZodNativeEnum = "ZodNativeEnum"),
              (e.ZodOptional = "ZodOptional"),
              (e.ZodNullable = "ZodNullable"),
              (e.ZodDefault = "ZodDefault"),
              (e.ZodCatch = "ZodCatch"),
              (e.ZodPromise = "ZodPromise"),
              (e.ZodBranded = "ZodBranded"),
              (e.ZodPipeline = "ZodPipeline"),
              (e.ZodReadonly = "ZodReadonly");
          })((ae = t.ZodFirstPartyTypeKind || (t.ZodFirstPartyTypeKind = {}))),
          (t.instanceof = (
            e,
            r = { message: `Input not instance of ${e.name}` },
          ) => (0, t.custom)((t) => t instanceof e, r));
        const ce = w.create;
        t.string = ce;
        const de = A.create;
        t.number = de;
        const ue = ne.create;
        t.nan = ue;
        const le = _.create;
        t.bigint = le;
        const he = T.create;
        t.boolean = he;
        const fe = R.create;
        t.date = fe;
        const pe = I.create;
        t.symbol = pe;
        const me = S.create;
        t.undefined = me;
        const ye = x.create;
        t.null = ye;
        const ge = P.create;
        t.any = ge;
        const ve = O.create;
        t.unknown = ve;
        const be = C.create;
        t.never = be;
        const we = k.create;
        t.void = we;
        const Ee = M.create;
        t.array = Ee;
        const Ae = B.create;
        t.object = Ae;
        const _e = B.strictCreate;
        t.strictObject = _e;
        const Te = D.create;
        t.union = Te;
        const Re = L.create;
        t.discriminatedUnion = Re;
        const Ie = F.create;
        t.intersection = Ie;
        const Se = H.create;
        t.tuple = Se;
        const xe = G.create;
        t.record = xe;
        const Pe = V.create;
        t.map = Pe;
        const Oe = W.create;
        t.set = Oe;
        const Ce = q.create;
        t.function = Ce;
        const ke = Z.create;
        t.lazy = ke;
        const Me = z.create;
        t.literal = Me;
        const Ne = J.create;
        t.enum = Ne;
        const Be = X.create;
        t.nativeEnum = Be;
        const De = Q.create;
        t.promise = De;
        const je = $.create;
        (t.effect = je), (t.transformer = je);
        const Le = Y.create;
        t.optional = Le;
        const Ue = ee.create;
        t.nullable = Ue;
        const Fe = $.createWithPreprocess;
        t.preprocess = Fe;
        const He = se.create;
        (t.pipeline = He),
          (t.ostring = () => ce().optional()),
          (t.onumber = () => de().optional()),
          (t.oboolean = () => he().optional()),
          (t.coerce = {
            string: (e) => w.create({ ...e, coerce: !0 }),
            number: (e) => A.create({ ...e, coerce: !0 }),
            boolean: (e) => T.create({ ...e, coerce: !0 }),
            bigint: (e) => _.create({ ...e, coerce: !0 }),
            date: (e) => R.create({ ...e, coerce: !0 }),
          }),
          (t.NEVER = s.INVALID);
      },
      6123: (e, t, r) => {
        "use strict";
        r.r(t),
          r.d(t, {
            ActionTimeout: () => xe,
            Answer: () => ue,
            AnswerDecision: () => Pe,
            AppClient: () => ar,
            AppHelper: () => E,
            AttachGameParams: () => He,
            BroadcastFrame: () => ze,
            BroadcastFrameEvent: () => Ke,
            BroadcastFrameInit: () => Je,
            BroadcastFrameMessage: () => Xe,
            CiphertextAndDigest: () => ve,
            Connection: () => Qe,
            Custom: () => he,
            DrawRandomItems: () => Ie,
            DrawTimeout: () => Se,
            ExitGameParams: () => Ge,
            GameAccount: () => f,
            GameBundle: () => p,
            GameContextSnapshot: () => Rt,
            GameEvent: () => le,
            GameRegistration: () => m,
            GameStart: () => Te,
            Leave: () => _e,
            Lock: () => be,
            Mask: () => ge,
            Message: () => Ze,
            OperationTimeout: () => ye,
            PlayerDeposit: () => l,
            PlayerJoin: () => d,
            PlayerProfile: () => v,
            PlayerShapshot: () => _t,
            Random: () => de,
            RandomnessReady: () => we,
            Ready: () => pe,
            RegistrationAccount: () => y,
            RegistrationWithGames: () => g,
            SecretShare: () => ce,
            SecretsReady: () => Oe,
            ServerAccount: () => c,
            ServerJoin: () => u,
            ServerLeave: () => Ae,
            ServerShapshot: () => Tt,
            ShareSecrets: () => me,
            Shutdown: () => Ce,
            SubmitEventParams: () => We,
            SubmitMessageParams: () => qe,
            SubscribeEventParams: () => Ve,
            Sync: () => Ee,
            Token: () => o,
            TokenWithBalance: () => a,
            Vote: () => h,
            VoteType: () => n,
            WaitingTimeout: () => Re,
            makeCustomEvent: () => fe,
          });
        var n,
          i = r(214),
          s = function (e, t, r, n) {
            var i,
              s = arguments.length,
              o =
                s < 3
                  ? t
                  : null === n
                  ? (n = Object.getOwnPropertyDescriptor(t, r))
                  : n;
            if (
              "object" == typeof Reflect &&
              "function" == typeof Reflect.decorate
            )
              o = Reflect.decorate(e, t, r, n);
            else
              for (var a = e.length - 1; a >= 0; a--)
                (i = e[a]) &&
                  (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
            return s > 3 && o && Object.defineProperty(t, r, o), o;
          };
        !(function (e) {
          (e[(e.ServerVoteTransactorDropOff = 0)] =
            "ServerVoteTransactorDropOff"),
            (e[(e.ClientVoteTransactorDropOff = 1)] =
              "ClientVoteTransactorDropOff");
        })(n || (n = {}));
        class o {
          constructor(e) {
            Object.assign(this, e);
          }
        }
        class a {
          constructor(e, t) {
            Object.assign(this, e),
              (this.amount = t),
              (this.uiAmount = (
                Number(t) / Math.pow(10, e.decimals)
              ).toLocaleString());
          }
        }
        class c {
          constructor(e) {
            Object.assign(this, e);
          }
        }
        s([(0, i.field)("string")], c.prototype, "addr", void 0),
          s([(0, i.field)("string")], c.prototype, "endpoint", void 0);
        class d {
          constructor(e) {
            Object.assign(this, e);
          }
        }
        s([(0, i.field)("string")], d.prototype, "addr", void 0),
          s([(0, i.field)("u16")], d.prototype, "position", void 0),
          s([(0, i.field)("u64")], d.prototype, "balance", void 0),
          s([(0, i.field)("u64")], d.prototype, "accessVersion", void 0),
          s([(0, i.field)("string")], d.prototype, "verifyKey", void 0);
        class u {
          constructor(e) {
            Object.assign(this, e);
          }
        }
        s([(0, i.field)("string")], u.prototype, "addr", void 0),
          s([(0, i.field)("string")], u.prototype, "endpoint", void 0),
          s([(0, i.field)("u64")], u.prototype, "accessVersion", void 0),
          s([(0, i.field)("string")], u.prototype, "verifyKey", void 0);
        class l {
          constructor(e) {
            Object.assign(this, e);
          }
        }
        s([(0, i.field)("string")], l.prototype, "addr", void 0),
          s([(0, i.field)("u64")], l.prototype, "amount", void 0),
          s([(0, i.field)("u64")], l.prototype, "settleVersion", void 0);
        class h {
          constructor(e) {
            Object.assign(this, e);
          }
        }
        s([(0, i.field)("string")], h.prototype, "voter", void 0),
          s([(0, i.field)("string")], h.prototype, "votee", void 0),
          s([(0, i.field)("u8")], h.prototype, "voteType", void 0);
        class f {
          constructor(e) {
            Object.assign(this, e);
          }
        }
        s([(0, i.field)("string")], f.prototype, "addr", void 0),
          s([(0, i.field)("string")], f.prototype, "title", void 0),
          s([(0, i.field)("string")], f.prototype, "bundleAddr", void 0),
          s([(0, i.field)("string")], f.prototype, "tokenAddr", void 0),
          s([(0, i.field)("string")], f.prototype, "ownerAddr", void 0),
          s([(0, i.field)("u64")], f.prototype, "settleVersion", void 0),
          s([(0, i.field)("u64")], f.prototype, "accessVersion", void 0),
          s(
            [(0, i.field)((0, i.array)((0, i.struct)(d)))],
            f.prototype,
            "players",
            void 0,
          ),
          s(
            [(0, i.field)((0, i.array)((0, i.struct)(l)))],
            f.prototype,
            "deposits",
            void 0,
          ),
          s(
            [(0, i.field)((0, i.array)((0, i.struct)(u)))],
            f.prototype,
            "servers",
            void 0,
          ),
          s(
            [(0, i.field)((0, i.option)("string"))],
            f.prototype,
            "transactorAddr",
            void 0,
          ),
          s(
            [(0, i.field)((0, i.array)((0, i.struct)(h)))],
            f.prototype,
            "votes",
            void 0,
          ),
          s(
            [(0, i.field)((0, i.option)("u64"))],
            f.prototype,
            "unlockTime",
            void 0,
          ),
          s([(0, i.field)("u16")], f.prototype, "maxPlayers", void 0),
          s([(0, i.field)("u64")], f.prototype, "minDeposit", void 0),
          s([(0, i.field)("u64")], f.prototype, "maxDeposit", void 0),
          s([(0, i.field)("u32")], f.prototype, "dataLen", void 0),
          s([(0, i.field)("u8-array")], f.prototype, "data", void 0);
        class p {
          constructor(e) {
            Object.assign(this, e);
          }
        }
        s([(0, i.field)("string")], p.prototype, "uri", void 0),
          s([(0, i.field)("string")], p.prototype, "name", void 0),
          s([(0, i.field)("u8-array")], p.prototype, "data", void 0);
        class m {
          constructor(e) {
            Object.assign(this, e);
          }
        }
        s([(0, i.field)("string")], m.prototype, "title", void 0),
          s([(0, i.field)("string")], m.prototype, "addr", void 0),
          s([(0, i.field)("u64")], m.prototype, "regTime", void 0),
          s([(0, i.field)("string")], m.prototype, "bundleAddr", void 0);
        class y {
          constructor(e) {
            Object.assign(this, e);
          }
        }
        s([(0, i.field)("string")], y.prototype, "addr", void 0),
          s([(0, i.field)("bool")], y.prototype, "isPrivate", void 0),
          s([(0, i.field)("u16")], y.prototype, "size", void 0),
          s(
            [(0, i.field)((0, i.option)("string"))],
            y.prototype,
            "owner",
            void 0,
          ),
          s(
            [(0, i.field)((0, i.array)((0, i.struct)(m)))],
            y.prototype,
            "games",
            void 0,
          );
        class g {
          constructor(e) {
            Object.assign(this, e);
          }
        }
        class v {
          constructor(e) {
            Object.assign(this, e);
          }
        }
        s([(0, i.field)("string")], v.prototype, "addr", void 0),
          s([(0, i.field)("string")], v.prototype, "nick", void 0),
          s(
            [(0, i.field)((0, i.option)("string"))],
            v.prototype,
            "pfp",
            void 0,
          );
        var b,
          w = function (e, t, r, n) {
            if ("a" === r && !n)
              throw new TypeError(
                "Private accessor was defined without a getter",
              );
            if ("function" == typeof t ? e !== t || !n : !t.has(e))
              throw new TypeError(
                "Cannot read private member from an object whose class did not declare it",
              );
            return "m" === r
              ? n
              : "a" === r
              ? n.call(e)
              : n
              ? n.value
              : t.get(e);
          };
        class E {
          constructor(e) {
            b.set(this, void 0),
              (function (e, t, r, n, i) {
                if ("m" === n)
                  throw new TypeError("Private method is not writable");
                if ("a" === n && !i)
                  throw new TypeError(
                    "Private accessor was defined without a setter",
                  );
                if ("function" == typeof t ? e !== t || !i : !t.has(e))
                  throw new TypeError(
                    "Cannot write private member to an object whose class did not declare it",
                  );
                "a" === n ? i.call(e, r) : i ? (i.value = r) : t.set(e, r);
              })(this, b, e, "f");
          }
          async getGame(e) {
            return await w(this, b, "f").getGameAccount(e);
          }
          async createGame(e, t) {
            if (0 == t.title.length || t.title.length > 16)
              throw new Error("Invalid title");
            if (t.minDeposit <= 0) throw new Error("Invalid minDeposit");
            if (t.maxDeposit < t.minDeposit)
              throw new Error("Invalid maxDeposit");
            if (t.maxPlayers < 1 || t.maxPlayers > 512)
              throw new Error("Invalid maxPlayers");
            let r = await w(this, b, "f").createGameAccount(e, t);
            return console.debug("Game account created at %s", r), r;
          }
          async registerGame(e, t, r) {
            await w(this, b, "f").registerGame(e, { gameAddr: t, regAddr: r });
          }
          async createProfile(e, t, r) {
            await w(this, b, "f").createPlayerProfile(e, { nick: t, pfp: r });
          }
          async getProfile(e) {
            return await w(this, b, "f").getPlayerProfile(e);
          }
          async listGames(e) {
            let t = [];
            for (const r of e) {
              const e = await w(this, b, "f").getRegistrationWithGames(r);
              if (void 0 !== e) for (const r of e.games) t.push(r);
            }
            return t;
          }
          async listTokens() {
            return await w(this, b, "f").listTokens();
          }
          async listNfts(e, t = void 0) {
            const r = await w(this, b, "f").listNfts(e);
            return void 0 === t ? r : r.filter((e) => e.collection === t);
          }
          async listTokensWithBalance(e) {
            const t = await this.listTokens(),
              r = t.map((e) => e.addr),
              n = await w(this, b, "f").fetchBalances(e, r);
            return t.map((e) => {
              let t = n.get(e.addr);
              return void 0 === t && (t = 0n), new a(e, t);
            });
          }
        }
        b = new WeakMap();
        var A = function (e, t, r, n) {
          var i,
            s = arguments.length,
            o =
              s < 3
                ? t
                : null === n
                ? (n = Object.getOwnPropertyDescriptor(t, r))
                : n;
          if (
            "object" == typeof Reflect &&
            "function" == typeof Reflect.decorate
          )
            o = Reflect.decorate(e, t, r, n);
          else
            for (var a = e.length - 1; a >= 0; a--)
              (i = e[a]) &&
                (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
          return s > 3 && o && Object.defineProperty(t, r, o), o;
        };
        class _ extends Error {}
        let T = class extends _ {
          constructor(e) {
            super(), (this.message = e.message);
          }
        };
        T = A([(0, i.variant)(0)], T);
        let R = class extends _ {
          constructor(e) {
            super(), (this.message = "No enough players");
          }
        };
        R = A([(0, i.variant)(1)], R);
        let I = class extends _ {
          constructor(e) {
            super(), (this.message = "Player not in game");
          }
        };
        I = A([(0, i.variant)(2)], I);
        let S = class extends _ {
          constructor(e) {
            super(), (this.message = "Can't leave game");
          }
        };
        S = A([(0, i.variant)(3)], S);
        let x = class extends _ {
          constructor(e) {
            super(), (this.message = "Invalid amount");
          }
        };
        x = A([(0, i.variant)(4)], x);
        let P = class extends _ {
          constructor(e) {
            super(), (this.message = "Malformed game account data");
          }
        };
        P = A([(0, i.variant)(5)], P);
        let O = class extends _ {
          constructor(e) {
            super(), (this.message = "Malformed custom event");
          }
        };
        O = A([(0, i.variant)(6)], O);
        let C = class extends _ {
          constructor(e) {
            super(), (this.message = "Serilization error");
          }
        };
        C = A([(0, i.variant)(7)], C);
        let k = class extends _ {
          constructor(e) {
            super(), (this.message = "No enough servers");
          }
        };
        k = A([(0, i.variant)(8)], k);
        let M = class extends _ {
          constructor(e) {
            super(), (this.message = `Internal error: ${e.message}`);
          }
        };
        A([(0, i.field)("string")], M.prototype, "message", void 0),
          (M = A([(0, i.variant)(9)], M));
        class N extends Error {
          constructor(e) {
            super(e);
          }
          static publicKeyNotFound(e) {
            return new N(`RSA public key for ${e} is missing`);
          }
          static gameAccountNotFound(e) {
            return new N(`Game account of ${e} not found`);
          }
          static gameBundleNotFound(e) {
            return new N(`Game bundle of ${e} not found`);
          }
          static transactorAccountNotFound(e) {
            return new N(`Transactor's account of ${e} not found`);
          }
          static gameNotServed(e) {
            return new N(`Game at ${e} is not served`);
          }
          static tokenNotFound(e) {
            return new N(`Token ${e} not found`);
          }
        }
        function B(e) {
          let t = "",
            r = new Uint8Array(e),
            n = r.byteLength;
          for (let e = 0; e < n; e++) t += String.fromCharCode(r[e]);
          return btoa(t);
        }
        function D(e) {
          const t = atob(e),
            r = new Uint8Array(t.length);
          for (let e = 0; e < t.length; e++) r[e] = t.charCodeAt(e);
          return r.buffer;
        }
        var j,
          L,
          U = r(1625),
          F = function (e, t, r, n) {
            var i,
              s = arguments.length,
              o =
                s < 3
                  ? t
                  : null === n
                  ? (n = Object.getOwnPropertyDescriptor(t, r))
                  : n;
            if (
              "object" == typeof Reflect &&
              "function" == typeof Reflect.decorate
            )
              o = Reflect.decorate(e, t, r, n);
            else
              for (var a = e.length - 1; a >= 0; a--)
                (i = e[a]) &&
                  (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
            return s > 3 && o && Object.defineProperty(t, r, o), o;
          },
          H = function (e, t, r, n, i) {
            if ("m" === n)
              throw new TypeError("Private method is not writable");
            if ("a" === n && !i)
              throw new TypeError(
                "Private accessor was defined without a setter",
              );
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
              throw new TypeError(
                "Cannot write private member to an object whose class did not declare it",
              );
            return (
              "a" === n ? i.call(e, r) : i ? (i.value = r) : t.set(e, r), r
            );
          },
          G = function (e, t, r, n) {
            if ("a" === r && !n)
              throw new TypeError(
                "Private accessor was defined without a getter",
              );
            if ("function" == typeof t ? e !== t || !n : !t.has(e))
              throw new TypeError(
                "Cannot read private member from an object whose class did not declare it",
              );
            return "m" === r
              ? n
              : "a" === r
              ? n.call(e)
              : n
              ? n.value
              : t.get(e);
          };
        let V = crypto.subtle;
        const W = Uint8Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
          q = Uint8Array.of(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
          Z =
            (Uint8Array.of(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1),
            new TextDecoder("utf8")),
          z = Uint8Array.of(1, 0, 1);
        class K {
          constructor(e) {
            (this.rsa = e.rsa), (this.ec = e.ec);
          }
        }
        F([(0, i.field)("string")], K.prototype, "rsa", void 0),
          F([(0, i.field)("string")], K.prototype, "ec", void 0);
        const J = { name: "RSA-OAEP", hash: "SHA-256" },
          X = { name: "ECDSA", namedCurve: "P-256" };
        async function Q(e) {
          return B(await V.exportKey("spki", e));
        }
        async function $(e) {
          return B(await V.exportKey("spki", e));
        }
        async function Y(e) {
          const t = D(e);
          return await V.importKey("spki", t, J, !0, ["encrypt"]);
        }
        async function ee(e) {
          const t = D(e);
          return await V.importKey("spki", t, X, !0, ["verify"]);
        }
        async function te() {
          return await V.generateKey(X, !0, ["verify", "sign"]);
        }
        async function re() {
          return await V.generateKey(
            {
              name: "RSA-OAEP",
              modulusLength: 1024,
              publicExponent: z,
              hash: "SHA-256",
            },
            !0,
            ["encrypt", "decrypt"],
          );
        }
        class ne {
          constructor(e) {
            (this.signer = e.signer),
              (this.timestamp = e.timestamp),
              (this.signature = e.signature);
          }
        }
        F([(0, i.field)("string")], ne.prototype, "signer", void 0),
          F([(0, i.field)("u64")], ne.prototype, "timestamp", void 0),
          F([(0, i.field)("u8-array")], ne.prototype, "signature", void 0);
        class ie {
          constructor(e, t) {
            (this.rsa = e), (this.ec = t);
          }
          static async initialize(e) {
            // let t, r;
            // return (
            //   (t = void 0 === e?.rsa ? await re() : e.rsa),
            //   (r = void 0 === e?.ec ? await te() : e.ec),
            //   new ie(t, r)
            // );
            let t, r;

            if (typeof e === 'undefined' || typeof e.rsa === 'undefined') {
              t = await re();
            } else {
              t = e.rsa;
            }

            if (typeof e === 'undefined' || typeof e.ec === 'undefined') {
              r = await te();
            } else {
              r = e.ec;
            }

            return new ie(t, r);
          }
        }
        class se {
          constructor(e, t) {
            (this.rsa = e), (this.ec = t);
          }
        }
        class oe {
          constructor(e) {
            j.set(this, void 0),
              L.set(this, void 0),
              H(this, j, e, "f"),
              H(this, L, new Map(), "f");
          }
          async decryptRsa(e) {
            return await (async function (e, t) {
              return new Uint8Array(await V.decrypt("RSA-OAEP", e, t));
            })(G(this, j, "f").rsa.privateKey, e);
          }
          async decryptAes(e, t) {
            const r = await (async function (e) {
              return await V.importKey("raw", e, { name: "AES-CTR" }, !0, [
                "encrypt",
                "decrypt",
              ]);
            })(e);
            return await (async function (e, t, r) {
              return new Uint8Array(
                await V.decrypt(
                  { name: "AES-CTR", counter: r, length: 64 },
                  e,
                  t,
                ),
              );
            })(r, t, W);
          }
          async decryptAesMulti(e, t) {
            for (const r of e) t = await this.decryptAes(r, t);
            return t;
          }
          encryptChacha20(e, t) {
            return (function (e, t, r) {
              return new U.Chacha20(e, r).encrypt(t);
            })(e, t, q);
          }
          decryptChacha20(e, t) {
            return (function (e, t, r) {
              return new U.Chacha20(e, r).decrypt(t);
            })(e, t, q);
          }
          decryptChacha20Multi(e, t) {
            for (const r of e) t = this.decryptChacha20(r, t);
            return t;
          }
          async signRaw(e) {
            return await (async function (e, t) {
              return new Uint8Array(
                await V.sign(
                  { name: "ECDSA", hash: { name: "SHA-256" } },
                  e,
                  t,
                ),
              );
            })(G(this, j, "f").ec.privateKey, e);
          }
          makeSignMessage(e, t) {
            const r = new DataView(new ArrayBuffer(8));
            r.setBigUint64(0, t, !0);
            const n = new Uint8Array(e.length + 8);
            return n.set(e), n.set(new Uint8Array(r.buffer), e.length), n;
          }
          async sign(e, t) {
            const r = BigInt(new Date().getTime()),
              n = this.makeSignMessage(e, r),
              i = await this.signRaw(n);
            return new ne({ timestamp: r, signer: t, signature: i });
          }
          async verify(e, t) {
            const r = t.timestamp;
            let n;

            const signerEntry = G(this, L, "f").get(t.signer);
            if (typeof signerEntry !== 'undefined') {
              n = signerEntry.ec;
            }
              // n = G(this, L, "f").get(t.signer)?.ec;
            if (void 0 === n)
              throw new Error("Can't verify message, ECDSA key is missing");
            const i = this.makeSignMessage(e, r);
            return await (async function (e, t, r) {
              return await V.verify(
                { name: "ECDSA", hash: { name: "SHA-256" } },
                e,
                t,
                r,
              );
            })(n, t.signature, i);
          }
          static async create(e, t) {
            if (void 0 !== t) {
              const r = await oe.importFromStorage(e, t);
              if (void 0 !== r) return r;
            }
            const r = await re(),
              n = await te(),
              i = new oe(new ie(r, n));
            return void 0 !== t && (await i.exportToStorage(e, t)), i;
          }
          static makeStorageKey(e) {
            return `ENCRYPTOR_KEY_1.0_${e}`;
          }
          async exportToStorage(e, t) {
            const r = await this.exportEcKeys(),
              n = await this.exportRsaKeys();
            t.setItem(oe.makeStorageKey(e), JSON.stringify({ rsa: n, ec: r }));
          }
          static async importFromStorage(e, t) {
            const r = oe.makeStorageKey(e),
              n = t.getItem(r);
            if (null === n) return;
            const { rsa: i, ec: s } = JSON.parse(n),
              o = await (async function ([e, t]) {
                const r = D(e),
                  n = await V.importKey("pkcs8", r, X, !0, ["sign"]);
                return { publicKey: await ee(t), privateKey: n };
              })(s),
              a = await (async function ([e, t]) {
                const r = D(e),
                  n = await V.importKey("pkcs8", r, J, !0, ["decrypt"]);
                return { publicKey: await Y(t), privateKey: n };
              })(i);
            return new oe(new ie(a, o));
          }
          async exportRsaKeys() {
            return await (async function (e) {
              return [
                B(await V.exportKey("pkcs8", e.privateKey)),
                await Q(e.publicKey),
              ];
            })(G(this, j, "f").rsa);
          }
          async exportEcKeys() {
            return await (async function (e) {
              return [
                B(await V.exportKey("pkcs8", e.privateKey)),
                await $(e.publicKey),
              ];
            })(G(this, j, "f").ec);
          }
          async addPublicKey(e, { rsa: t, ec: r }) {
            const n = await Y(t),
              i = await ee(r);
            G(this, L, "f").set(e, new se(n, i));
          }
          async exportPublicKey(e) {
            let t, r;
            if (void 0 === e)
              (t = G(this, j, "f").rsa.publicKey),
                (r = G(this, j, "f").ec.publicKey);
            else {
              const n = G(this, L, "f").get(e);
              if (void 0 === n) throw N.publicKeyNotFound(e);
              (t = n.rsa), (r = n.ec);
            }
            return new K({ rsa: await Q(t), ec: await $(r) });
          }
          async decryptWithSecrets(e, t, r) {
            const n = new Map();
            for (const [i, s] of e) {
              const e = t.get(i);
              if (void 0 === e) throw new Error("Missing secrets");
              {
                const t = this.decryptChacha20Multi(e, s),
                  o = Z.decode(t);
                if (void 0 === r.find((e) => e === o))
                  throw new Error(
                    "Invalid result: [" + o + "], options:" + r.join(","),
                  );
                n.set(i, o);
              }
            }
            return n;
          }
        }
        (j = new WeakMap()), (L = new WeakMap());
        var ae = function (e, t, r, n) {
          var i,
            s = arguments.length,
            o =
              s < 3
                ? t
                : null === n
                ? (n = Object.getOwnPropertyDescriptor(t, r))
                : n;
          if (
            "object" == typeof Reflect &&
            "function" == typeof Reflect.decorate
          )
            o = Reflect.decorate(e, t, r, n);
          else
            for (var a = e.length - 1; a >= 0; a--)
              (i = e[a]) &&
                (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
          return s > 3 && o && Object.defineProperty(t, r, o), o;
        };
        class ce {}
        let de = class extends ce {
          constructor(e) {
            super(), Object.assign(this, e);
          }
        };
        ae([(0, i.field)("string")], de.prototype, "fromAddr", void 0),
          ae(
            [(0, i.field)((0, i.option)("string"))],
            de.prototype,
            "toAddr",
            void 0,
          ),
          ae([(0, i.field)("usize")], de.prototype, "randomId", void 0),
          ae([(0, i.field)("usize")], de.prototype, "index", void 0),
          ae([(0, i.field)("u8-array")], de.prototype, "secret", void 0),
          (de = ae([(0, i.variant)(0)], de));
        let ue = class extends ce {
          constructor(e) {
            super(), Object.assign(this, e);
          }
        };
        ae([(0, i.field)("string")], ue.prototype, "fromAddr", void 0),
          ae([(0, i.field)("usize")], ue.prototype, "decisionId", void 0),
          ae([(0, i.field)("u8-array")], ue.prototype, "secret", void 0),
          (ue = ae([(0, i.variant)(1)], ue));
        class le {
          kind() {
            return "Invalid";
          }
        }
        let he = class extends le {
          constructor(e) {
            super(), Object.assign(this, e);
          }
          kind() {
            return "Custom";
          }
        };
        function fe(e, t) {
          return new he({ sender: e, raw: t.serialize() });
        }
        ae([(0, i.field)("string")], he.prototype, "sender", void 0),
          ae([(0, i.field)("u8-array")], he.prototype, "raw", void 0),
          (he = ae([(0, i.variant)(0)], he));
        let pe = class extends le {
          constructor(e = {}) {
            super();
          }
          kind() {
            return "Ready";
          }
        };
        pe = ae([(0, i.variant)(1)], pe);
        let me = class extends le {
          constructor(e) {
            super(), Object.assign(this, e);
          }
          kind() {
            return "ShareSecrets";
          }
        };
        ae([(0, i.field)("string")], me.prototype, "sender", void 0),
          ae(
            [(0, i.field)((0, i.array)((0, i.enums)(ce)))],
            me.prototype,
            "shares",
            void 0,
          ),
          (me = ae([(0, i.variant)(2)], me));
        let ye = class extends le {
          constructor(e) {
            super(), Object.assign(this, e);
          }
          kind() {
            return "OperationTimeout";
          }
        };
        ae(
          [(0, i.field)((0, i.array)("string"))],
          ye.prototype,
          "addrs",
          void 0,
        ),
          (ye = ae([(0, i.variant)(3)], ye));
        let ge = class extends le {
          constructor(e) {
            super(), Object.assign(this, e);
          }
          kind() {
            return "Mask";
          }
        };
        ae([(0, i.field)("string")], ge.prototype, "sender", void 0),
          ae([(0, i.field)("usize")], ge.prototype, "randomId", void 0),
          ae(
            [(0, i.field)((0, i.array)("u8-array"))],
            ge.prototype,
            "ciphertexts",
            void 0,
          ),
          (ge = ae([(0, i.variant)(4)], ge));
        class ve {
          constructor(e) {
            Object.assign(this, e);
          }
        }
        ae([(0, i.field)("u8-array")], ve.prototype, "ciphertext", void 0),
          ae([(0, i.field)("u8-array")], ve.prototype, "digest", void 0);
        let be = class extends le {
          constructor(e) {
            super(), Object.assign(this, e);
          }
          kind() {
            return "Lock";
          }
        };
        ae([(0, i.field)("string")], be.prototype, "sender", void 0),
          ae([(0, i.field)("usize")], be.prototype, "randomId", void 0),
          ae(
            [(0, i.field)((0, i.array)((0, i.struct)(ve)))],
            be.prototype,
            "ciphertextsAndDigests",
            void 0,
          ),
          (be = ae([(0, i.variant)(5)], be));
        let we = class extends le {
          constructor(e) {
            super(), Object.assign(this, e);
          }
          kind() {
            return "RandomnessReady";
          }
        };
        ae([(0, i.field)("usize")], we.prototype, "randomId", void 0),
          (we = ae([(0, i.variant)(6)], we));
        let Ee = class extends le {
          constructor(e) {
            super(), Object.assign(this, e);
          }
          kind() {
            return "Sync";
          }
        };
        ae(
          [(0, i.field)((0, i.array)((0, i.struct)(d)))],
          Ee.prototype,
          "newPlayers",
          void 0,
        ),
          ae(
            [(0, i.field)((0, i.array)((0, i.struct)(u)))],
            Ee.prototype,
            "newServers",
            void 0,
          ),
          ae([(0, i.field)("string")], Ee.prototype, "transactorAddr", void 0),
          ae([(0, i.field)("u64")], Ee.prototype, "accessVersion", void 0),
          (Ee = ae([(0, i.variant)(7)], Ee));
        let Ae = class extends le {
          constructor(e) {
            super(), Object.assign(this, e);
          }
          kind() {
            return "ServerLeave";
          }
        };
        ae([(0, i.field)("string")], Ae.prototype, "serverAddr", void 0),
          ae([(0, i.field)("string")], Ae.prototype, "transactorAddr", void 0),
          (Ae = ae([(0, i.variant)(8)], Ae));
        let _e = class extends le {
          constructor(e) {
            super(), Object.assign(this, e);
          }
          kind() {
            return "Leave";
          }
        };
        ae([(0, i.field)("string")], _e.prototype, "playerAddr", void 0),
          (_e = ae([(0, i.variant)(9)], _e));
        let Te = class extends le {
          constructor(e) {
            super(), Object.assign(this, e);
          }
          kind() {
            return "GameStart";
          }
        };
        ae([(0, i.field)("u64")], Te.prototype, "accessVersion", void 0),
          (Te = ae([(0, i.variant)(10)], Te));
        let Re = class extends le {
          constructor(e = {}) {
            super();
          }
          kind() {
            return "WaitingTimeout";
          }
        };
        Re = ae([(0, i.variant)(11)], Re);
        let Ie = class extends le {
          constructor(e) {
            super(), Object.assign(this, e);
          }
          kind() {
            return "DrawRandomItems";
          }
        };
        ae([(0, i.field)("string")], Ie.prototype, "sender", void 0),
          ae([(0, i.field)("usize")], Ie.prototype, "randomId", void 0),
          ae(
            [(0, i.field)((0, i.array)("usize"))],
            Ie.prototype,
            "indexes",
            void 0,
          ),
          (Ie = ae([(0, i.variant)(12)], Ie));
        let Se = class extends le {
          constructor(e) {
            super();
          }
          kind() {
            return "DrawTimeout";
          }
        };
        Se = ae([(0, i.variant)(13)], Se);
        let xe = class extends le {
          constructor(e) {
            super(), Object.assign(this, e);
          }
          kind() {
            return "ActionTimeout";
          }
        };
        ae([(0, i.field)("string")], xe.prototype, "playerAddr", void 0),
          (xe = ae([(0, i.variant)(14)], xe));
        let Pe = class extends le {
          constructor(e) {
            super(), Object.assign(this, e);
          }
          kind() {
            return "AnswerDecision";
          }
        };
        ae([(0, i.field)("string")], Pe.prototype, "sender", void 0),
          ae([(0, i.field)("usize")], Pe.prototype, "decisionId", void 0),
          ae([(0, i.field)("u8-array")], Pe.prototype, "ciphertext", void 0),
          ae([(0, i.field)("u8-array")], Pe.prototype, "digest", void 0),
          (Pe = ae([(0, i.variant)(15)], Pe));
        let Oe = class extends le {
          constructor(e = {}) {
            super();
          }
          kind() {
            return "SecretsReady";
          }
        };
        Oe = ae([(0, i.variant)(16)], Oe);
        let Ce = class extends le {
          constructor(e = {}) {
            super();
          }
          kind() {
            return "Shutdown";
          }
        };
        Ce = ae([(0, i.variant)(17)], Ce);
        var ke,
          Me,
          Ne,
          Be,
          De,
          je,
          Le = function (e, t, r, n) {
            var i,
              s = arguments.length,
              o =
                s < 3
                  ? t
                  : null === n
                  ? (n = Object.getOwnPropertyDescriptor(t, r))
                  : n;
            if (
              "object" == typeof Reflect &&
              "function" == typeof Reflect.decorate
            )
              o = Reflect.decorate(e, t, r, n);
            else
              for (var a = e.length - 1; a >= 0; a--)
                (i = e[a]) &&
                  (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
            return s > 3 && o && Object.defineProperty(t, r, o), o;
          },
          Ue = function (e, t, r, n, i) {
            if ("m" === n)
              throw new TypeError("Private method is not writable");
            if ("a" === n && !i)
              throw new TypeError(
                "Private accessor was defined without a setter",
              );
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
              throw new TypeError(
                "Cannot write private member to an object whose class did not declare it",
              );
            return (
              "a" === n ? i.call(e, r) : i ? (i.value = r) : t.set(e, r), r
            );
          },
          Fe = function (e, t, r, n) {
            if ("a" === r && !n)
              throw new TypeError(
                "Private accessor was defined without a getter",
              );
            if ("function" == typeof t ? e !== t || !n : !t.has(e))
              throw new TypeError(
                "Cannot read private member from an object whose class did not declare it",
              );
            return "m" === r
              ? n
              : "a" === r
              ? n.call(e)
              : n
              ? n.value
              : t.get(e);
          };
        class He {
          constructor(e) {
            (this.key = e.key), (this.signer = e.signer);
          }
        }
        Le([(0, i.field)("string")], He.prototype, "signer", void 0),
          Le([(0, i.field)((0, i.struct)(K))], He.prototype, "key", void 0);
        class Ge {}
        class Ve {
          constructor(e) {
            this.settleVersion = e.settleVersion;
          }
        }
        Le([(0, i.field)("u64")], Ve.prototype, "settleVersion", void 0);
        class We {
          constructor(e) {
            this.event = e.event;
          }
        }
        Le([(0, i.field)((0, i.enums)(le))], We.prototype, "event", void 0);
        class qe {
          constructor(e) {
            this.content = e.content;
          }
        }
        Le([(0, i.field)("string")], qe.prototype, "content", void 0);
        class Ze {
          constructor(e) {
            Object.assign(this, e);
          }
        }
        Le([(0, i.field)("string")], Ze.prototype, "sender", void 0),
          Le([(0, i.field)("string")], Ze.prototype, "content", void 0);
        class ze {}
        let Ke = class extends ze {
          constructor(e) {
            super(), Object.assign(this, e);
          }
        };
        Le([(0, i.field)("string")], Ke.prototype, "gameAddr", void 0),
          Le([(0, i.field)((0, i.enums)(le))], Ke.prototype, "event", void 0),
          Le([(0, i.field)("u64")], Ke.prototype, "timestamp", void 0),
          (Ke = Le([(0, i.variant)(0)], Ke));
        let Je = class extends ze {
          constructor(e) {
            super(), Object.assign(this, e);
          }
        };
        Le([(0, i.field)("string")], Je.prototype, "gameAddr", void 0),
          Le([(0, i.field)("u64")], Je.prototype, "accessVersion", void 0),
          Le([(0, i.field)("u64")], Je.prototype, "settleVersion", void 0),
          Le(
            [(0, i.field)((0, i.option)("u8-array"))],
            Je.prototype,
            "state",
            void 0,
          ),
          (Je = Le([(0, i.variant)(1)], Je));
        let Xe = class extends ze {
          constructor(e) {
            super(), Object.assign(this, e);
          }
        };
        Le([(0, i.field)("string")], Xe.prototype, "gameAddr", void 0),
          Le(
            [(0, i.field)((0, i.struct)(Ze))],
            Xe.prototype,
            "message",
            void 0,
          ),
          (Xe = Le([(0, i.variant)(2)], Xe));
        class Qe {
          constructor(e, t, r, n) {
            try {
              ke.set(this, void 0),
              Me.set(this, void 0),
              Ne.set(this, void 0),
              Be.set(this, void 0),
              De.set(this, void 0),
              je.set(this, void 0),
              Ue(this, ke, e, "f"),
              Ue(this, Me, t, "f"),
              Ue(this, Ne, r, "f");
              const i = new WebSocket(t);
              Ue(this, Be, i, "f"), Ue(this, De, !1, "f"), Ue(this, je, n, "f");
            } catch (error) {
              console.log(error);
            }
            
          }
          async attachGame(e, t) {
            const r = this.makeReqNoSig(e, "attach_game", t);
            await this.requestXhr(r);
          }
          async submitEvent(e, t) {
            const r = await this.makeReq(e, "submit_event", t);
            await this.requestXhr(r);
          }
          async submitMessage(e, t) {
            const r = await this.makeReq(e, "submit_message", t);
            await this.requestXhr(r);
          }
          async exitGame(e, t) {
            const r = await this.makeReq(e, "exit_game", t);
            await this.requestXhr(r);
          }
          async *subscribeEvents(e, t) {
            const r = this.makeReqNoSig(e, "subscribe_event", t);
            await this.requestWs(r);
            let n,
              i = [],
              s = new Promise((e) => (n = e));
            for (
              Fe(this, Be, "f").onmessage = (e) => {
                if (void 0 !== n) {
                  let t = this.parseEventMessage(e.data);
                  if (void 0 !== t) {
                    let e = n;
                    (n = void 0), e(t);
                  }
                } else {
                  let t = this.parseEventMessage(e.data);
                  void 0 !== t && i.push(t);
                }
              },
                Fe(this, Be, "f").onclose = () => {
                  if (!Fe(this, De, "f") && Fe(this, je, "f"))
                    try {
                      Fe(this, je, "f").call(this);
                    } catch (e) {
                      console.log("process onClose error", e);
                    }
                  if (void 0 !== n) {
                    let e = n;
                    (n = void 0), e(void 0);
                  }
                };
              ;

            )
              i.length > 0
                ? yield i.shift()
                : (yield s, (s = new Promise((e) => (n = e))));
          }
          close() {
            Ue(this, De, !0, "f"), Fe(this, Be, "f").close();
          }
          parseEventMessage(e) {
            let t = JSON.parse(e);
            if ("s_event" === t.method) {
              let e = (function (e) {
                const t = atob(e),
                  r = new Uint8Array(t.length);
                for (let e = 0; e < t.length; e++) r[e] = t.charCodeAt(e);
                return r;
              })(t.params.result);
              return (0, i.deserialize)(ze, e);
            }
          }
          static initialize(e, t, r, n) {
            return new Qe(e, t, r, n);
          }
          async makeReq(e, t, r) {
            const n = (0, i.serialize)(r),
              s = await Fe(this, Ne, "f").sign(n, Fe(this, ke, "f")),
              o = (0, i.serialize)(s);
            return JSON.stringify({
              jsonrpc: "2.0",
              method: t,
              id: crypto.randomUUID(),
              params: [e, B(n), B(o)],
            });
          }
          makeReqNoSig(e, t, r) {
            const n = (0, i.serialize)(r);
            return JSON.stringify({
              jsonrpc: "2.0",
              method: t,
              id: crypto.randomUUID(),
              params: [e, B(n)],
            });
          }
          async requestWs(e) {
            try {
              await this.waitSocketReady(), Fe(this, Be, "f").send(e);
            } catch (e) {
              throw (
                (console.error(
                  "Failed to connect to current transactor: " +
                    Fe(this, Me, "f"),
                ),



                e)
              );
            }
          }
          async requestXhr(e) {
            try {
              const t = await fetch(Fe(this, Me, "f").replace(/^ws/, "http"), {
                method: "POST",
                body: e,
                headers: { "Content-Type": "application/json" },
              });
              if (t.ok) return t.json();
              throw Error("Transactor request failed:" + t.json());
            } catch (e) {
              throw (
                (console.error(
                  "Failed to connect to current transactor: " +
                    Fe(this, Me, "f"),
                ),
                e)
              );
            }
          }
          waitSocketReady() {
            return new Promise((e, t) => {
              let r = 0;
              const n = setInterval(() => {
                r > 100
                  ? (clearInterval(n), t())
                  : Fe(this, Be, "f").readyState === Fe(this, Be, "f").OPEN &&
                    (clearInterval(n), e(void 0)),
                  r++;
              }, 200);
            });
          }
        }
        (ke = new WeakMap()),
          (Me = new WeakMap()),
          (Ne = new WeakMap()),
          (Be = new WeakMap()),
          (De = new WeakMap()),
          (je = new WeakMap());
        var $e = function (e, t, r, n) {
          var i,
            s = arguments.length,
            o =
              s < 3
                ? t
                : null === n
                ? (n = Object.getOwnPropertyDescriptor(t, r))
                : n;
          if (
            "object" == typeof Reflect &&
            "function" == typeof Reflect.decorate
          )
            o = Reflect.decorate(e, t, r, n);
          else
            for (var a = e.length - 1; a >= 0; a--)
              (i = e[a]) &&
                (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
          return s > 3 && o && Object.defineProperty(t, r, o), o;
        };
        class Ye {}
        let et = class extends Ye {
          constructor(e) {
            super(), Object.assign(this, e);
          }
          asOptions() {
            return this.options;
          }
        };
        $e(
          [(0, i.field)((0, i.array)("string"))],
          et.prototype,
          "options",
          void 0,
        ),
          (et = $e([(0, i.variant)(0)], et));
        let tt = class extends Ye {
          constructor(e) {
            super(), Object.assign(this, e);
          }
          asOptions() {
            const e = [];
            for (const [t, r] of this.optionsAndWeights)
              for (let n = 0; n < r; n++) e.push(t);
            return e;
          }
        };
        $e(
          [(0, i.field)((0, i.map)("string", "u16"))],
          tt.prototype,
          "optionsAndWeights",
          void 0,
        ),
          (tt = $e([(0, i.variant)(1)], tt));
        class rt {
          constructor(e, t) {
            (this.digest = t), (this.owner = e);
          }
        }
        class nt {
          constructor(e) {
            (this.owner = e), (this.status = "required");
          }
        }
        class it {
          constructor(e) {
            (this.ciphertext = e),
              (this.locks = []),
              (this.owner = { kind: "unclaimed" });
          }
        }
        class st {
          constructor(e, t, r) {
            (this.fromAddr = e),
              (this.index = t),
              (this.toAddr = r),
              (this.secret = void 0);
          }
        }
        class ot {
          constructor(e, t, r) {
            if (0 === r.length) throw new Error("No enough servers");
            this.owners = r;
            const n = t.asOptions(),
              i = n.map((e) => new it(new TextEncoder().encode(e)));
            (this.options = n),
              (this.size = n.length),
              (this.ciphertexts = i),
              (this.masks = r.map((e) => new nt(e))),
              (this.id = e),
              (this.revealed = new Map()),
              (this.secretShares = []),
              (this.status = { kind: "masking", addr: r[0] });
          }
          isFullyMasked() {
            return this.masks.every((e) => "required" !== e.status);
          }
          isFullyLocked() {
            return this.masks.every((e) => "removed" === e.status);
          }
          mask(e, t) {
            if ("masking" !== this.status.kind)
              throw new Error("Invalid status" + this.status);
            {
              if (this.status.addr !== e) throw new Error("Invalid operator");
              const r = this.masks.find((t) => t.owner === e);
              if (void 0 === r) throw new Error("Invalid operator");
              if ("required" !== r.status) throw new Error("Duplicated mask");
              if (t.length !== this.ciphertexts.length)
                throw new Error("Invalid ciphertexts");
              for (let e = 0; e < this.ciphertexts.length; e++)
                this.ciphertexts[e].ciphertext = t[e];
              (r.status = "applied"), this.updateStatus();
            }
          }
          lock(e, t) {
            if ("locking" !== this.status.kind)
              throw new Error("Invalid status" + this.status);
            {
              if (this.status.addr !== e) throw new Error("Invalid operator");
              const r = this.masks.find((t) => t.owner === e);
              if (void 0 === r) throw new Error("Invalid operator");
              if (t.length !== this.ciphertexts.length)
                throw new Error("Invalid ciphertexts");
              r.status = "removed";
              for (let r = 0; r < this.ciphertexts.length; r++) {
                const { ciphertext: n, digest: i } = t[r];
                (this.ciphertexts[r].ciphertext = n),
                  this.ciphertexts[r].locks.push(new rt(e, i));
              }
              this.updateStatus();
            }
          }
          assign(e, t) {
            if (
              "ready" !== this.status.kind &&
              "waiting-secrets" !== this.status.kind
            )
              throw new Error("Invalid status" + this.status);
            for (const r of t) {
              let t = this.ciphertexts[r];
              if ("assigned" === t.owner.kind || "revealed" === t.owner.kind)
                throw new Error("Ciphertext already assigned");
              t.owner = { kind: "assigned", addr: e };
              let n = this.secretShares;
              this.owners.forEach((t) => {
                n.push(new st(t, r, e));
              });
            }
            this.status = { kind: "waiting-secrets" };
          }
          addSecretShare(e) {
            void 0 ===
              this.secretShares.find(
                (t) =>
                  t.fromAddr === e.fromAddr &&
                  t.toAddr === e.toAddr &&
                  t.index === e.index,
              ) && this.secretShares.push(e);
          }
          reveal(e) {
            if (
              "ready" !== this.status.kind &&
              "waiting-secrets" !== this.status.kind
            )
              throw new Error("Invalid status" + this.status);
            for (const t of e) {
              let e = this.ciphertexts[t];
              if ("revealed" !== e.owner.kind) {
                e.owner = { kind: "revealed" };
                let r = this.secretShares;
                this.owners.forEach((e) => {
                  r.push(new st(e, t));
                });
              }
            }
            this.status = { kind: "waiting-secrets" };
          }
          listRequiredSecretsByFromAddr(e) {
            return this.secretShares
              .filter((t) => void 0 === t.secret && t.fromAddr === e)
              .map((e) => ({
                fromAddr: e.fromAddr,
                toAddr: e.toAddr,
                randomId: this.id,
                index: e.index,
              }));
          }
          listRevealedSecrets() {
            if ("ready" !== this.status.kind)
              throw new Error(
                "Secrets not ready, current status: " + this.status.kind,
              );
            let e = new Map();
            for (const t of this.secretShares)
              if (void 0 === t.toAddr) {
                let r = e.get(t.index);
                void 0 === r ? e.set(t.index, [t.secret]) : r.push(t.secret);
              }
            return e;
          }
          listAssignedCiphertexts(e) {
            let t = new Map();
            for (let r = 0; r < this.ciphertexts.length; r++) {
              const n = this.ciphertexts[r];
              "assigned" === n.owner.kind &&
                n.owner.addr === e &&
                t.set(r, n.ciphertext);
            }
            return t;
          }
          listRevealedCiphertexts() {
            let e = new Map();
            for (let t = 0; t < this.ciphertexts.length; t++) {
              const r = this.ciphertexts[t];
              "revealed" === r.owner.kind && e.set(t, r.ciphertext);
            }
            return e;
          }
          listSharedSecrets(e) {
            if ("ready" !== this.status.kind)
              throw new Error(
                "Secrets not ready, current status: " + this.status.kind,
              );
            let t = new Map();
            for (const r of this.secretShares)
              if (r.toAddr === e) {
                let e = t.get(r.index);
                void 0 === e ? t.set(r.index, [r.secret]) : e.push(r.secret);
              }
            return t;
          }
          addRevealed(e) {
            for (const [t, r] of e) {
              if (t >= this.size) throw new Error("Invalid index");
              this.revealed.set(t, r);
            }
          }
          addSecret(e, t, r, n) {
            const i = this.secretShares.find(
              (n) => n.fromAddr === e && n.toAddr === t && n.index === r,
            );
            if (void 0 !== i) {
              if (void 0 !== i.secret) throw new Error("Duplicated secret");
              if (void 0 === this.ciphertexts[i.index])
                throw new Error("Invalid secret");
              i.secret = n;
            }
            this.updateStatus();
          }
          listOperatingAddrs() {
            switch (this.status.kind) {
              case "ready":
                return [];
              case "locking":
              case "masking":
                return [this.status.addr];
              case "waiting-secrets":
                return this.secretShares
                  .filter((e) => void 0 === e.secret)
                  .map((e) => e.fromAddr);
            }
          }
          updateStatus() {
            let e = this.masks.find((e) => "required" === e.status);
            void 0 === e
              ? ((e = this.masks.find((e) => "applied" === e.status)),
                void 0 === e
                  ? void 0 ===
                    this.secretShares.find((e) => void 0 === e.secret)
                    ? (this.status = { kind: "ready" })
                    : (this.status = { kind: "waiting-secrets" })
                  : (this.status = { kind: "locking", addr: e.owner }))
              : (this.status = { kind: "masking", addr: e.owner });
          }
        }
        class at {
          constructor(e, t) {
            (this.digest = t), (this.ciphertext = e);
          }
        }
        class ct {
          constructor(e, t) {
            (this.id = e),
              (this.owner = t),
              (this.status = "asked"),
              (this.secret = void 0),
              (this.answer = void 0),
              (this.value = void 0);
          }
          setAnswer(e, t, r) {
            if (this.owner !== e) throw new Error("Invalid decision owner");
            if ("asked" !== this.status)
              throw new Error("Invalid decision status");
            (this.answer = new at(t, r)), (this.status = "answered");
          }
          release() {
            if ("answered" !== this.status)
              throw new Error("Invalid decision status");
            this.status = "releasing";
          }
          addReleased(e) {
            if ("released" !== this.status)
              throw new Error("Invalid decision status");
            this.value = e;
          }
          addSecret(e, t) {
            if ("releasing" !== this.status)
              throw new Error("Invalid decision status");
            if (this.owner !== e) throw new Error("Invalid decision owner");
            (this.secret = t), (this.status = "released");
          }
        }
        var dt = function (e, t, r, n) {
          var i,
            s = arguments.length,
            o =
              s < 3
                ? t
                : null === n
                ? (n = Object.getOwnPropertyDescriptor(t, r))
                : n;
          if (
            "object" == typeof Reflect &&
            "function" == typeof Reflect.decorate
          )
            o = Reflect.decorate(e, t, r, n);
          else
            for (var a = e.length - 1; a >= 0; a--)
              (i = e[a]) &&
                (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
          return s > 3 && o && Object.defineProperty(t, r, o), o;
        };
        class ut {}
        let lt = class extends ut {
          constructor(e) {
            super(), Object.assign(this, e);
          }
        };
        dt([(0, i.field)("u64")], lt.prototype, "amount", void 0),
          (lt = dt([(0, i.variant)(0)], lt));
        let ht = class extends ut {
          constructor(e) {
            super(), Object.assign(this, e);
          }
        };
        dt([(0, i.field)("u64")], ht.prototype, "amount", void 0),
          (ht = dt([(0, i.variant)(1)], ht));
        let ft = class extends ut {
          constructor(e) {
            super();
          }
        };
        ft = dt([(0, i.variant)(2)], ft);
        class pt {
          constructor(e) {
            (this.addr = e.addr), (this.op = e.op);
          }
          sortKey() {
            return this.op instanceof lt ? 0 : this.op instanceof ht ? 1 : 2;
          }
          compare(e) {
            return this.sortKey() - e.sortKey();
          }
        }
        dt([(0, i.field)("string")], pt.prototype, "addr", void 0),
          dt([(0, i.field)((0, i.enums)(ut))], pt.prototype, "op", void 0);
        class mt {
          constructor(e) {
            Object.assign(this, e);
          }
        }
        dt([(0, i.field)("string")], mt.prototype, "playerAddr", void 0);
        class yt {
          constructor(e) {
            Object.assign(this, e);
          }
        }
        dt([(0, i.field)("usize")], yt.prototype, "randomId", void 0),
          dt([(0, i.field)("string")], yt.prototype, "playerAddr", void 0),
          dt(
            [(0, i.field)((0, i.array)("usize"))],
            yt.prototype,
            "indexes",
            void 0,
          );
        class gt {
          constructor(e) {
            Object.assign(this, e);
          }
        }
        dt([(0, i.field)("usize")], gt.prototype, "randomId", void 0),
          dt(
            [(0, i.field)((0, i.array)("usize"))],
            gt.prototype,
            "indexes",
            void 0,
          );
        class vt {
          constructor(e) {
            Object.assign(this, e);
          }
        }
        dt([(0, i.field)("usize")], vt.prototype, "decisionId", void 0);
        class bt {
          constructor(e) {
            Object.assign(this, e);
          }
        }
        dt([(0, i.field)("string")], bt.prototype, "playerAddr", void 0),
          dt([(0, i.field)("u64")], bt.prototype, "timeout", void 0);
        class wt {
          constructor(e) {
            Object.assign(this, e);
          }
          static fromContext(e) {
            const t = new Map();
            for (const r of e.randomStates) t.set(r.id, r.revealed);
            const r = new Map();
            for (const t of e.decisionStates) r.set(t.id, t.value);
            const n = e.timestamp,
              i = e.randomStates.length + 1,
              s = e.decisionStates.length + 1,
              o = e.players.length,
              a = e.servers.length,
              c = e.handlerState,
              d = e.allowExit;
            return new wt({
              actionTimeout: void 0,
              waitTimeout: void 0,
              startGame: !1,
              stopGame: !1,
              cancelDispatch: !1,
              timestamp: n,
              currRandomId: i,
              currDecisionId: s,
              playersCount: o,
              serversCount: a,
              asks: [],
              assigns: [],
              releases: [],
              reveals: [],
              initRandomStates: [],
              revealed: t,
              answered: r,
              settles: [],
              handlerState: c,
              error: void 0,
              allowExit: d,
            });
          }
        }
        dt(
          [(0, i.field)((0, i.option)((0, i.struct)(bt)))],
          wt.prototype,
          "actionTimeout",
          void 0,
        ),
          dt(
            [(0, i.field)((0, i.option)("u64"))],
            wt.prototype,
            "waitTimeout",
            void 0,
          ),
          dt([(0, i.field)("bool")], wt.prototype, "startGame", void 0),
          dt([(0, i.field)("bool")], wt.prototype, "stopGame", void 0),
          dt([(0, i.field)("bool")], wt.prototype, "cancelDispatch", void 0),
          dt([(0, i.field)("u64")], wt.prototype, "timestamp", void 0),
          dt([(0, i.field)("usize")], wt.prototype, "currRandomId", void 0),
          dt([(0, i.field)("usize")], wt.prototype, "currDecisionId", void 0),
          dt([(0, i.field)("u16")], wt.prototype, "playersCount", void 0),
          dt([(0, i.field)("u16")], wt.prototype, "serversCount", void 0),
          dt(
            [(0, i.field)((0, i.array)((0, i.struct)(mt)))],
            wt.prototype,
            "asks",
            void 0,
          ),
          dt(
            [(0, i.field)((0, i.array)((0, i.struct)(yt)))],
            wt.prototype,
            "assigns",
            void 0,
          ),
          dt(
            [(0, i.field)((0, i.array)((0, i.struct)(gt)))],
            wt.prototype,
            "reveals",
            void 0,
          ),
          dt(
            [(0, i.field)((0, i.array)((0, i.struct)(vt)))],
            wt.prototype,
            "releases",
            void 0,
          ),
          dt(
            [(0, i.field)((0, i.array)((0, i.enums)(Ye)))],
            wt.prototype,
            "initRandomStates",
            void 0,
          ),
          dt(
            [(0, i.field)((0, i.map)("usize", (0, i.map)("usize", "string")))],
            wt.prototype,
            "revealed",
            void 0,
          ),
          dt(
            [(0, i.field)((0, i.map)("usize", "string"))],
            wt.prototype,
            "answered",
            void 0,
          ),
          dt(
            [(0, i.field)((0, i.array)((0, i.struct)(pt)))],
            wt.prototype,
            "settles",
            void 0,
          ),
          dt(
            [(0, i.field)((0, i.option)("u8-array"))],
            wt.prototype,
            "handlerState",
            void 0,
          ),
          dt(
            [(0, i.field)((0, i.option)((0, i.enums)(_)))],
            wt.prototype,
            "error",
            void 0,
          ),
          dt([(0, i.field)("bool")], wt.prototype, "allowExit", void 0);
        const Et = 15000n;
        class At {
          constructor(e) {
            if (e instanceof At) {
              const t = e;
              (this.gameAddr = t.gameAddr),
                (this.accessVersion = t.accessVersion),
                (this.settleVersion = t.settleVersion),
                (this.transactorAddr = t.transactorAddr),
                (this.status = t.status),
                (this.players = t.players.map((e) => Object.assign({}, e))),
                (this.servers = t.servers.map((e) => Object.assign({}, e))),
                (this.dispatch = t.dispatch),
                (this.handlerState = new Uint8Array(t.handlerState)),
                (this.timestamp = t.timestamp),
                (this.allowExit = t.allowExit),
                (this.randomStates = t.randomStates),
                (this.decisionStates = t.decisionStates),
                (this.settles = t.settles);
            } else {
              const t = e,
                r = t.transactorAddr;
              if (void 0 === r) throw new Error("Game not served");
              const n = t.players.map((e) => ({
                  addr: e.addr,
                  balance: e.balance,
                  position: e.position,
                  status: { kind: "pending", accessVersion: e.accessVersion },
                })),
                i = t.servers.map((e) => ({
                  addr: e.addr,
                  endpoint: e.endpoint,
                  status: { kind: "pending", accessVersion: e.accessVersion },
                }));
              (this.gameAddr = t.addr),
                (this.transactorAddr = r),
                (this.accessVersion = t.accessVersion),
                (this.settleVersion = t.settleVersion),
                (this.status = "uninit"),
                (this.dispatch = void 0),
                (this.players = n),
                (this.servers = i),
                (this.timestamp = 0n),
                (this.allowExit = !1),
                (this.randomStates = []),
                (this.decisionStates = []),
                (this.settles = void 0),
                (this.handlerState = Uint8Array.of());
            }
          }
          getServerByAddress(e) {
            return this.servers.find((t) => t.addr === e);
          }
          getPlayerByAddress(e) {
            return this.players.find((t) => t.addr === e);
          }
          dispatchEvent(e, t) {
            this.dispatch = { event: e, timeout: this.timestamp + t };
          }
          dispatchEventInstantly(e) {
            this.dispatchEvent(e, 0n);
          }
          waitTimeout(e) {
            this.dispatch = { event: new Re({}), timeout: this.timestamp + e };
          }
          actionTimeout(e, t) {
            this.dispatch = {
              event: new xe({ playerAddr: e }),
              timeout: this.timestamp + t,
            };
          }
          genStartGameEvent() {
            return new Te({ accessVersion: this.accessVersion });
          }
          startGame() {
            (this.randomStates = []),
              (this.decisionStates = []),
              (this.dispatch = {
                event: this.genStartGameEvent(),
                timeout: 0n,
              });
          }
          shutdownGame() {
            this.dispatch = { event: new Ce({}), timeout: 0n };
          }
          getRandomState(e) {
            if (e <= 0) throw new Error("Invalid random id: " + e);
            const t = this.randomStates[e - 1];
            if (void 0 === t) throw new Error("Invalid random id: " + e);
            return t;
          }
          getDecisionState(e) {
            if (e <= 0) throw new Error("Invalid decision id: " + e);
            const t = this.decisionStates[e - 1];
            if (void 0 === t) throw new Error("Invalid decision id: " + e);
            return t;
          }
          assign(e, t, r) {
            this.getRandomState(e).assign(t, r);
          }
          reveal(e, t) {
            this.getRandomState(e).reveal(t);
          }
          isRandomReady(e) {
            const t = this.getRandomState(e).status.kind;
            return "ready" === t || "waiting-secrets" === t;
          }
          isAllRandomReady() {
            for (const e of this.randomStates) {
              const t = e.status.kind;
              if ("ready" !== t && "waiting-secrets" !== t) return !1;
            }
            return !0;
          }
          isSecretsReady() {
            return this.randomStates.every((e) => "ready" === e.status.kind);
          }
          setPlayerStatus(e, t) {
            let r = this.players.find((t) => t.addr === e);
            if (void 0 === r) throw new Error("Invalid player address");
            r.status = t;
          }
          addPlayer(e) {
            const t = this.players.find(
              (t) => t.addr === e.addr || t.position === e.position,
            );
            if (void 0 !== t)
              throw t.position === e.position
                ? new Error("Position occupied")
                : new Error("Player already joined");
            this.players.push({
              addr: e.addr,
              balance: e.balance,
              status: { kind: "ready" },
              position: e.position,
            });
          }
          addServer(e) {
            if (void 0 !== this.players.find((t) => t.addr === e.addr))
              throw new Error("Server already joined");
            this.servers.push({
              addr: e.addr,
              status: { kind: "ready" },
              endpoint: e.endpoint,
            });
          }
          setAccessVersion(e) {
            this.accessVersion = e;
          }
          setAllowExit(e) {
            this.allowExit = e;
          }
          removePlayer(e) {
            if (!this.allowExit) throw new Error("Can't leave");
            {
              const t = this.players.length;
              if (
                ((this.players = this.players.filter((t) => t.addr !== e)),
                this.players.length === t)
              )
                throw new Error("Player not in game");
            }
          }
          initRandomState(e) {
            const t = this.randomStates.length + 1,
              r = this.servers
                .filter((e) => "ready" === e.status.kind)
                .map((e) => e.addr),
              n = new ot(t, e, r);
            return this.randomStates.push(n), t;
          }
          addSharedSecrets(e, t) {
            for (const e of t)
              if (e instanceof de) {
                const {
                  randomId: t,
                  toAddr: r,
                  fromAddr: n,
                  index: i,
                  secret: s,
                } = e;
                this.getRandomState(t).addSecret(n, r, i, s);
              } else if (e instanceof ue) {
                const { fromAddr: t, decisionId: r, secret: n } = e;
                this.getDecisionState(r).addSecret(t, n);
              }
          }
          randomizeAndMask(e, t, r) {
            this.getRandomState(t).mask(e, r),
              this.dispatchRandomizationTimeout(t);
          }
          lock(e, t, r) {
            this.getRandomState(t).lock(e, r),
              this.dispatchRandomizationTimeout(t);
          }
          dispatchRandomizationTimeout(e) {
            const t = void 0 === this.dispatch;
            let r = this.getRandomState(e);
            const n = r.status.kind;
            if ("ready" === n)
              this.dispatchEventInstantly(new we({ randomId: e }));
            else if ("locking" === n || "masking" === n) {
              const e = r.status.addr;
              t && this.dispatchEvent(new ye({ addrs: [e] }), Et);
            } else if ("waiting-secrets" === n && t) {
              const e = r.listOperatingAddrs();
              this.dispatchEvent(new ye({ addrs: e }), Et);
            }
          }
          settle(e) {
            this.settles = e;
          }
          bumpSettleVersion() {
            this.settleVersion += 1n;
          }
          applyAndTakeSettles() {
            if (void 0 === this.settles) return;
            let e = this.settles;
            (this.settles = void 0), (e = e.sort((e, t) => e.compare(t)));
            for (const t of e)
              if (t.op instanceof lt) {
                let e = this.getPlayerByAddress(t.addr);
                if (void 0 === e)
                  throw new Error("Invalid settle player address");
                e.balance += t.op.amount;
              } else if (t.op instanceof ht) {
                let e = this.getPlayerByAddress(t.addr);
                if (void 0 === e)
                  throw new Error("Invalid settle player address");
                e.balance -= t.op.amount;
              } else
                t.op instanceof ft &&
                  (this.players = this.players.filter(
                    (e) => e.addr !== t.addr,
                  ));
            return this.bumpSettleVersion(), e;
          }
          addSettle(e) {
            void 0 === this.settles
              ? (this.settles = [e])
              : this.settles.push(e);
          }
          addRevealedRandom(e, t) {
            this.getRandomState(e).addRevealed(t);
          }
          addRevealedAnswer(e, t) {
            this.getDecisionState(e).addReleased(t);
          }
          ask(e) {
            const t = this.decisionStates.length + 1,
              r = new ct(t, e);
            return this.decisionStates.push(r), t;
          }
          answerDecision(e, t, r, n) {
            this.getDecisionState(e).setAnswer(t, r, n);
          }
          getRevealed(e) {
            return this.getRandomState(e).revealed;
          }
          applyEffect(e) {
            e.startGame
              ? this.startGame()
              : e.stopGame
              ? this.shutdownGame()
              : void 0 !== e.actionTimeout
              ? this.actionTimeout(
                  e.actionTimeout.playerAddr,
                  e.actionTimeout.timeout,
                )
              : void 0 !== e.waitTimeout
              ? this.waitTimeout(e.waitTimeout)
              : e.cancelDispatch && (this.dispatch = void 0),
              this.setAllowExit(e.allowExit);
            for (const t of e.assigns)
              this.assign(t.randomId, t.playerAddr, t.indexes);
            for (const t of e.reveals) this.reveal(t.randomId, t.indexes);
            for (const t of e.asks) this.ask(t.playerAddr);
            for (const t of e.initRandomStates) this.initRandomState(t);
            e.settles.length > 0 && this.settle(e.settles),
              void 0 !== e.handlerState && (this.handlerState = e.handlerState);
          }
          setNodeReady(e) {
            for (const t of this.servers)
              "pending" === t.status.kind &&
                t.status.accessVersion < e &&
                (t.status = { kind: "ready" });
            for (const t of this.players)
              "pending" === t.status.kind &&
                t.status.accessVersion < e &&
                (t.status = { kind: "ready" });
          }
          applyCheckpoint(e, t) {
            if (this.settleVersion !== t) throw new Error("Invalid checkpoint");
            (this.players = this.players.filter(
              (t) => "pending" !== t.status.kind || t.status.accessVersion <= e,
            )),
              (this.servers = this.servers.filter(
                (t) =>
                  "pending" !== t.status.kind || t.status.accessVersion <= e,
              )),
              (this.accessVersion = e);
          }
        }
        class _t {
          constructor(e) {
            (this.addr = e.addr),
              (this.balance = e.balance),
              (this.position = e.position),
              (this.status = e.status);
          }
        }
        class Tt {
          constructor(e) {
            (this.addr = e.addr),
              (this.endpoint = e.endpoint),
              (this.status = e.status);
          }
        }
        class Rt {
          constructor(e) {
            (this.gameAddr = e.gameAddr),
              (this.accessVersion = e.accessVersion),
              (this.settleVersion = e.settleVersion),
              (this.status = e.status),
              (this.allowExit = e.allowExit),
              (this.players = e.players.map((e) => new _t(e))),
              (this.servers = e.servers.map((e) => new Tt(e)));
          }
        }
        var It,
          St,
          xt = function (e, t, r, n) {
            var i,
              s = arguments.length,
              o =
                s < 3
                  ? t
                  : null === n
                  ? (n = Object.getOwnPropertyDescriptor(t, r))
                  : n;
            if (
              "object" == typeof Reflect &&
              "function" == typeof Reflect.decorate
            )
              o = Reflect.decorate(e, t, r, n);
            else
              for (var a = e.length - 1; a >= 0; a--)
                (i = e[a]) &&
                  (o = (s < 3 ? i(o) : s > 3 ? i(t, r, o) : i(t, r)) || o);
            return s > 3 && o && Object.defineProperty(t, r, o), o;
          },
          Pt = function (e, t, r, n, i) {
            if ("m" === n)
              throw new TypeError("Private method is not writable");
            if ("a" === n && !i)
              throw new TypeError(
                "Private accessor was defined without a setter",
              );
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
              throw new TypeError(
                "Cannot write private member to an object whose class did not declare it",
              );
            return (
              "a" === n ? i.call(e, r) : i ? (i.value = r) : t.set(e, r), r
            );
          },
          Ot = function (e, t, r, n) {
            if ("a" === r && !n)
              throw new TypeError(
                "Private accessor was defined without a getter",
              );
            if ("function" == typeof t ? e !== t || !n : !t.has(e))
              throw new TypeError(
                "Cannot read private member from an object whose class did not declare it",
              );
            return "m" === r
              ? n
              : "a" === r
              ? n.call(e)
              : n
              ? n.value
              : t.get(e);
          };
        class Ct {
          constructor(e) {
            (this.addr = e.addr),
              (this.accessVersion = e.accessVersion),
              (this.settleVersion = e.settleVersion),
              (this.data = e.data),
              (this.players = e.players),
              (this.servers = e.servers);
          }
          static createFromGameAccount(e, t, r) {
            let { addr: n, players: i, servers: s, data: o } = e;
            return (
              (i = i.filter((e) => e.accessVersion <= t)),
              (s = s.filter((e) => e.accessVersion <= t)),
              new Ct({
                addr: n,
                data: o,
                players: i,
                servers: s,
                accessVersion: t,
                settleVersion: r,
              })
            );
          }
          serialize() {
            return (0, i.serialize)(Ct);
          }
          static deserialize(e) {
            return (0, i.deserialize)(Ct, e);
          }
        }
        xt([(0, i.field)("string")], Ct.prototype, "addr", void 0),
          xt(
            [(0, i.field)((0, i.array)((0, i.struct)(d)))],
            Ct.prototype,
            "players",
            void 0,
          ),
          xt(
            [(0, i.field)((0, i.array)((0, i.struct)(u)))],
            Ct.prototype,
            "servers",
            void 0,
          ),
          xt([(0, i.field)("u8-array")], Ct.prototype, "data", void 0),
          xt([(0, i.field)("u64")], Ct.prototype, "accessVersion", void 0),
          xt([(0, i.field)("u64")], Ct.prototype, "settleVersion", void 0);
        class kt {
          constructor(e, t) {
            It.set(this, void 0),
              St.set(this, void 0),
              Pt(this, It, t, "f"),
              Pt(this, St, e, "f");
          }
          static async initialize(e, t) {
            const r = {
              imports: {
                memory: new WebAssembly.Memory({
                  shared: !0,
                  maximum: 100,
                  initial: 100,
                }),
              },
            };
            let n;
            return (
              0 === e.data.length
                ? (console.debug("Initiate handler by streaming:", e.uri),
                  (n = await WebAssembly.instantiateStreaming(fetch(e.uri), r)))
                : (n = await WebAssembly.instantiate(e.data, r)),
              new kt(n.instance, t)
            );
          }
          async handleEvent(e, t) {
            await this.generalPreHandleEvent(e, t, Ot(this, It, "f")),
              await this.customHandleEvent(e, t),
              await this.generalPostHandleEvent(e, t),
              e.applyAndTakeSettles();
          }
          async initState(e, t) {
            await this.generalPreInitState(e, t),
              await this.customInitState(e, t),
              await this.generalPostInitState(e, t);
          }
          async generalPreInitState(e, t) {}
          async generalPostInitState(e, t) {}
          async generalPreHandleEvent(e, t, r) {
            if (t instanceof me) {
              const { sender: r, shares: n } = t;
              e.addSharedSecrets(r, n),
                e.isSecretsReady() && e.dispatchEventInstantly(new Oe());
            } else if (t instanceof Pe) {
              const { decisionId: r, ciphertext: n, sender: i, digest: s } = t;
              e.answerDecision(r, i, n, s);
            } else if (t instanceof ge) {
              const { sender: r, randomId: n, ciphertexts: i } = t;
              e.randomizeAndMask(r, n, i);
            } else if (t instanceof be) {
              const { sender: r, randomId: n, ciphertextsAndDigests: i } = t;
              e.lock(r, n, i);
            } else if (t instanceof Ee) {
              const { accessVersion: r, newPlayers: n, newServers: i } = t;
              if (r < e.accessVersion) throw new Error("Event ignored");
              for (const t of n) e.addPlayer(t);
              for (const t of i) e.addServer(t);
              e.accessVersion = r;
            } else if (t instanceof _e) {
              const { playerAddr: r } = t;
              if (void 0 === e.players.find((e) => e.addr === r))
                throw new Error("Invalid player address");
            } else if (t instanceof Te) {
              const { accessVersion: r } = t;
              (e.status = "running"), e.setNodeReady(r);
            } else if (t instanceof Oe)
              for (const t of e.randomStates) {
                const n = t.options,
                  i = await r.decryptWithSecrets(
                    t.listRevealedCiphertexts(),
                    t.listRevealedSecrets(),
                    n,
                  );
                e.addRevealedRandom(t.id, i);
              }
          }
          async generalPostHandleEvent(e, t) {}
          async customInitState(e, t) {
            const r = Ot(this, St, "f").exports,
              n = r.memory;
            n.grow(4);
            let s = new Uint8Array(n.buffer);
            const o = wt.fromContext(e),
              a = (0, i.serialize)(o),
              c = a.length,
              d = (0, i.serialize)(t),
              u = d.length;
            if (
              (console.debug("Effect Bytes: [%s]", Array.of(a).toString()),
              s.length < 1 + u + c)
            )
              throw new Error(
                `WASM memory overflow, buffer length: ${s.length}, required: ${
                  1 + u + c
                }`,
              );
            let l = 1;
            s.set(a, l), (l += c), s.set(d, l);
            const h = (0, r.init_state)(c, u),
              f = new Uint8Array(n.buffer).slice(1, h + 1),
              p = (0, i.deserialize)(wt, f);
            if (void 0 !== p.error) throw (console.error(p.error), p.error);
            e.applyEffect(p);
          }
          async customHandleEvent(e, t) {
            const r = Ot(this, St, "f").exports,
              n = r.memory;
            let s = new Uint8Array(n.buffer);
            const o = wt.fromContext(e),
              a = (0, i.serialize)(o),
              c = a.length,
              d = (0, i.serialize)(t),
              u = d.length;
            if (s.length < 1 + u + c)
              throw new Error(
                `WASM memory overflow, buffer length: ${s.length}, required: ${
                  1 + u + c
                }`,
              );
            let l = 1;
            s.set(a, l), (l += c), s.set(d, l);
            const h = (0, r.handle_event)(c, u),
              f = new Uint8Array(n.buffer).slice(1, h + 1);
            let p;
            try {
              p = (0, i.deserialize)(wt, f);
            } catch (e) {
              throw (
                (console.debug(
                  "Failed to deserialize effect, raw: [%s]",
                  Array.from(f).toString(),
                ),
                e)
              );
            }
            if (void 0 !== p.error) throw p.error;
            e.applyEffect(p);
          }
        }
        (It = new WeakMap()), (St = new WeakMap());
        var Mt;
        class Nt {
          constructor(e) {
            Mt.set(this, void 0),
              (function (e, t, r, n, i) {
                if ("m" === n)
                  throw new TypeError("Private method is not writable");
                if ("a" === n && !i)
                  throw new TypeError(
                    "Private accessor was defined without a setter",
                  );
                if ("function" == typeof t ? e !== t || !i : !t.has(e))
                  throw new TypeError(
                    "Cannot write private member to an object whose class did not declare it",
                  );
                "a" === n ? i.call(e, r) : i ? (i.value = r) : t.set(e, r);
              })(this, Mt, e, "f");
          }
          clear() {}
          isRandomLoaded(e) {
            return !0;
          }
          genRandomStates(e, t) {}
        }
        Mt = new WeakMap();
        var Bt,
          Dt,
          jt,
          Lt,
          Ut,
          Ft,
          Ht,
          Gt = function (e, t, r, n, i) {
            if ("m" === n)
              throw new TypeError("Private method is not writable");
            if ("a" === n && !i)
              throw new TypeError(
                "Private accessor was defined without a setter",
              );
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
              throw new TypeError(
                "Cannot write private member to an object whose class did not declare it",
              );
            return (
              "a" === n ? i.call(e, r) : i ? (i.value = r) : t.set(e, r), r
            );
          },
          Vt = function (e, t, r, n) {
            if ("a" === r && !n)
              throw new TypeError(
                "Private accessor was defined without a getter",
              );
            if ("function" == typeof t ? e !== t || !n : !t.has(e))
              throw new TypeError(
                "Cannot read private member from an object whose class did not declare it",
              );
            return "m" === r
              ? n
              : "a" === r
              ? n.call(e)
              : n
              ? n.value
              : t.get(e);
          };
        class Wt {
          constructor(e, t, r, n, i) {
            Bt.set(this, void 0),
              Dt.set(this, void 0),
              jt.set(this, void 0),
              Lt.set(this, void 0),
              Ut.set(this, void 0),
              Ft.set(this, void 0),
              Ht.set(this, void 0),
              Gt(this, Ut, e, "f"),
              Gt(this, Lt, t, "f"),
              Gt(this, Dt, r, "f"),
              Gt(this, Bt, n, "f"),
              Gt(this, jt, i, "f"),
              Gt(this, Ft, new Array(), "f"),
              Gt(this, Ht, new Nt(n), "f");
          }
          async attachGame() {
            const e = await Vt(this, Bt, "f").exportPublicKey(void 0);
            await Vt(this, jt, "f").attachGame(
              Vt(this, Lt, "f"),
              new He({ signer: Vt(this, Ut, "f"), key: e }),
            );
          }
          async submitEvent(e) {
            await Vt(this, jt, "f").submitEvent(
              Vt(this, Lt, "f"),
              new We({ event: e }),
            );
          }
          async submitCustomEvent(e) {
            const t = fe(Vt(this, Lt, "f"), e);
            await Vt(this, jt, "f").submitEvent(
              Vt(this, Lt, "f"),
              new We({ event: t }),
            );
          }
          async handleDecision(e) {
            return [];
          }
          loadRandomStates(e) {
            for (let t of e.randomStates)
              Vt(this, Ht, "f").isRandomLoaded(t.id) ||
                Vt(this, Ht, "f").genRandomStates(t.id, t.size);
          }
          async handleUpdatedContext(e) {
            return this.loadRandomStates(e), await this.handleDecision(e);
          }
          flushSecretStates() {
            Vt(this, Ht, "f").clear(), Vt(this, Ft, "f").splice(0);
          }
          async decrypt(e, t) {
            let r = e.getRandomState(t),
              n = r.options,
              i = await Vt(this, Bt, "f").decryptWithSecrets(
                r.listRevealedCiphertexts(),
                r.listRevealedSecrets(),
                n,
              ),
              s = await Vt(this, Bt, "f").decryptWithSecrets(
                r.listAssignedCiphertexts(Vt(this, Ut, "f")),
                r.listSharedSecrets(Vt(this, Ut, "f")),
                n,
              );
            return new Map([...i, ...s]);
          }
        }
        (Bt = new WeakMap()),
          (Dt = new WeakMap()),
          (jt = new WeakMap()),
          (Lt = new WeakMap()),
          (Ut = new WeakMap()),
          (Ft = new WeakMap()),
          (Ht = new WeakMap());
        class qt {
          constructor(e) {
            (this.transport = e), (this.caches = new Map());
          }
          async getProfile(e) {
            let t = this.caches.get(e);
            if (void 0 !== t) return t;
            {
              const t = await this.transport.getPlayerProfile(e);
              return void 0 === t ? void 0 : (this.caches.set(e, t), t);
            }
          }
          async injectProfiles(e) {
            for (let t of e.players) {
              const e = await this.getProfile(t.addr);
              t.profile = e;
            }
          }
        }
        var Zt,
          zt,
          Kt,
          Jt,
          Xt,
          Qt,
          $t,
          Yt,
          er,
          tr,
          rr,
          nr,
          ir,
          sr = function (e, t, r, n, i) {
            if ("m" === n)
              throw new TypeError("Private method is not writable");
            if ("a" === n && !i)
              throw new TypeError(
                "Private accessor was defined without a setter",
              );
            if ("function" == typeof t ? e !== t || !i : !t.has(e))
              throw new TypeError(
                "Cannot write private member to an object whose class did not declare it",
              );
            return (
              "a" === n ? i.call(e, r) : i ? (i.value = r) : t.set(e, r), r
            );
          },
          or = function (e, t, r, n) {
            if ("a" === r && !n)
              throw new TypeError(
                "Private accessor was defined without a getter",
              );
            if ("function" == typeof t ? e !== t || !n : !t.has(e))
              throw new TypeError(
                "Cannot read private member from an object whose class did not declare it",
              );
            return "m" === r
              ? n
              : "a" === r
              ? n.call(e)
              : n
              ? n.value
              : t.get(e);
          };
        class ar {
          constructor(e, t, r, n, i, s, o, a, c, d, u, l) {
            Zt.set(this, void 0),
              zt.set(this, void 0),
              Kt.set(this, void 0),
              Jt.set(this, void 0),
              Xt.set(this, void 0),
              Qt.set(this, void 0),
              $t.set(this, void 0),
              Yt.set(this, void 0),
              er.set(this, void 0),
              tr.set(this, void 0),
              rr.set(this, void 0),
              nr.set(this, void 0),
              ir.set(this, void 0),
              sr(this, Zt, e, "f"),
              sr(this, zt, t, "f"),
              sr(this, Kt, r, "f"),
              sr(this, Jt, n, "f"),
              sr(this, Xt, i, "f"),
              sr(this, Qt, s, "f"),
              sr(this, $t, o, "f"),
              sr(this, Yt, a, "f"),
              sr(this, er, c, "f"),
              sr(this, tr, d, "f"),
              sr(this, rr, u, "f"),
              sr(this, nr, new qt(i), "f"),
              sr(this, ir, l, "f");
          }
          static async initialize(e) {
            const {
              transport: t,
              wallet: r,
              gameAddr: n,
              onEvent: i,
              onMessage: s,
              storage: o,
              onClose: a,
            } = e;
            console.group("AppClient initialization");
            try {
              const e = r.walletAddr,
                c = await oe.create(e, o),
                d = await t.getGameAccount(n);
              if (void 0 === d) throw N.gameAccountNotFound(n);
              console.log("Game account:", d);
              const u = await t.getGameBundle(d.bundleAddr);
              if (void 0 === u) throw N.gameBundleNotFound(d.bundleAddr);
              console.log("Game bundle:", u);
              const l = d.transactorAddr;
              if (void 0 === l) throw N.gameNotServed(n);
              console.log("Transactor address:", l);
              const h = await t.getServerAccount(l);
              if (void 0 === h) throw N.transactorAccountNotFound(l);
              const f = await kt.initialize(u, c),
                p = Qe.initialize(e, h.endpoint, c, a),
                m = new Wt(e, n, t, c, p),
                y = new At(d),
                g = await t.getToken(d.tokenAddr);
              if (void 0 === g) throw N.tokenNotFound(d.tokenAddr);
              const v = {
                title: d.title,
                minDeposit: d.minDeposit,
                maxDeposit: d.maxDeposit,
                maxPlayers: d.maxPlayers,
                token: g,
              };
              return new ar(n, f, r, m, t, p, y, d, i, s, c, v);
            } finally {
              console.groupEnd();
            }
          }
          get playerAddr() {
            return or(this, Kt, "f").walletAddr;
          }
          get gameAddr() {
            return or(this, Zt, "f");
          }
          get gameContext() {
            return or(this, $t, "f");
          }
          async getProfile(e) {
            return await or(this, Xt, "f").getPlayerProfile(e);
          }
          async invokeEventCallback(e) {
            const t = new Rt(or(this, $t, "f"));
            await or(this, nr, "f").injectProfiles(t);
            const r = or(this, $t, "f").handlerState;
            or(this, er, "f").call(this, t, r, e);
          }
          async attachGame() {
            await or(this, Jt, "f").attachGame();
            const e = or(this, $t, "f").settleVersion;
            let t = or(this, Qt, "f").subscribeEvents(
              or(this, Zt, "f"),
              new Ve({ settleVersion: e }),
            );
            for await (const e of t)
              if (e instanceof Je) {
                console.group("Initialize handler state");
                try {
                  const { state: t, accessVersion: r, settleVersion: n } = e;
                  console.log("Access version:", r),
                    console.log("Settle version:", n),
                    or(this, $t, "f").applyCheckpoint(r, n);
                  const i = Ct.createFromGameAccount(or(this, Yt, "f"), r, n);
                  console.log("Init account:", i),
                    await or(this, zt, "f").initState(or(this, $t, "f"), i),
                    void 0 !== t
                      ? (console.log("State:", t),
                        (or(this, $t, "f").handlerState = t))
                      : console.log("No state snapshot, start from beginning."),
                    console.log("Context created:", or(this, $t, "f")),
                    await this.invokeEventCallback(void 0);
                } finally {
                  console.groupEnd();
                }
              } else if (e instanceof Xe) {
                const { message: t } = e;
                console.log("Message:", t), or(this, tr, "f").call(this, t);
              } else {
                if (!(e instanceof Ke)) break;
                {
                  const { event: t, timestamp: r } = e;
                  console.group("Handle event: " + t.kind());
                  try {
                    console.log("Event:", t),
                      console.log(
                        "Timestamp:",
                        new Date(Number(r)).toLocaleTimeString(),
                      ),
                      (or(this, $t, "f").timestamp = r);
                    try {
                      let e = new At(or(this, $t, "f"));
                      await or(this, zt, "f").handleEvent(e, t),
                        sr(this, $t, e, "f"),
                        console.log("Game context:", or(this, $t, "f"));
                    } catch (e) {
                      console.error(e);
                    }
                    await this.invokeEventCallback(t);
                  } finally {
                    console.groupEnd();
                  }
                }
              }
          }
          async join(e) {
            const t = await or(this, Xt, "f").getGameAccount(this.gameAddr);
            if (void 0 === t) throw new Error("Game account not found");
            const r = t.players.length;
            if (t.maxPlayers <= r) throw new Error("Game is full");
            let n = e.position;
            if (void 0 === n)
              for (let e = 0; e < t.maxPlayers; e++)
                if (void 0 === t.players.find((t) => t.position === e)) {
                  n = e;
                  break;
                }
            if (void 0 === n) throw new Error("Game is full");
            const i = await or(this, rr, "f").exportPublicKey();
            await or(this, Xt, "f").join(or(this, Kt, "f"), {
              gameAddr: this.gameAddr,
              amount: e.amount,
              accessVersion: t.accessVersion,
              position: n,
              verifyKey: i.ec,
            });
          }
          async submitEvent(e) {
            let t = e instanceof Uint8Array ? e : e.serialize();
            const r = new he({ sender: this.playerAddr, raw: t });
            await or(this, Qt, "f").submitEvent(
              or(this, Zt, "f"),
              new We({ event: r }),
            );
          }
          async submitMessage(e) {
            await or(this, Qt, "f").submitMessage(
              or(this, Zt, "f"),
              new qe({ content: e }),
            );
          }
          async getRevealed(e) {
            return await or(this, Jt, "f").decrypt(or(this, $t, "f"), e);
          }
          async close() {
            or(this, Qt, "f").close();
          }
          async exit() {
            await or(this, Qt, "f").exitGame(or(this, Zt, "f"), {});
          }
          get info() {
            return or(this, ir, "f");
          }
        }
        (Zt = new WeakMap()),
          (zt = new WeakMap()),
          (Kt = new WeakMap()),
          (Jt = new WeakMap()),
          (Xt = new WeakMap()),
          (Qt = new WeakMap()),
          ($t = new WeakMap()),
          (Yt = new WeakMap()),
          (er = new WeakMap()),
          (tr = new WeakMap()),
          (rr = new WeakMap()),
          (nr = new WeakMap()),
          (ir = new WeakMap());
      },
      161: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getTokenListURL = t.ChainID = void 0),
          (function (e) {
            (e[(e.POLYGON = 137)] = "POLYGON"),
              (e[(e.MUMBAI = 80001)] = "MUMBAI");
          })(r || (t.ChainID = r = {}));
        const n = {
          [r.POLYGON]:
            "https://raw.githubusercontent.com/viaprotocol/tokenlists/main/tokenlists/polygon.json",
          [r.MUMBAI]:
            "https://raw.githubusercontent.com/viaprotocol/tokenlists/main/tokenlists/mumbai.json",
        };
        t.getTokenListURL = (e) => {
          if (!Object.values(r).includes(e))
            throw new Error(`unsupported ${e}`);
          return n[e];
        };
      },
      1134: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.NAME_LEN = t.PROFILE_ACCOUNT_LEN = void 0),
          (t.PROFILE_ACCOUNT_LEN = 130),
          (t.NAME_LEN = 16);
      },
      8629: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__importDefault) ||
          function (e) {
            return e && e.__esModule ? e : { default: e };
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getABIJSON = t.getContractAddress = void 0);
        const i = n(r(8296)),
          s = n(r(2774)),
          o = n(r(8438)),
          a = n(r(736)),
          c = n(r(9634)),
          d = r(161),
          u = {
            Token: c.default,
            NFT: a.default,
            Race: i.default,
            Registry: o.default,
            Profile: s.default,
          },
          l = {
            [d.ChainID.POLYGON]: {
              Token: "",
              Profile: "",
              Race: "",
              Registry: "",
            },
            [d.ChainID.MUMBAI]: {
              Token: "0x0a2664F0425a43EE03150BAd5751D35678F61d94",
              Profile: "0xA78ef0BF6BbD685e8bAE2E6036bf9e22ebE78621",
              Race: "0x9BF0C51B6cC55ce51619745605f35f74b03a2385",
              Registry: "0x0ab9567Ee93b9b6d5470F5671003Bc1549D97BAC",
            },
          };
        (t.getContractAddress = (e, t) => {
          if (!Object.values(d.ChainID).includes(e))
            throw new Error(`No contracts found for chainId: ${e}`);
          return l[e][t];
        }),
          (t.getABIJSON = (e) => u[e]);
      },
      7645: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.parseGameState = t.batchParseGameState = void 0);
        const n = r(978),
          i = r(9361),
          s = r(1531);
        function o(e) {
          const t = s.utils.hexToBytes(e.data);
          return new n.GameAccount({
            addr: (0, i.gameIDWithout0x)(e.gameID),
            accessVersion: e.accessVersion,
            bundleAddr: e.bundleAddr,
            data: t,
            dataLen: t.length,
            deposits: [],
            maxDeposit: e.maxDeposit,
            maxPlayers: e.maxPlayers,
            minDeposit: e.minDeposit,
            ownerAddr: e.owner,
            settleVersion: e.settleVersion,
            title: e.title,
            tokenAddr: e.token,
            transactorAddr: e.transactorAddr,
            unlockTime: e.unlockTime,
            players: e.players.map(
              (e) =>
                new n.PlayerJoin({
                  addr: e.addr,
                  position: Number(e.position),
                  balance: e.balance,
                  accessVersion: e.accessVersion,
                  verifyKey: e.verifyKey,
                }),
            ),
            servers: e.servers.map(
              (e) =>
                new n.ServerJoin({
                  addr: e.addr,
                  endpoint: e.endpoint,
                  accessVersion: e.accessVersion,
                  verifyKey: e.verifyKey,
                }),
            ),
            votes: e.votes.map(
              (e) =>
                new n.Vote({
                  votee: e.votee,
                  voter: e.voter,
                  voteType: e.voteType,
                }),
            ),
          });
        }
        (t.batchParseGameState = function (e) {
          const t = [];
          for (let r = 0; r < e.length; r++) t[r] = o(e[r]);
          return t;
        }),
          (t.parseGameState = o);
      },
      3169: function (e, t, r) {
        "use strict";
        var n,
          i,
          s =
            (this && this.__classPrivateFieldSet) ||
            function (e, t, r, n, i) {
              if ("m" === n)
                throw new TypeError("Private method is not writable");
              if ("a" === n && !i)
                throw new TypeError(
                  "Private accessor was defined without a setter",
                );
              if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError(
                  "Cannot write private member to an object whose class did not declare it",
                );
              return (
                "a" === n ? i.call(e, r) : i ? (i.value = r) : t.set(e, r), r
              );
            },
          o =
            (this && this.__classPrivateFieldGet) ||
            function (e, t, r, n) {
              if ("a" === r && !n)
                throw new TypeError(
                  "Private accessor was defined without a getter",
                );
              if ("function" == typeof t ? e !== t || !n : !t.has(e))
                throw new TypeError(
                  "Cannot read private member from an object whose class did not declare it",
                );
              return "m" === r
                ? n
                : "a" === r
                ? n.call(e)
                : n
                ? n.value
                : t.get(e);
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EVMTransport = void 0);
        const a = r(978),
          c = r(1134),
          d = r(8629),
          u = r(161),
          l = r(7645),
          h = r(9361),
          f = r(1531);
        (t.EVMTransport = class {
          constructor(e, t) {
            n.set(this, void 0),
              i.set(this, void 0),
              s(this, n, new Map(), "f"),
              (this.web3 = e),
              (this.chainID = t);
          }
          async _fetchLegacyTokens() {
            const e = await fetch((0, u.getTokenListURL)(this.chainID)),
              t = await e.json();
            s(this, i, t, "f");
          }
          async closeGameAccount(e, t) {
            const r = this.getContract("Race"),
              n = r.methods.closeGame((0, h.hexGameID)(t.gameAddr)).encodeABI();
            return await e.sendTransaction(
              { from: e.walletAddr, to: r.options.address, data: n },
              this.web3.eth,
            );
          }
          async createGameAccount(e, t) {
            if (t.title.length > c.NAME_LEN)
              throw new Error("Game title length exceeds 16 chars");
            const r = this.getContract("Race"),
              n = r.methods
                .createGameState(
                  t.bundleAddr,
                  t.tokenAddr,
                  t.title,
                  t.maxPlayers,
                  t.minDeposit,
                  t.maxDeposit,
                  f.utils.bytesToHex(t.data),
                )
                .encodeABI(),
              i = await e.sendTransaction(
                { from: e.walletAddr, to: r.options.address, data: n },
                this.web3.eth,
              ),
              s = await this.filterEventFromReceipt(
                i,
                r.options.jsonInterface,
                "CreateGame",
              );
            return (0, h.gameIDWithout0x)(s.returnValues.gameID);
          }
          async createPlayerProfile(e, t) {
            if (t.nick.length > c.NAME_LEN)
              throw new Error("Player nick name exceeds 16 chars");
            const r = this.getContract("Profile"),
              n = await r.methods.createProfile(t.nick, t.pfp).encodeABI();
            return await e.sendTransaction(
              { from: e.walletAddr, to: r.options.address, data: n },
              this.web3.eth,
            );
          }
          async createRegistration(e, t) {
            const r = this.getContract("Registry"),
              n = r.methods.createRegistry(t.isPrivate, t.size).encodeABI();
            return (
              await e.sendTransaction(
                { from: e.walletAddr, to: r.options.address, data: n },
                this.web3.eth,
              ),
              e.walletAddr
            );
          }
          deposit(e, t) {
            return Promise.resolve(void 0);
          }
          async fetchBalances(e, t) {
            const r = new Map();
            for (const n of t) {
              const t = new f.Contract(
                  (0, d.getABIJSON)("Token"),
                  n,
                  this.web3,
                ),
                i = await t.methods.balanceOf(e).call();
              r.set(n, i);
            }
            return r;
          }
          async getGameAccount(e) {
            const t = this.getContract("Race"),
              r = await t.methods.getGameState((0, h.hexGameID)(e)).call();
            return (0, l.parseGameState)(r);
          }
          async getGameBundle(e) {
            const t = this.getContract("Race");
            let r = await t.methods.getNFTInfo(e).call();
            return new a.GameBundle({
              name: r[0],
              uri: r[2],
              data: new Uint8Array(),
            });
          }
          async getNft(e) {
            const t = this.getContract("Race");
            let r = await t.methods.getNFTInfo(e).call();
            return {
              addr: e,
              name: r[0],
              symbol: r[1],
              image: "",
              collection: void 0,
            };
          }
          async getPlayerProfile(e) {
            const t = this.getContract("Profile");
            let r = await t.methods.getProfile(e).call();
            return new a.PlayerProfile({ addr: e, nick: r.nick, pfp: r.pfp });
          }
          async getRegistration(e) {
            const t = this.getContract("Registry");
            let r = await t.methods.getRegistry(e).call();
            return new a.RegistrationAccount({
              addr: e,
              games: r.games.map(
                (e) =>
                  new a.GameRegistration({
                    title: e.title,
                    addr: (0, h.gameIDWithout0x)(e.addr),
                    bundleAddr: e.bundleAddr,
                    regTime: e.regTime,
                  }),
              ),
              isPrivate: r.isPrivate,
              owner: r.owner,
              size: r.size,
            });
          }
          async getRegistrationWithGames(e) {
            let t = await this.getRegistration(e);
            if (void 0 === t) return Promise.resolve(void 0);
            let r = new a.RegistrationWithGames({
              addr: e,
              games: [],
              isPrivate: t.isPrivate,
              owner: t.owner,
              size: t.size,
            });
            const n = t.games.map((e) => (0, h.hexGameID)(e.addr)),
              i = this.getContract("Race"),
              s = await i.methods.batchGetGameState(n).call();
            return r.games.push(...(0, l.batchParseGameState)(s)), r;
          }
          async getServerAccount(e) {
            const t = this.getContract("Race");
            let r = await t.methods.getServer(e).call();
            return new a.ServerAccount({ addr: e, endpoint: r.endpoint });
          }
          async getToken(e) {
            let t;
            if (
              (void 0 === o(this, i, "f") && (await this._fetchLegacyTokens()),
              void 0 !== o(this, i, "f") &&
                (t = o(this, i, "f").find((t) => t.address == e)),
              null == t)
            ) {
              const r = new f.Contract(
                  (0, d.getABIJSON)("Token"),
                  e,
                  this.web3,
                ),
                n = await r.methods.name().call(),
                i = await r.methods.symbol().call(),
                s = await r.methods.decimals().call();
              t = { name: n, address: e, symbol: i, decimals: s, logoURI: "" };
            }
            return {
              addr: t.address,
              decimals: t.decimals,
              icon: t.logoURI,
              name: t.name,
              symbol: t.symbol,
            };
          }
          async hasEnoughAllowance(e, t, r, n) {
            return (await e.methods.allowance(t, r).call()) >= n;
          }
          async tokenApprove(e, t, r, n) {
            const i = t.methods.approve(r, n).encodeABI(),
              s = await e.sendTransaction(
                { from: e.walletAddr, to: t.options.address, data: i },
                this.web3.eth,
              );
            await this.waitForReceipt(s);
          }
          async join(e, t) {
            const r = (0, h.hexGameID)(t.gameAddr),
              n = this.getContract("Race"),
              i = await this.getGameAccount(r);
            if (void 0 === i) throw new Error("invalid game account");
            if (t.amount < i.minDeposit || t.amount > i.maxDeposit)
              throw new Error("invalid amount");
            const s = new f.Contract(
              (0, d.getABIJSON)("Token"),
              i.tokenAddr,
              this.web3,
            );
            (await this.hasEnoughAllowance(
              s,
              e.walletAddr,
              n.options.address,
              t.amount,
            )) || (await this.tokenApprove(e, s, n.options.address, t.amount));
            const o = n.methods
              .join(r, t.amount, t.accessVersion, t.position, t.verifyKey)
              .encodeABI();
            return await e.sendTransaction(
              { from: e.walletAddr, to: n.options.address, data: o },
              this.web3.eth,
            );
          }
          async listTokens() {
            const e = [],
              t = [(0, d.getContractAddress)(this.chainID, "Token")];
            for (let r of t) {
              const t = await this.getToken(r);
              void 0 !== t && e.push(t);
            }
            return e;
          }
          async listNfts(e) {
            const t = this.getContract("Race");
            return (await t.methods.getOwnerNFTList(e).call()).map((e) => ({
              addr: e.contractAddress,
              name: e.name,
              symbol: e.symbol,
              image: e.uri,
              collection: void 0,
            }));
          }
          async publishGame(e, t) {
            const r = this.getContract("Race"),
              n = r.methods.publishGame(t.name, t.symbol, t.uri).encodeABI(),
              i = await e.sendTransaction(
                { from: e.walletAddr, to: r.options.address, data: n },
                this.web3.eth,
              );
            return (
              await this.filterEventFromReceipt(
                i,
                r.options.jsonInterface,
                "PublishGame",
              )
            ).returnValues.nftContract;
          }
          async registerGame(e, t) {
            const r = this.getContract("Registry"),
              n = r.methods
                .registerGame(t.regAddr, (0, h.hexGameID)(t.gameAddr))
                .encodeABI();
            return await e.sendTransaction(
              { from: e.walletAddr, to: r.options.address, data: n },
              this.web3.eth,
            );
          }
          async unregisterGame(e, t) {
            const r = this.getContract("Registry"),
              n = r.methods
                .unregisterGame(t.regAddr, (0, h.hexGameID)(t.gameAddr))
                .encodeABI();
            return await e.sendTransaction(
              { from: e.walletAddr, to: r.options.address, data: n },
              this.web3.eth,
            );
          }
          async getNFTGameList(e) {
            const t = this.getContract("Race"),
              r = await t.methods.getNFTGameList(e).call();
            return (0, l.batchParseGameState)(r);
          }
          vote(e, t) {
            return Promise.resolve();
          }
          findEventABIByName(e, t) {
            const r = e.find((e) => e.name == t && "event" == e.type);
            if (void 0 === r) throw new Error(`event:${t} not found`);
            return r;
          }
          async filterEventFromReceipt(e, t, r) {
            const n = this.findEventABIByName(t, r),
              i = await this.waitForReceipt(e);
            for (let e of i.logs)
              if (e.topics && e.topics[0] == n.signature)
                return f.eth.contract.decodeEventABI(n, e, t);
            throw new Error(`tx ${e} event ${r} not found`);
          }
          async waitForReceipt(e, t = 0) {
            const r = await (0, h.waitTransaction)(this.web3, e, {
              interval: 500,
              blocksToWait: t,
            });
            if (null == r || !(0, h.isSuccessfulTransaction)(r))
              throw new Error(`tx ${e} failed`);
            return r;
          }
          getContract(e) {
            if (!o(this, n, "f").has(e)) {
              const t = new f.Contract(
                (0, d.getABIJSON)(e),
                (0, d.getContractAddress)(this.chainID, e),
                this.web3,
              );
              o(this, n, "f").set(e, t);
            }
            return o(this, n, "f").get(e);
          }
        }),
          (n = new WeakMap()),
          (i = new WeakMap());
      },
      9361: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.isSuccessfulTransaction =
            t.waitTransaction =
            t.gameIDWithout0x =
            t.hexGameID =
              void 0);
        const n = r(8840),
          i = r(3087);
        (t.hexGameID = function (e) {
          return (0, n.isHexString)(e) ? e : `0x${e}`;
        }),
          (t.gameIDWithout0x = function (e) {
            return (0, n.isHexString)(e) ? e.substring(2, e.length) : e;
          }),
          (t.waitTransaction = function (e, t, r) {
            const n = r && r.interval ? r.interval : 500,
              s = r && r.blocksToWait ? r.blocksToWait : 0,
              o = async function (t, r, a) {
                try {
                  const i = await e.eth.getTransactionReceipt(t);
                  if (0 == s) return void r(i);
                  if (
                    (await e.eth.getBlockNumber()) - BigInt(i.blockNumber) >=
                    s
                  )
                    return void r(i);
                  setTimeout(function () {
                    o(t, r, a);
                  }, n);
                } catch (e) {
                  e.code && e.code == i.ERR_TX_NOT_FOUND
                    ? setTimeout(function () {
                        o(t, r, a);
                      }, n)
                    : a(e);
                }
              };
            return new Promise(function (e, r) {
              o(t, e, r);
            });
          }),
          (t.isSuccessfulTransaction = function (e) {
            return "0x1" == e.status || 1 == e.status;
          });
      },
      672: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EVMWalletAdapter = void 0);
        const n = r(1531);
        t.EVMWalletAdapter = class {
          constructor(e) {
            this.wallet = e;
          }
          get walletAddr() {
            return n.utils.toChecksumAddress(this.wallet.selectedAddress);
          }
          get isConnected() {
            return this.wallet.isConnected();
          }
          async sendTransaction(e, t) {
            //合约因为for循环，gas会递增
            let gas = parseInt(await this.estimateGas(e));
            gas = parseInt(gas*1.2);
            let newGas = "0x"+gas.toString(16);
            return (
              e.gas || (e.gas = newGas),
              await this.wallet.request({
                method: "eth_sendTransaction",
                params: [e],
              })
            );
          }
          async estimateGas(e) {
            return await this.wallet.request({
              method: "eth_estimateGas",
              params: [e],
            });
          }
        };
      },
      195: function (e, t, r) {
        "use strict";
        var n,
          i,
          s,
          o,
          a =
            (this && this.__classPrivateFieldSet) ||
            function (e, t, r, n, i) {
              if ("m" === n)
                throw new TypeError("Private method is not writable");
              if ("a" === n && !i)
                throw new TypeError(
                  "Private accessor was defined without a setter",
                );
              if ("function" == typeof t ? e !== t || !i : !t.has(e))
                throw new TypeError(
                  "Cannot write private member to an object whose class did not declare it",
                );
              return (
                "a" === n ? i.call(e, r) : i ? (i.value = r) : t.set(e, r), r
              );
            },
          c =
            (this && this.__classPrivateFieldGet) ||
            function (e, t, r, n) {
              if ("a" === r && !n)
                throw new TypeError(
                  "Private accessor was defined without a getter",
                );
              if ("function" == typeof t ? e !== t || !n : !t.has(e))
                throw new TypeError(
                  "Cannot read private member from an object whose class did not declare it",
                );
              return "m" === r
                ? n
                : "a" === r
                ? n.call(e)
                : n
                ? n.value
                : t.get(e);
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.WallConnectAdapter = void 0);
        const d = r(1531);
        (t.WallConnectAdapter = class {
          constructor(e, t) {
            if (
              (n.set(this, void 0),
              i.set(this, void 0),
              s.set(this, void 0),
              o.set(this, void 0),
              a(this, n, e, "f"),
              a(this, i, t, "f"),
              a(this, s, "", "f"),
              a(this, o, "", "f"),
              !c(this, n, "f").session.length)
            )
              return;
            // const r = c(this, n, "f").session.map.get(c(this, i, "f")),
            //   u = Object.values(r?.namespaces)
            //     .map((e) => e.accounts)
            //     .flat();
            const sessionEntry = c(this, n, "f").session.map.get(c(this, i, "f"));
            let u = [];

            if (typeof sessionEntry !== 'undefined' && sessionEntry.namespaces) {
              u = Object.values(sessionEntry.namespaces)
                .map((e) => e.accounts)
                .flat();
            }
            if (0 == u.length) return;
            const [l, h, f] = u[0].split(":");
            a(this, o, `${l}:${h}`, "f"),
              a(this, s, d.utils.toChecksumAddress(f), "f");
          }
          get walletAddr() {
            return c(this, s, "f");
          }
          get isConnected() {
            return !!c(this, s, "f");
          }
          async sendTransaction(e, t) {
            return (
              e.gas || (e.gas = Number(await t.estimateGas(e))),
              c(this, n, "f").request({
                topic: c(this, i, "f"),
                chainId: c(this, o, "f"),
                request: { method: "eth_sendTransaction", params: [e] },
              })
            );
          }
        }),
          (n = new WeakMap()),
          (i = new WeakMap()),
          (s = new WeakMap()),
          (o = new WeakMap());
      },
      6601: () => {},
      30: (e, t) => {
        "use strict";
        function r(e) {
          return (function (e) {
            let t = 0;
            return () => e[t++];
          })(
            (function (e) {
              let t = 0;
              function r() {
                return (e[t++] << 8) | e[t++];
              }
              let n = r(),
                i = 1,
                s = [0, 1];
              for (let e = 1; e < n; e++) s.push((i += r()));
              let o = r(),
                a = t;
              t += o;
              let c = 0,
                d = 0;
              function u() {
                return (
                  0 == c && ((d = (d << 8) | e[t++]), (c = 8)), (d >> --c) & 1
                );
              }
              const l = 2 ** 31,
                h = l >>> 1,
                f = l - 1;
              let p = 0;
              for (let e = 0; e < 31; e++) p = (p << 1) | u();
              let m = [],
                y = 0,
                g = l;
              for (;;) {
                let e = Math.floor(((p - y + 1) * i - 1) / g),
                  t = 0,
                  r = n;
                for (; r - t > 1; ) {
                  let n = (t + r) >>> 1;
                  e < s[n] ? (r = n) : (t = n);
                }
                if (0 == t) break;
                m.push(t);
                let o = y + Math.floor((g * s[t]) / i),
                  a = y + Math.floor((g * s[t + 1]) / i) - 1;
                for (; 0 == ((o ^ a) & h); )
                  (p = ((p << 1) & f) | u()),
                    (o = (o << 1) & f),
                    (a = ((a << 1) & f) | 1);
                for (; o & ~a & 536870912; )
                  (p = (p & h) | ((p << 1) & (f >>> 1)) | u()),
                    (o = (o << 1) ^ h),
                    (a = ((a ^ h) << 1) | h | 1);
                (y = o), (g = 1 + a - o);
              }
              let v = n - 4;
              return m.map((t) => {
                switch (t - v) {
                  case 3:
                    return (
                      v + 65792 + ((e[a++] << 16) | (e[a++] << 8) | e[a++])
                    );
                  case 2:
                    return v + 256 + ((e[a++] << 8) | e[a++]);
                  case 1:
                    return v + e[a++];
                  default:
                    return t - 1;
                }
              });
            })(
              (function (e) {
                let t = [];
                [
                  ..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
                ].forEach((e, r) => (t[e.charCodeAt(0)] = r));
                let r = e.length,
                  n = new Uint8Array((6 * r) >> 3);
                for (let i = 0, s = 0, o = 0, a = 0; i < r; i++)
                  (a = (a << 6) | t[e.charCodeAt(i)]),
                    (o += 6),
                    o >= 8 && (n[s++] = a >> (o -= 8));
                return n;
              })(e),
            ),
          );
        }
        function n(e) {
          return 1 & e ? ~e >> 1 : e >> 1;
        }
        function i(e, t) {
          let r = Array(e);
          for (let i = 0, s = 0; i < e; i++) r[i] = s += n(t());
          return r;
        }
        function s(e, t = 0) {
          let r = [];
          for (;;) {
            let n = e(),
              i = e();
            if (!i) break;
            t += n;
            for (let e = 0; e < i; e++) r.push(t + e);
            t += i + 1;
          }
          return r;
        }
        function o(e) {
          return c(() => {
            let t = s(e);
            if (t.length) return t;
          });
        }
        function a(e) {
          let t = [];
          for (;;) {
            let r = e();
            if (0 == r) break;
            t.push(u(r, e));
          }
          for (;;) {
            let r = e() - 1;
            if (r < 0) break;
            t.push(l(r, e));
          }
          return t.flat();
        }
        function c(e) {
          let t = [];
          for (;;) {
            let r = e(t.length);
            if (!r) break;
            t.push(r);
          }
          return t;
        }
        function d(e, t, r) {
          let n = Array(e)
            .fill()
            .map(() => []);
          for (let s = 0; s < t; s++) i(e, r).forEach((e, t) => n[t].push(e));
          return n;
        }
        function u(e, t) {
          let r = 1 + t(),
            n = t(),
            i = c(t);
          return d(i.length, 1 + e, t).flatMap((e, t) => {
            let [s, ...o] = e;
            return Array(i[t])
              .fill()
              .map((e, t) => {
                let i = t * n;
                return [s + t * r, o.map((e) => e + i)];
              });
          });
        }
        function l(e, t) {
          return d(1 + t(), 1 + e, t).map((e) => [e[0], e.slice(1)]);
        }
        var h = r(
          "AEgSbwjEDVYByQKaAQsBOQDpATQAngDUAHsAoABoANQAagCNAEQAhABMAHIAOwA9ACsANgAmAGIAHgAvACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGAAeABMAFwAXAA0ADgAWAA8AFAAVBFsF1QEXE0o3xAXUALIArkABaACmAgPGAK6AMDAwMAE/qAYK7P4HQAblMgVYBVkAPSw5Afa3EgfJwgAPA8meNALGCjACjqIChtk/j2+KAsXMAoPzASDgCgDyrgFCAi6OCkCQAOQA4woWABjVuskNDD6eBBx4AP4COhi+D+wKBirqBgSCaA0cBy4ArABqku+mnIAAXAaUJAbqABwAPAyUFvyp/Mo8INAIvCoDshQ8APcubKQAon4ZABgEJtgXAR4AuhnOBPsKIE04CZgJiR8cVlpM5INDABQADQAWAA9sVQAiAA8ASO8W2T30OVnKluYvChEeX05ZPe0AFAANABYAD2wgXUCYAMPsABwAOgzGFryp/AHauQVcBeMC0KACxLEKTR2kZhR0Gm5M9gC8DmgC4gAMLjSKF8qSAoF8ARMcAL4OaALiAAwuAUlQJpJMCwMt/AUpCthqGK4B2EQAciwSeAIyFiIDKCi6OGwAOuIB9iYAyA7MtgEcZIIAsgYABgCK1EoFHNZsGACoKNIBogAAAAAAKy4DnABoAQoaPu43dQQZGACrAcgCIgDgLBJ0OvRQsTOiKDVJBfsoBVoFWbC5BWo7XkITO1hCmHuUZmCh+QwUA8YIJvJ4JASkTAJUVAJ2HKwoAZCkpjZcA0YYBIRiCgDSBqxAMCQHKgI6XgBsAWIgcgCEHhoAlgFKuAAoahgBsMYDOC4iRFQBcFoGZgJmAPJKGAMqAgYASkIArABeAHQALLYGCPTwGo6AAAAKIgAqALQcSAHSAdwIDDKXeYHpAAsAEgA1AD4AOTR3etTBEGAQXQJNCkxtOxUMAq0PpwvmERYM0irM09kANKoH7ANUB+wDVANUB+wH7ANUB+wDVANUA1QDVBwL8BvUwRBgD0kEbgWPBYwE1wiEJkoRggcpCNNUDnQfHEgDRgD9IyZJHTuUMwwlQ0wNTQQH/TZDbKh9OQNIMaxU9pCjA8wyUDltAh5yEqEAKw90HTW2Tn96SHGhCkxPr7WASWNOaAK/Oqk/+QoiCZRvvHdPBj4QGCeiEPQMMAGyATgN6kvVBO4GOATGH3oZFg/KlZkIoi3aDOom4C6egFcj8iqABepL8TzaC0pRZQ9WC2IJ4DpggUsDHgEKIogK2g02CGoQ8ArGaA3iEUIHNgPSSZcAogb+Cw4dMhWyJg1iqQsGOXQG+BrzC4wmrBMmevkF0BoeBkoBJhr8AMwu5IWtWi5cGU9cBgALIiPEFKVQHQ0iQLR4RRoYBxIlpgKOQ21KhFEzHpAh8zw6DWMuEFF5B/I8AhlMC348m0aoRQsRzz6KPUUiRkwpBDJ8LCwniAnMD4IMtnxvAVYJHgmuDG4TLhEUN8IINgcWKpchJxIIHkaSYJcE9JwD8BPOAwgFPAk+BxADshwqEysVJgUKgSHUAvA20i6wAoxWfQEUBcgPIh/cEE1H3Q7mCJgCYgOAJegAKhUeABQimAhAYABcj9VTAi7ICMRqaSNxA2QU5F4RcAeODlQHpBwwFbwc3nDFXgiGBSigrAlYAXIJlgFcBOAIBjVYjJ0gPmdQi1UYmCBeQTxd+QIuDGIVnES6h3UCiA9oEhgBMgFwBzYM/gJ0EeoRaBCSCOiGATWyM/U6IgRMIYAgDgokA0xsywskJvYM9WYBoBJfAwk0OnfrZ6hgsyEX+gcWMsJBXSHuC49PygyZGr4YP1QrGeEHvAPwGvAn50FUBfwDoAAQOkoz6wS6C2YIiAk8AEYOoBQH1BhnCm6MzQEuiAG0lgNUjoACbIwGNAcIAGQIhAV24gAaAqQIoAACAMwDVAA2AqoHmgAWAII+AToDJCwBHuICjAOQCC7IAZIsAfAmBBjADBIA9DRuRwLDrgKAZ2afBdpVAosCRjIBSiIEAktETgOsbt4A2ABIBhDcRAESqEfIF+BAAdxsKADEAPgAAjIHAj4BygHwagC0AVwLLgmfsLIBSuYmAIAAEmgB1AKGANoAMgB87gFQAEoFVvYF0AJMRgEOLhUoVF4BuAMcATABCgB2BsiKosYEHARqB9ACEBgV3gLvKweyAyLcE8pCwgK921IAMhMKNQqkCqNgWF0wAy5vPU0ACx+lPsQ/SwVOO1A7VTtQO1U7UDtVO1A7VTtQO1UDlLzfvN8KaV9CYegMow3RRMU6RhPYYE5gLxPFLbQUvhXLJVMZOhq5JwIl4VUGDwEt0GYtCCk0che5ADwpZYM+Y4MeLQpIHORTjlT1LRgArkufM6wNqRsSRD0FRHXqYicWCwofAmR+AmI/WEqsWDcdAqH0AmiVAmYGAp+BOBgIAmY4AmYjBGsEfAN/EAN+jzkDOXQUOX86ICACbBoCMjM4BwJtxAJtq+yHMGRCKAFkANsA3gBHAgeVDIoA+wi/AAqyAncsAnafPAJ5SEACeLcaWdhFq0bwAnw8AnrFAn0GAnztR/1IemAhACgSSVVKWBIUSskC0P4C0MlLJAOITAOH40TCkS8C8p5dAAMDq0vLTCoiAMxNSU2sAos8AorVvhgEGkBkArQCjjQCjlk9lH4CjtYCjll1UbFTMgdS0VSCApP4ApMJAOYAGVUbVaxVzQMsGCmSgzLeeGNFODYCl5wC769YHqUAViIClowClnmZAKZZqVoGfkoAOAKWsgKWS1xBXM4CmcgCmWFcx10EFgKcmDm/OpoCnBMCn5gCnrWHABoMLicMAp3uAp6PALI6YTFh7AKe0AKgawGmAp6cHAKeS6JjxWQkIigCJ6wCJnsCoPgCoEnUAqYsAqXLAqf8AHoCp+9oeWiuAABGahlqzgKs4AKsqwKtZAKs/wJXGgJV2QKx3tQDH0tslAKyugoCsuUUbN1tYG1FXAMlygK2WTg8bo0DKUICuFsCuUQSArkndHAzcN4CvRYDLa8DMg4CvoVx/wMzbgK+F3Mfc0wCw8gCwwFzf3RIMkJ03QM8pAM8lwM9vALFeQLGRALGDYYCyGZOAshBAslMAskrAmSaAt3PeHZeeKt5IkvNAxigZv8CYfEZ8JUhewhej164DgLPaALPaSxIUM/wEJwAw6oCz3ABJucDTg9+SAIC3CQC24cC0kwDUlkDU1wA/gNViYCGPMgT6l1CcoLLg4oC2sQC2duEDYRGpzkDhqIALANkC4ZuVvYAUgLfYgLetXB0AuIs7REB8y0kAfSYAfLPhALr8ALpbXYC6vYC6uEA9kQBtgLuhgLrmZanlwAC7jwDhd2YdnDdcZ4C8wAAZgOOE5mQAvcQA5FrA5KEAveVAvnWAvhjmhmaqLg0mxsDnYAC/vcBGAA2nxmfsAMFigOmZwOm1gDOwgMGZ6GFogIGAwxGAQwBHAdqBl62ZAIAuARovA6IHrAKABRyNgAgAzASSgOGfAFgJB4AjOwAHgDmoAScjgi0BhygwgCoBRK86h4+PxZ5BWk4P0EsQiJCtV9yEl+9AJbGBTMAkE0am7o7J2AzErrQDjAYxxiKyfcFWAVZBVgFWQVkBVkFWAVZBVgFWQVYBVkFWAVZRxYI2IZoAwMDCmVe6iwEygOyBjC8vAC8BKi8AOhBKhazBUc+aj5xQkBCt192OF/pAFgSM6wAjP/MbMv9puhGez4nJAUsFyg3Nn5u32vB8hnDLGoBbNdvMRgFYAVrycLJuQjQSlwBAQEKfV5+jL8AND+CAAQW0gbmriQGAIzEDAMCDgDlZh4+JSBLQrJCvUI5JF8oYDcoOSQJwj4KRT9EPnk+gj5xPnICikK9SkM8X8xPUGtOCy1sVTBrDG8gX+E0OxwJaJwKYyQsPR4nQqxCvSzMAsv9X8oPIC8KCQoAACN+nt9rOy5LGMmsya0JZsLMzQphQWAP5hCkEgCTjh5GQiYbqm06zjkKND9EPnFCQBwICx5NSG1cLS5a4rwTCn7uHixCQBxeCUsKDzRVREM4BTtEnC0KghwuQkAb9glUIyQZMTIBBo9i8F8KcmTKYAxgLiRvAERgGjoDHB9gtAcDbBFmT2BOEgIAZOhgFmCWYH5gtGBMYJJpFhgGtg/cVqq8WwtDF6wBvCzOwgMgFgEdBB8BegJtMDGWU4EBiwq5SBsA5SR0jwvLDqdN6wGcAoidUAVBYAD4AD4LATUXWHsMpg0lILuwSABQDTUAFhO4NVUC0wxLZhEcANlPBnYECx9bADIAtwKbKAsWcKwzOaAaAVwBhwn9A9ruEAarBksGugAey1aqWwq7YhOKCy1ADrwBvAEjA0hbKSkpIR8gIi0TJwciDY4AVQJvWJFKlgJvIA9ySAHUdRDPUiEaqrFN6wcSBU1gAPgAPgsBewAHJW0LiAymOTEuyLBXDgwAYL0MAGRKaFAiIhzAADIAtwKbKC08D88CkRh8ULxYyXRzjtilnA72mhU+G+0S2hIHDxwByAk7EJQGESwNNwwAPAC0zwEDAKUA4gCbizAAFQBcG8cvbXcrDsIRAzwlRNTiHR8MG34CfATCC6vxbQA4Oi4Opzkuz6IdB7wKABA7Ls8SGgB9rNsdD7wbSBzOoncfAT4qYB0C7KAJBE3z5R9mDL0M+wg9Cj8ABcELPgJMDbwIvQ09CT0KvS7PoisOvAaYAhwPjBriBBwLvBY8AKELPBC8BRihe90AO2wMPQACpwm9BRzR9QYFB2/LBnwAB7wSXBISvQECAOsCAAB1FVwHFswV/HAXvBg8AC68AuyovAAevAJWISuAAAG8AALkFT0VvCvso7zJqDwEAp8nTAACXADn3hm8CaVcD7/FAPUafAiiBQv/cQDfvKe8GNwavKOMeXMG/KmchAASvAcbDAADlABtvAcAC7ynPAIaPLsIopzLDvwHwak8AOF8L7dtvwNJAAPsABW8AAb8AAm8AGmMABq8AA68Axi8jmoV/AABXAAObAAuTB8ABrwAF7wIIgANSwC6vCcAA7wADpwq7ACyWwAcHAAbvAAB7AqiAAXHCxYV3AAHnABCvAEDAGm8AAt8AB28AAi8CaIABcsAbqAZ1gCSCCIABcsAATwAB9wAHZwIIgAGmwAJfAAbLABtHADmvIEACFwACDwAFLwAaPwJIgAGywDjjAAJPAuiDsX7YAAHPABunUBJAEgACrwFAAM8AAmuAzgABxwAGXwAAgym/AAKHAAKPAAJ/KfsBrwACRwAAwwAEDwBABQ8ABFsAA+MAA3sAA28ABkMBxYcABU8AG6cFrQBvAC7ABM8BABpLAsA4UwAAjwABFMAF3wFHAAG0QAYvB8BfClTADpGALAJBw4McwApK3EBpQYIXwJtJA0ACghwTG1gK4oggRVjLjcDogq1AALZABcC/ARvAXdzSFMVIgNQAhY/AS0GBHRHvnxTe0EAKgAyAvwAVAvcAHyRLQEsAHfmDhIzRwJLAFgGAAJRAQiLzQB5PAQhpgBbANcWAJZpOCCMAM5ssgDQ1RcJw3Z0HBlXHgrSAYmRrCNUVE5JEz3DivoAgB04QSos4RKYUABzASosMSlDGhADMVYE+MbvAExm3QBrAnICQBF7Osh4LzXWBhETIAUVCK6v/xPNACYAAQIbAIYAiQCONgDjALQA1QCdPQC7AKsApgChAOcAnwDTAJwA4AEBAPwAwAB6AFsAywDNAPwA1wDrAIkAogEqAOMA2ADVBAIIKzTT09PTtb/bzM/NQjEWAUsBVS5GAVMBYgFhAVQBRUpCRGcMAUwUBgkEMzcMBwAgDSQmKCs3OTk8PDw9Pg0/HVBQUFBSUlFSKFNUVlVVHFxgYF9hYCNlZ29ucXFxcXFxc3Nzc3Nzc3Nzc3N1dXZ1dFsAPesAQgCTAHEAKwBf8QCHAFAAUAAwAm/oAIT+8fEAXQCM6wCYAEgAWwBd+PipAH4AfgBiAE8AqgAdAK8AfAI5AjwA9QDgAPcA9wDhAPgA4gDiAOEA3wAoAnQBSgE5ATcBTQE3ATcBNwEyATEBMQExARUBURAAKgkBAEwYCxcEFhcPAIcAjwCfAEoAYxkCKgBvAGgAkAMOAyArAxpCP0gqAIoCSADAAlACnQC5Ao8CjwKPAo8CjwKPAoQCjwKPAo8CjwKPAo8CjgKOApECmQKQAo8CjwKNAo0CjQKNAosCjgJuAc0CkAKYAo8CjwKOF3oMAPcGA5gCWgIzGAFNETYC2xILLBQBRzgUTpIBdKU9AWJaAP4DOkgA/wCSKh4ZkGsAKmEAagAvAIoDlcyM8K+FWwa7LA/DEgKe1nUrCwQkWwGzAN5/gYB/gX+Cg4N/hIeFf4aJh4GIg4mDin+Lf4x/jYuOf49/kIORf5J/k3+Uf5WElomXg5h/AIMloQCEBDwEOQQ7BD4EPARCBD8EOgRABEIEQQQ9BD8EQgCkA4gAylIA0AINAPdbAPcBGgD3APUA9QD2APXVhSRmvwD3APUA9QD2APUdAIpbAPcAigEaAPcAigLtAPcAitWFJGa/HQD4WwEaAPcA9wD1APUA9gD1APgA9QD1APYA9dWFJGa/HQCKWwEaAPcAigD3AIoC7QD3AIrVhSRmvx0CRAE3AksBOgJMwgOfAu0Dn9WFJGa/HQCKWwEaA58AigOfAIoC7QOfAIrVhSRmvx0EMQCKBDIAigeOMm4hLQCKAT9vBCQA/gDHWwMAVVv/FDMDAIoDPtkASgMAigMAl2dBtv/TrfLzakaPh3aztmIuZQrR3ER2n5Yo+qNR2jK/aP/V04UK1njIJXLgkab9PjOxyJDVbIN3R/FZLoZVl2kYFQIZ7V6LpRqGDt9OdDohnJKp5yX/HLj0voPpLrneDaN11t5W3sSM4ALscgSw8fyWLVkKa/cNcQmjYOgTLZUgOLi2F05g4TR0RfgZ4PBdntxdV3qvdxQt8DeaMMgjJMgwUxYN3tUNpUNx21AvwADDAIa0+raTWaoBXmShAl5AThpMi282o+WzOKMlxjHj7a+DI6AM6VI9w+xyh3Eyg/1XvPmbqjeg2MGXugHt8wW03DQMRTd5iqqOhjLvyOCcKtViGwAHVLyl86KqvxVX7MxSW8HLq6KCrLpB8SspAOHO9IuOwCh9poLoMEha9CHCxlRAXJNDobducWjqhFHqCkzjTM2V9CHslwq4iU19IxqhIFZMve15lDTiMVZIPdADXGxTqzSTv0dDWyk1ht430yvaYCy9qY0MQ3cC5c1uw4mHcTGkMHTAGC99TkNXFAiLQgw9ZWhwKJjGCe+J5FIaMpYhhyUnEgfrF3zEtzn40DdgCIJUJfZ0mo3eXsDwneJ8AYCr7Vx2eHFnt2H6ZEyAHs9JoQ4Lzh5zBoGOGwAz37NOPuqSNmZf51hBEovtpm2T1wI79OBWDyvCFYkONqAKGVYgIL0F+uxTcMLSPtFbiNDbBPFgip8MGDmLLHbSyGXdCMO6f7teiW9EEmorZ+75KzanZwvUySgjoUQBTfHlOIerJs6Y9wLlgDw18AB1ne0tZRNgGjcrqHbtubSUooEpy4hWpDzTSrmvqw0H9AoXQLolMt9eOM+l9RitBB1OBnrdC1XL4yLFyXqZSgZhv7FnnDEXLUeffb4nVDqYTLY6X7gHVaK4ZZlepja2Oe6OhLDI/Ve5SQTCmJdH3HJeb14cw99XsBQAlDy5s5kil2sGezZA3tFok2IsNja7QuFgM30Hff3NGSsSVFYZLOcTBOvlPx8vLhjJrSI7xrNMA/BOzpBIJrdR1+v+zw4RZ7ry6aq4/tFfvPQxQCPDsXlcRvIZYl+E5g3kJ+zLMZon0yElBvEOQTh6SaAdIO6BwdqJqfvgU+e8Y65FQhdiHkZMVt9/39N2jGd26J6cNjq8cQIyp6RonRPgVn2fl89uRDcQ27GacaN0MPrcNyRlbUWelKfDfyrNVVGBG5sjd3jXzTx06ywyzuWn5jbvEfPPCTbpClkgEu9oPLKICxU5HuDe3jA1XnvU85IYYhaEtOU1YVWYhEFsa4/TQj3rHdsU2da2eVbF8YjSI0m619/8bLMZu3xildwqM7zf1cjn4Whx0PSYXcY5bR7wEQfGC7CTOXwZdmsdTO8q3uGm7Rh/RfCWwpzBHCAaVfjxgibL5vUeL0pH6bzDmI9yCXKC/okkmbc28OJvI87L/bjFzpq0DHepw4kT1Od+fL7cyuFaRgfaUWB2++TCFvz11J0leEtrGkpccfX9z2LY39sph4PBHCjNOOkd0ybUm+ZzS8GkFbqMpq8uiX2yHpa0jllTLfGTDBMYR6FT5FWLLDPMkYxt1Q0eyMvxJWztDjy0m6VvZPvamrFXjHmPpU6WxrZqH6WW//I37RwvqPQhPz8I3RPuXAk1C94ZprQWm9iGM/KgiGDO6SV9sjp+Jmk4TBajMNJ5zzWZ1k1jrteQQBp9C2dOvmbIeeEME8y573Q8TgGe+ZCzutM45gYLBzYm2LNvgq2kebAbMpHRDSyh6dQ27GbsAAdCqQVVXWC1C+zpwBM2Lr4eqtobmmu1vJEDlIQR1iN8CUWpztq50z7FFQBn3SKViX6wSqzVQCoYvAjByjeSa+h1PRnYWvBinTDB9cHt4eqDsPS4jcD3FwXJKT0RQsl8EvslI2SFaz2OtmYLFV8FwgvWroZ3fKmh7btewX9tfL2upXsrsqpLJzpzNGyNlnuZyetg7DIOxQTMBR7dqlrTlZ6FWi1g4j1NSjA2j1Yd7fzTH6k9LxCyUCneAKYCU581bnvKih6KJTeTeCX4Zhme/QIz7w2o+AdSgtLAkdrLS9nfweYEqrMLsrGGSWXtgWamAWp6+x6GM/Z8jNw3BqPNQ39hrzYLECn3tPvh/LqKbRSCiDGauDKBBj/kGbpnM1Bb/my8hv4NWStclkwjfl57y4oNDgw1JAG9VOti3QVVoSziMEsSdfEjaCPIDb7SgpLXykQsM+nbqbt97I0mIlzWv0uqFobLMAq8Rd9pszUBKxFhBPwOjf//gVOz2r7URJ2OnpviCXv9iz3a4X/YLBYbXoYwxBv/Kq0a5s4utQHzoTerJ7PmFW/no/ZAsid/hRIV82tD+Qabh5F1ssIM8Ri3chu0PuPD3sSJRMjDoxLAbwUbroiPAz/V52e8s3DIixxlO7OrvhMj3qfzA0kKxzwicr5wJmZwJxTXgrwYsqhRvpgC2Nfdyd+TYYxJSZgk+gk2g9KyHSlwQVAyPtWWgvVGyVBqsU2LpDlLNosSAtolC1uBKt5pQZLhAxTjeGCWIC/HVpagc5rRwkgpCHKEsjA8d+scp8aiMewwQBhp5dYTV5t/Nvl+HbDMu8F3S0psPyZb1bSnqlHPFUnMQeQqSqwDBT23fJO9gO3aVaa1icrXU0PKwlMM5K+iL3ATcVq2fFWKk0irCTF4LDVDG4gUpkyplq6efcZS+WDR1woApjD18x+2JQR9oOXzuA7uy4b+/91WsJd/tSd1QcAH8PVPXApieA37B7YXPhDPH1azP3PKR+HfHmOoDYLeuKsIi/ssSsdYs62qJo14Hw1P2N/6zpr8F3FTWmJ4ysAVcl84Iv/tl///Z8FaAWbBQbyMNDZjrZ2JwdRjtd1jOeNumSodFtr4/Zf45iRJf/8HSW+KIB/+GlKu8Rv1BPLr/4duoL+kFPRqrstEr41gfJupoJRf4hcYDWX93FOcfEBiIivxtjtV8g7mvOReiamYWKE7vfPbv3v2L9Kwq3cIDFGLyhyfOGuf/9vA5muH6Pjg7B4SUj2ydDXra9fSBI+DrsNHA6l51wfHssJb+11TfNk7B8OleUe3Y+ZmHboMFHdv7FFP2cfISFyeAQR0sk/Xv62HBTdW4HmnGSLFk/cqyWVVFJkdIIa+4hos3JRHcqLoRKM5h2Qtk1RZtzISMtlXTfTqIc77YsCCgQD0r61jtxskCctwJOtjE/pL8wC4LBD4AZFjh2wzzFCrT/PNqW0/DeBbkfMfzVm9yy06WiF+1mTdNNEAytVtohBKg3brWd2VQa+aF+cQ0mW5CvbwOlWCT07liX226PjiVLwFCRs/Ax2/u+ZNPjrNFIWIPf5GjHyUKp60OeXe9F01f7IaPf/SDTvyDAf7LSWWejtiZcsqtWZjrdn6A2MqBwnSeKhrZOlUMmgMionmiCIvXqKZfmhGZ1MwD3uMF4n9KJcfWLA3cL5pq48tm5NDYNh3SS/TKUtmFSlQR89MR4+kxcqJgpGbhm9gXneDELkyqAN5nitmIzTscKeJRXqd64RiaOALR2d295NWwbjHRNG2AU5oR9OS2oJg/5CY6BFPc1JvD2Mxdhp2/MZdI8dLePxiP4KRIp8VXmqfg+jqd/RNG7GNuq1U2SiI4735Bdc0MVFx6mH5UOWEa5HuhYykd6t4M1gYLVS8m1B+9bUqi5DziQq7qT8d94cxB6AB4WqMCOF/zPPtRSZUUaMSsvHOWxGASufywTX8ogy6HgUf9p+Z30wUEosl8qgmwm6o2AV6nO9HKQjRHpN6SUegI5pvR61RLnUJ1lqCtmfcsRQutEizVpAaPXN7xMp5UQ5OSZK6tniCK9CpyMd7LjR6+MxfoMEDPpWdf2p2m5N3KO4QMxf+V7vGdYjemQczQ+m2MGIkFNYDMf0Yop2eSx81sP36WHUczqEhKysp2iJSYAvfgJjinKwToPvRKb+HBi+7cJ96S5ngfLOXaHAFRLkulo4TnXTFO51gX0TCCo4ZUHdbpdgkMEwUZAPjh6M+hA8DzycbtxAgH3uD6i0nN1aTiIuQ4BYCE9dEHHwAmINU+4YEWx4EC3OZwFGfYZMPLScVlb+BAAJeARUh+gdWA3/gRqCrf1jecgqeFf1MdzrrP4SVlGm5mMihSP+zYYksAB7O+SBPwNQqSNMiLnkviY/klwgcRmvqtCqeWeA0gjuir4CMZqmw/ntP6M+l0pdN8/P9xI53aP7x/zavJbbKOz8VzO/nXxIr1tjparMnqd6iWdByHKw4lF4p/u57Yv07WeZPDnRl7wgmDVZZ44fQsjdYO/gmXQ+940PRGst8UMQApFC4OOV22e4N+lVOPyFLAOj4t8R3PFw/FjbSWy0ELuAFReNkee8ORcBOT2NPDcs7OfpUmzvn/F9Czk9o9naMyVYy/j8I5qVFmQDFcptBp65J/+sJA3w/j6y/eqUkKxTsf0CZjtNdRSBEmJ2tmfgmJbqpcsSagk+Ul9qdyV+NnqFBIJZFCB1XwPvWGDBOjVUmpWGHsWA5uDuMgLUNKZ4vlq5qfzY1LnRhCc/mh5/EX+hzuGdDy5aYYx4BAdwTTeZHcZpl3X0YyuxZFWNE6wFNppYs3LcFJePOyfKZ8KYb7dmRyvDOcORLPH0sytC6mH1US3JVj6paYM1GEr+CUmyHRnabHPqLlh6Kl0/BWd3ebziDfvpRQpPoR7N+LkUeYWtQ6Rn5v5+NtNeBPs2+DKDlzEVR5aYbTVPrZekJsZ9UC9qtVcP99thVIt1GREnN8zXP8mBfzS+wKYym8fcW6KqrE702Zco+hFQAEIR7qimo7dd7wO8B7R+QZPTuCWm1UAwblDTyURSbd85P4Pz+wBpQyGPeEpsEvxxIZkKsyfSOUcfE3UqzMFwZKYijb7sOkzpou+tC4bPXey5GI1GUAg9c3vLwIwAhcdPHRsYvpAfzkZHWY20vWxxJO0lvKfj6sG2g/pJ1vd/X2EBZkyEjLN4nUZOpOO7MewyHCrxQK8d5aF7rCeQlFX+XksK6l6z971BPuJqwdjj68ULOj9ZTDdOLopMdOLL0PFSS792SXE/EC9EDnIXZGYhr52aQb+9b2zEdBSnpkxAdBUkwJDqGCpZk/HkRidjdp0zKv/Cm52EenmfeKX6HkLUJgMbTTxxIZkIeL/6xuAaAAHbA7mONVduTHNX/UJj1nJEaI7f3HlUyiqKn7VfBE+bdb4HWln1HPJx001Ulq1tOxFf8WZEARvq5Da1+pE7fPVxLntGACz3nkoLsKcPdUqdCwwiyWkmXTd5+bv3j7HaReRt3ESn783Ew3SWsvkEjKtbocNksbrLmV+GVZn1+Uneo35MT1/4r8fngQX5/ptORfgmWfF6KSB/ssJmUSijXxQqUpzkANEkSkYgYj560OOjJr6uqckFuO15TRNgABEwNDjus1V3q2huLPYERMCLXUNmJJpbMrUQsSO7Qnxta55TvPWL6gWmMOvFknqETzqzFVO8SVkovEdYatypLGmDy9VWfgAc0KyIChiOhbd7UlbAeVLPZyEDp4POXKBwN/KP5pT6Cyqs6yaI00vXMn1ubk9OWT9Q/O2t/C25qlnO/zO0xcBzpMBCAB8vsdsh3U8fnPX1XlPEWfaYJxKVaTUgfCESWl4CCkIyjE6iQ5JFcwU6S4/IH0/Agacp8d5Gzq2+GzPnJ7+sqk40mfFQpKrDbAKwLlr3ONEati2k/ycLMSUu7V/7BBkDlNyXoN9tvqXCbbMc4SSQXgC/DBUY9QjtrCtQ+susEomCq8xcNJNNMWCH31GtlTw2BdCXkJBjT+/QNWlBWwQ5SWCh1LdQ99QVii/DyTxjSR6rmdap3l3L3aiplQpPYlrzNm9er88fXd2+ao+YdUNjtqmxiVxmyYPzJxl67OokDcTezEGqldkGgPbRdXA+fGcuZVkembZByo7J1dMnkGNjwwCny+FNcVcWvWYL9mg8oF7jACVWI3bA64EXpdM8bSIEVIAs5JJH+LHXgnCsgcMGPZyAAVBncvbLiexzg9YozcytjPXVlAbQAC7Tc4S0C8QN4LlAGjj4pQAVWrwkaDoUYGxxvkCWKRRHkdzJB5zpREleBDL1oDKEvAqmkDibVC4kTqF89YO6laUjgtJPebBfzr16tg4t10GmN1sJ5vezk2sUOq8blCn5mPZyT3ltaDcddKupQjqusNM9wtFVD0ABzv17fZDn7GPT1nkCtdcgYejcK1qOcTGtPxnCX1rErEjVWCnEJv5HaOAUjgpiKQjUKkQi64D5g2COgwas8FcgIl0Pw95H9dWxE3QG0VbMNffh6BPlAojLDf4es2/5Xfq7hw5NGcON2g8Qsy2UQm94KddKyy3kdJxWgpNaEc15xcylbLC3vnT26u8qS90qc2MU8LdOJc5VPF5KnSpXIhnj1eJJ/jszjZ01oR6JDFJRoeTPO/wh4IPFbdG9KljuSzeuI92p8JF/bpgDE8wG86/W2EBKgPrmzdLijxssQn8mM44ky/KLGOJcrSwXIpZa/Z3v7W6HCRk7ewds99LTsUW1LbeJytw8Q/BFZVZyfO9BUHOCe2suuEkO8DU4fLX0IQSQ2TdOkKXDtPf3sNV9tYhYFueuPRhfQlEEy+aYM/MCz7diDNmFSswYYlZZPmKr2Q5AxLsSVEqqBtn6hVl1BCFOFExnqnIsmyY/NA8jXnDaNzr7Zv3hu+I1Mf/PJjk0gALN2G8ABzdf9FNvWHvZHhv6xIoDCXf964MxG92vGZtx/LYU5PeZqgly8tT5tGeQGeJzMMsJc5p+a5Rn2PtEhiRzo/5Owjy1n0Lzx3ev8GHQmeWb8vagG6O5Qk5nrZuQTiKODI4UqL0LLAusS2Ve7j1Ivdxquu1BR9Rc4QkOiUPwQXJv6du2E8i5pDhVoQpUhyMWGUT2O2YODIhjAfI71gxep5r5zAY7GBUZpy51hAw0pcCCrhOmU8Wp6ujQTdZQsCjtq6SHX8QAMNiPCIIkoxhHEZPgsBcOlP4aErJZPhF7qvx6gHrn8hEwPwYbx8YmT/n7lbcmTip1v8kgsrIjFTAlvLY4Nuil0KDmgz3svYs0ZJ3O3Is/vSx4xpxF1e2VAtZE8dJxGYEIhCSuPvCjP54l/NSNDnwlKvAW8mG+AQkgp7a87Igh26uKMFGD0PoPHTSvoWxiHuk+su8XkQiHIjeYKl/RdcOHpxhQH3zHCNE3aARm83Bl6zGxU/vMltlVPQhubcqhW4RYkl6uXk5JdP/QpzaKFpw2M8zvysv2qj7xaQECuu2akM0Cssj/uB9+wDR7uA6XOnLNaoczalHoMj33eiiu+DRaFsUmlmUZuh9bjDY4INMNSSAivSh03uJvny4Gj+D+neudoa7iJi7c4VFlZ/J5gUR82308zSNAt/ZroBXDWw0fV3eVPAn3aX0mtJabF6RsUZmL+Ehn+wn51/4QipMjD+6y64t7bjL6bjENan2prQ4h7++hBJ9NXvX8CUocJqMC937IasLzm5K0qwXeFMAimMHkEIQIQI2LrQ9sLBfXuyp66zWvlsh74GPv7Xpabj993pRNNDuFud5oIcn/92isbADXdpRPbjmbCNOrwRbxGZx2XmYNGMiV5kjF4IKyxCBvKier9U4uVoheCdmk83rp5G0PihAm2fAtczI4b9BWqX+nrZTrJX5kSwQddi93NQrXG+Cl3eBGNkM77VBsMpEolhXex1MVvMkZN9fG59GGbciH11FEXaY1MxrArovaSjE/lUUqBg2cZBNmiWbvzCHCPJ4RVGFK2dTbObM1m+gJyEX53fa7u3+TZpm74mNEzWbkVL4vjNwfL9uzRCu1cgbrNx5Yv5dDruNrIOgwIk+UZWwJfdbu/WHul6PMmRflVCIzd7B37Pgm/Up/NuCiQW7RXyafevN3AL6ycciCc4ZPlTRzEu+aURGlUBOJbUEsheX7PPyrrhdUt5JAG12EEEZpY/N3Vhbl5uLAfT0CbC2XmpnryFkxZmBTs5prvEeuf0bn73i3O82WTiQtJWEPLsBXnQmdnKhB06NbbhLtlTZYJMxDMJpFeajSNRDB2v61BMUHqXggUwRJ19m6p5zl51v11q34T74lTXdJURuV6+bg2D6qpfGnLy7KGLuLZngobM4pIouz4+n0/UzFKxDgLM4h+fUwKZozQ9UGrHjcif51Ruonz7oIVZ56xWtZS8z7u5zay6J2LD4gCYh2RXoBRLDKsUlZ80R8kmoxlJiL8aZCy2wCAonnucFxCLT1HKoMhbPKt34D97EXPPh0joO93iJVF1Uruew61Qoy3ZUVNX9uIJDt9AQWKLLo+mSzmTibyLHq0D6hhzpvgUgI6ekyVEL3FD+Fi5R3A8MRHPXspN1VyKkfRlC+OGiNgPC4NREZpFETgVmdXrQ2TxChuS3aY+Ndc7CiYv5+CmzfiqeZrWIQJW/C4RvjbGUoJFf1K6ZdR2xL/bG4kVq1+I4jQWX+26YUijpp+lpN7o5c6ZodXJCF56UkFGsqz44sIg8jrdWvbjRCxi2Bk0iyM3a7ecAV93zB6h1Ei38c0s6+8nrbkopArccGP8vntQe1bFeEh2nJIFOHX/k3/UHb5PtKGpnzbkmnRETMX+9X/QduLZWw/feklW/kH/JnzToJe9Kgu9Hct1UGbH5BPCLo4OOtQnZonW0xnyCcdtKyPQ/sbLiSTYJdSx4sJqWLMnfn6fIqPB3WAgk00J+fCOkomPHqtS67pf0mFmKoItYZUlJu6BihSZ8qve8+/X+LX1MhQXF95AshfUleCtmdn6l6QFXzLg2sgLn1oyVFuZecv7fzsIHzoRlAGp0gwYDOn1S4qabWvB5xUaE+Svw4KmjWtxdnuQbI32dw87D4N95u8qQRJTSQg0wLxOLkxSrPMLEn1UIhNKjAa9VLs3WLaXGrtCIt8bKY2AQP/ZdyRU6zT/E8qP2ltyBE2CCZPgWgEYDoJJO4n92y61ylNaSFXKohJhLjkfvYWm592539sIpmBNLlDo1bExFBfmHJJ0lFEiC/fj8v42OoMC9Mo3whIoWvyHfq6Uacqq55mzFf/EGC+NP/gHjhd6urc6R0hES27VXux7UY8CGKPohplWIZtTrFSaPWslCWy78E22Pw8fvReSUZx/txqLtHrFqg1DY/Eus6Iq1heZdrdcqE0/c971Bz1HW/XNXHsXpUIbI4kHdOfCc6T5zHZzvzQJB0ggMFL6IGPAilU9bj/ASdPk6fNvNtZqPuwEDhMBtBnhCexo6D6VAGIOPvJPPV523Y8R8a9vCqZbswSZKzOT1291BsUbmUWehtbb1fdRX9hiJKXvwr1QX6GjnZMgyMvnwOo2Dr24amr7FqEAbVeJAjRNOceM2EQ1Mna9fInqPJ5mh5X8CzT1aDOv08An0blz0fF5Gq4mS2cwq5glwIOlY5nznE8X4j/UdZ3FJsVIXte1JH0A7iibuPfazStM5O/Vo3KXIpXBeGORV0M9XDXFvsYZUHGvFCUubWzTw248EHE0cpQM2zNg6rjavreq3NHCAWsoZ7wvVy7l5gvtKRmIj1MnvfWEm0yFnGcuOq192350a5WefpfKCcX3Sn+AgHU+qnpstNtddbdVebagJU390lq9ko4aI9rqdaWXYG8tv5O/ZQHSqDRYHC6zfH10l5z++opso7aOSaIczlQ13iAzXvLdEu0V7kwNUZ1c8Y8aq7SeIEe5p902FlNkW8DnwHyueHchbK8vVFJfmr9mz7P8nUSccl1ULaoWMRSI1ls32kvlK0h46h3J25Yd9AzfcJbp9qYF/SEt3H5j69mMdcsNxZcAzT/A89ov3tglTX54y/EwjMfuoDoxPwLJDm5I7q6F9Kp469yNy1zSxz0N4HbRRBj9xFFuogvBspv7DXUNIsGxTINEQfmctb42XImWAODgARNo7dfcTqFKq6aTfivmvunLmzP9f8yLsJvXD3JbcPcDGNriMAcjzeDTNr65t8YB5tsnFDFLa0Uwmd2OvUdkLMX9TsAUYUfooSv47sw5J88j7CpahRjjO3/UhOXjTS39W5YZAel2KTbQd1h7INOw9P23GW7GDAe4agIUFHP48MZr7ubq0efFmmtwYMyk7D0r1oeG/CGOODgb9Ur+JMHxkwzPbtCX2ZnENQuI0RN5SyTIZuoY4XS9Rd/tPe3vNAZGSHM/YYwqs9xkkENx0O+eC2YVW1cwOJ3ckE890nbQeHLKlW15L0P0W2VliyYrfNr0nrIYddoRyGaCtj4OYd2MT7ebApqZOAQIaSHJM4mphhfjNjtnjg6YRyx9qM2FT3xOiYIMqXPFWdzhSgFF8ItocqVV09CmIoO8k6U/oJB7++wSX/YksxfPXHyjSgAGZOj1aKEq9fSvXBqtp2wu8/FxEf5AxapAD06pPGuLVUYLdgEzHR8wqRGYEwiUO9MyYbgswstuLYhwYFpSVKOdzAihZ9LuHtD598EGhINU9xc9xhL+QgTLAstmPIvvm2xyRw/WTUPXkP3ZHu6GyPmj5xFH9/QGpkglKXRVUBgVmLOJx8uZO2AstxQYocZH2JhORlxawj66BAXUEs7K/gPxINIRAFyK3WLuyq9oBTF9wEbnmCot82WjIg7CPNwYK3KrZMrKAz5yFszg4wCVLJVnIL8+OYA0xRDH8cHQjQUiQ2i1mr/be32k/3Xej9sdf3iuGvZHyLFSJvPSqz/wltnxumTJYKZsrWXtx/Rmu39jjV9lFaJttfFn57/No2h/unsJmMHbrnZ8csxkp5HQ4xR1s0HH+t3Iz82a3iQWTUDGq/+l2W3TUYLE8zNdL8Y+5oXaIH/Y2UUcX67cXeN4WvENZjz4+8q7vjhowOI3rSjFhGZ6KzwmU7+5nFV+kGWAZ5z2UWvzq0TK0pk1hPwAN4jbw//1CApRvIaIjhSGhioY6TUmsToek9cF9XjJdHvLPcyyCV3lbR5Jiz/ts46ay2F820VjTXvllElwrGzKcNSyvQlWDXdwrUINXmHorAM3fE19ngLZmgeUaCJLsSITf2VcfAOuWwX7mTPdP8Zb/04KqRniufCpwnDUk7sP0RX6cud/sanFMagnzKInSRVey0YzlVSOtA/AjrofmSH6RYbJQ8b4NDeTkIGc6247+Mnbez/qhJ9GAv9fGNFercPnnrf285Qgs+UqThLRgflcAKFuqWhLzZaR4QqvSwa3xe0LPkqj9xJWub195r7NrrR0e78FR+0mRBNMPsraqZctAUVAJfYKehTDV1MGGQSeDsOK9J3sbUuKRIS/WilX/64CBms9jCZocBlsBSZaIAjWm/SUZ8daWL2a/cJFyUOFqE3Epc2RWbtjNyPwOGpWtzu32kUooUqsJud7IV4E8rstUBXM7tGEtBx99x60g1duhyvxeKJSl8s5E34HTMmADT0836aEdg5Dv9rVyCz8i2REOmiz6wtIVFN0HsjAoN37SrY0bV1Ms8CRUILhvZvvRaDzoVCaSI0u8EPuTe4b7OPowgRGODl22UBBmHSTUY8e4DyL+Bc7bngo+2T8HtNvzyATSL5iJZgFPKpmUyZv54vVL90+/RQGATUmNKnrIvcJMYON9fl83naW5sf6hRkbbTC9RUEE6XADwjgA46wWfUQ+QWZl0J4PVTWAln/YfAz/SV3q3J9+yCYDleruoN5uoc/wT2f4YONGTb6zTGq3V+3JqzmCOjwebKln+fExVLN7sqtqfMnsKVXWbb2Ai5m3D/fCTgX7oKYzTZvj+m28XnDqPbXuP4MyWdmPezcesdrh7rCzA7BWdObiuyDEKjjzBbQ0qnuwjliz+b+j7aPMKlkXyIznV3tGzAfYwIbzGGt098oh4eq3ruDjdgHtjxfFCjHrjjRbHajoz/YOY4raojPFQ910GIlBV7hq47UDgpyajBxQUmD8NctiLV1rTSLAEsQDLTeRKcmPBMVMFF0SPBBhZ5oXoxtD3lMhuAQXmA+57OcciczVW9e9zwSIAHS+FJmvfXMJGF1dMBsIUMaPjvgaVqUc3p32qVCMQYFEiRLzlVSOGMCmv/HJIxAHe3mL/XnoZ1IkWLeRZfgyByjnDbbeRK5KL7bYHSVJZ9UFq+yCiNKeRUaYjgbC3hVUvfJAhy/QNl/JqLKVvGMk9ZcfyGidNeo/VTxK9vUpodzfQI9Z2eAre4nmrkzgxKSnT5IJ1D69oHuUS5hp7pK9IAWuNrAOtOH0mAuwCrY8mXAtVXUeaNK3OXr6PRvmWg4VQqFSy+a1GZfFYgdsJELG8N0kvqmzvwZ02Plf5fH9QTy6br0oY/IDsEA+GBf9pEVWCIuBCjsup3LDSDqI+5+0IKSUFr7A96A2f0FbcU9fqljdqvsd8sG55KcKloHIFZem2Wb6pCLXybnVSB0sjCXzdS8IKvE",
        );
        const f = new Map([
          [8217, "apostrophe"],
          [8260, "fraction slash"],
          [12539, "middle dot"],
        ]);
        function p(e) {
          return `{${(function (e) {
            return e.toString(16).toUpperCase().padStart(2, "0");
          })(e)}}`;
        }
        function m(e) {
          let t = [];
          for (let r = 0, n = e.length; r < n; ) {
            let n = e.codePointAt(r);
            (r += n < 65536 ? 1 : 2), t.push(n);
          }
          return t;
        }
        function y(e) {
          let t = e.length;
          if (t < 4096) return String.fromCodePoint(...e);
          let r = [];
          for (let n = 0; n < t; )
            r.push(String.fromCodePoint(...e.slice(n, (n += 4096))));
          return r.join("");
        }
        function g(e, t) {
          let r = e.length,
            n = r - t.length;
          for (let i = 0; 0 == n && i < r; i++) n = e[i] - t[i];
          return n;
        }
        var v = r(
          "AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g",
        );
        function b(e) {
          return (e >> 24) & 255;
        }
        function w(e) {
          return 16777215 & e;
        }
        const E = new Map(
            o(v).flatMap((e, t) => e.map((e) => [e, (t + 1) << 24])),
          ),
          A = new Set(s(v)),
          _ = new Map(),
          T = new Map();
        for (let [e, t] of a(v)) {
          if (!A.has(e) && 2 == t.length) {
            let [r, n] = t,
              i = T.get(r);
            i || ((i = new Map()), T.set(r, i)), i.set(n, e);
          }
          _.set(e, t.reverse());
        }
        const R = 44032,
          I = 4352,
          S = 4449,
          x = 4519,
          P = 28,
          O = 21 * P,
          C = R + 19 * O,
          k = I + 19,
          M = S + 21,
          N = x + P;
        function B(e) {
          return e >= R && e < C;
        }
        function D(e, t) {
          if (e >= I && e < k && t >= S && t < M)
            return R + (e - I) * O + (t - S) * P;
          if (B(e) && t > x && t < N && (e - R) % P == 0) return e + (t - x);
          {
            let r = T.get(e);
            return r && ((r = r.get(t)), r) ? r : -1;
          }
        }
        function j(e) {
          let t = [],
            r = [],
            n = !1;
          function i(e) {
            let r = E.get(e);
            r && ((n = !0), (e |= r)), t.push(e);
          }
          for (let n of e)
            for (;;) {
              if (n < 128) t.push(n);
              else if (B(n)) {
                let e = n - R,
                  t = ((e % O) / P) | 0,
                  r = e % P;
                i(I + ((e / O) | 0)), i(S + t), r > 0 && i(x + r);
              } else {
                let e = _.get(n);
                e ? r.push(...e) : i(n);
              }
              if (!r.length) break;
              n = r.pop();
            }
          if (n && t.length > 1) {
            let e = b(t[0]);
            for (let r = 1; r < t.length; r++) {
              let n = b(t[r]);
              if (0 == n || e <= n) {
                e = n;
                continue;
              }
              let i = r - 1;
              for (;;) {
                let r = t[i + 1];
                if (((t[i + 1] = t[i]), (t[i] = r), !i)) break;
                if (((e = b(t[--i])), e <= n)) break;
              }
              e = b(t[r]);
            }
          }
          return t;
        }
        function L(e) {
          return j(e).map(w);
        }
        function U(e) {
          return (function (e) {
            let t = [],
              r = [],
              n = -1,
              i = 0;
            for (let s of e) {
              let e = b(s),
                o = w(s);
              if (-1 == n) 0 == e ? (n = o) : t.push(o);
              else if (i > 0 && i >= e)
                0 == e ? (t.push(n, ...r), (r.length = 0), (n = o)) : r.push(o),
                  (i = e);
              else {
                let s = D(n, o);
                s >= 0
                  ? (n = s)
                  : 0 == i && 0 == e
                  ? (t.push(n), (n = o))
                  : (r.push(o), (i = e));
              }
            }
            return n >= 0 && t.push(n, ...r), t;
          })(j(e));
        }
        const F = 65039,
          H = ".";
        function G() {
          return new Set(s(h));
        }
        const V = new Map(a(h)),
          W = G(),
          q = G(),
          Z = new Set(
            s(h).map(
              function (e) {
                return this[e];
              },
              [...q],
            ),
          ),
          z = G(),
          K = G(),
          J = o(h);
        function X() {
          return new Set([s(h).map((e) => J[e]), s(h)].flat(2));
        }
        const Q = h(),
          $ = c((e) => {
            let t = c(h).map((e) => e + 96);
            if (t.length) {
              let r = e >= Q;
              (t[0] -= 32), (t = y(t)), r && (t = `Restricted[${t}]`);
              let n = X(),
                i = X(),
                s = [...n, ...i].sort((e, t) => e - t);
              return { N: t, P: n, M: !h(), R: r, V: new Set(s) };
            }
          }),
          Y = G(),
          ee = new Map();
        [...Y, ...G()]
          .sort((e, t) => e - t)
          .map((e, t, r) => {
            let n = h(),
              i = (r[t] = n ? r[t - n] : { V: [], M: new Map() });
            i.V.push(e), Y.has(e) || ee.set(e, i);
          });
        for (let { V: e, M: t } of new Set(ee.values())) {
          let r = [];
          for (let t of e) {
            let e = $.filter((e) => e.V.has(t)),
              n = r.find(({ G: t }) => e.some((e) => t.has(e)));
            n || ((n = { G: new Set(), V: [] }), r.push(n)),
              n.V.push(t),
              e.forEach((e) => n.G.add(e));
          }
          let n = r.flatMap(({ G: e }) => [...e]);
          for (let { G: e, V: i } of r) {
            let r = new Set(n.filter((t) => !e.has(t)));
            for (let e of i) t.set(e, r);
          }
        }
        let te = new Set(),
          re = new Set();
        for (let e of $) for (let t of e.V) (te.has(t) ? re : te).add(t);
        for (let e of te) ee.has(e) || re.has(e) || ee.set(e, 1);
        const ne = new Set([...te, ...L(te)]),
          ie = s(h),
          se = (function e(t) {
            let r = c(() => {
                let t = s(h).map((e) => ie[e]);
                if (t.length) return e(t);
              }).sort((e, t) => t.Q.size - e.Q.size),
              n = h(),
              i = n % 3;
            n = (n / 3) | 0;
            let o = 1 & n;
            return (
              (n >>= 1), { B: r, V: i, F: o, S: 1 & n, C: 2 & n, Q: new Set(t) }
            );
          })([]);
        class oe extends Array {
          get is_emoji() {
            return !0;
          }
        }
        function ae(e, t = p) {
          let r = [];
          le(e[0]) && r.push("◌");
          let n = 0,
            i = e.length;
          for (let s = 0; s < i; s++) {
            let i = e[s];
            he(i) && (r.push(y(e.slice(n, s))), r.push(t(i)), (n = s + 1));
          }
          return r.push(y(e.slice(n, i))), r.join("");
        }
        function ce(e) {
          return (he(e) ? "" : `${de(ae([e]))} `) + p(e);
        }
        function de(e) {
          return `"${e}"‎`;
        }
        function ue(e) {
          for (let t = e.lastIndexOf(95); t > 0; )
            if (95 !== e[--t])
              throw new Error("underscore allowed only at start");
        }
        function le(e) {
          return q.has(e);
        }
        function he(e) {
          return z.has(e);
        }
        function fe(e, t) {
          let r = 0;
          return e.split(H).map((e) => {
            let n,
              i = m(e),
              s = { input: i, offset: r };
            r += i.length + 1;
            try {
              let e,
                r = (s.tokens = ve(i, U)),
                o = r.length;
              if (!o) throw new Error("empty label");
              {
                let i = r[0],
                  a = o > 1 || i.is_emoji;
                if (!a && i.every((e) => e < 128))
                  (n = i),
                    ue(n),
                    (function (e) {
                      if (e.length >= 4 && 45 == e[2] && 45 == e[3])
                        throw new Error("invalid label extension");
                    })(n),
                    (e = "ASCII");
                else if (
                  (a &&
                    ((s.emoji = !0),
                    (i = r.flatMap((e) => (e.is_emoji ? [] : e)))),
                  (n = r.flatMap((e) => (!t && e.is_emoji ? be(e) : e))),
                  ue(n),
                  i.length)
                ) {
                  if (q.has(n[0])) throw ge("leading combining mark");
                  for (let e = 1; e < o; e++) {
                    let t = r[e];
                    if (!t.is_emoji && q.has(t[0]))
                      throw ge(
                        `emoji + combining mark: "${y(r[e - 1])} + ${ae([
                          t[0],
                        ])}"`,
                      );
                  }
                  !(function (e) {
                    let t = e[0],
                      r = f.get(t);
                    if (r) throw ge(`leading ${r}`);
                    let n = e.length,
                      i = -1;
                    for (let s = 1; s < n; s++) {
                      t = e[s];
                      let n = f.get(t);
                      if (n) {
                        if (i == s) throw ge(`${r} + ${n}`);
                        (i = s + 1), (r = n);
                      }
                    }
                    if (i == n) throw ge(`trailing ${r}`);
                  })(n);
                  let t = [...new Set(i)],
                    [s] = (function (e) {
                      let t = $;
                      for (let r of e) {
                        let e = t.filter((e) => e.V.has(r));
                        if (!e.length) throw t === $ ? me(r) : ye(t[0], r);
                        if (((t = e), 1 == e.length)) break;
                      }
                      return t;
                    })(t);
                  !(function (e, t) {
                    let { V: r, M: n } = e;
                    for (let n of t) if (!r.has(n)) throw ye(e, n);
                    if (n) {
                      let e = L(t);
                      for (let t = 1, r = e.length; t < r; t++)
                        if (Z.has(e[t])) {
                          let n = t + 1;
                          for (let i; n < r && Z.has((i = e[n])); n++)
                            for (let r = t; r < n; r++)
                              if (e[r] == i)
                                throw new Error(
                                  `non-spacing marks: repeated ${ce(i)}`,
                                );
                          if (n - t > 4)
                            throw new Error(
                              `non-spacing marks: too many ${de(
                                ae(e.slice(t - 1, n)),
                              )} (${n - t}/4)`,
                            );
                          t = n;
                        }
                    }
                  })(s, i),
                    (function (e, t) {
                      let r,
                        n = [];
                      for (let e of t) {
                        let t = ee.get(e);
                        if (1 === t) return;
                        if (t) {
                          let n = t.M.get(e);
                          if (
                            ((r = r ? r.filter((e) => n.has(e)) : [...n]),
                            !r.length)
                          )
                            return;
                        } else n.push(e);
                      }
                      if (r)
                        for (let t of r)
                          if (n.every((e) => t.V.has(e)))
                            throw new Error(
                              `whole-script confusable: ${e.N}/${t.N}`,
                            );
                    })(s, t),
                    (e = s.N);
                } else e = "Emoji";
              }
              s.type = e;
            } catch (e) {
              s.error = e;
            }
            return (s.output = n), s;
          });
        }
        function pe(e) {
          return e
            .map(({ input: t, error: r, output: n }) => {
              if (r) {
                let n = r.message;
                throw new Error(
                  1 == e.length ? n : `Invalid label ${de(ae(t))}: ${n}`,
                );
              }
              return y(n);
            })
            .join(H);
        }
        function me(e) {
          return new Error(`disallowed character: ${ce(e)}`);
        }
        function ye(e, t) {
          let r = ce(t),
            n = $.find((e) => e.P.has(t));
          return (
            n && (r = `${n.N} ${r}`),
            new Error(`illegal mixture: ${e.N} + ${r}`)
          );
        }
        function ge(e) {
          return new Error(`illegal placement: ${e}`);
        }
        function ve(e, t) {
          let r = [],
            n = [];
          for (e = e.slice().reverse(); e.length; ) {
            let i = we(e);
            if (i) n.length && (r.push(t(n)), (n = [])), r.push(i);
            else {
              let t = e.pop();
              if (ne.has(t)) n.push(t);
              else {
                let e = V.get(t);
                if (e) n.push(...e);
                else if (!W.has(t)) throw me(t);
              }
            }
          }
          return n.length && r.push(t(n)), r;
        }
        function be(e) {
          return e.filter((e) => e != F);
        }
        function we(e, t) {
          let r,
            n,
            i = se,
            s = [],
            o = e.length;
          for (t && (t.length = 0); o; ) {
            let a = e[--o];
            if (((i = i.B.find((e) => e.Q.has(a))), !i)) break;
            if (i.S) n = a;
            else if (i.C && a === n) break;
            s.push(a),
              i.F && (s.push(F), o > 0 && e[o - 1] == F && o--),
              i.V &&
                ((r = Ee(s, i)),
                t && t.push(...e.slice(o).reverse()),
                (e.length = o));
          }
          return r;
        }
        function Ee(e, t) {
          let r = oe.from(e);
          return 2 == t.V && r.splice(1, 1), r;
        }
        const Ae = "valid",
          _e = "mapped",
          Te = "ignored";
        function Re(e) {
          return e == Ae || e == _e;
        }
        function Ie(e) {
          return e.some((e) => K.has(e));
        }
        function Se(e) {
          for (let t = 0; t < e.length; t++)
            if (e[t].type == Ae) {
              let r = t + 1;
              for (; r < e.length && e[r].type == Ae; ) r++;
              e.splice(t, r - t, {
                type: Ae,
                cps: e.slice(t, r).flatMap((e) => e.cps),
              });
            }
          return e;
        }
        (t.ens_beautify = function (e) {
          let t = fe(e, !0);
          for (let { type: e, output: r, error: n } of t)
            if (!n && "Greek" !== e) {
              let e = 0;
              for (;;) {
                let t = r.indexOf(958, e);
                if (t < 0) break;
                (r[t] = 926), (e = t + 1);
              }
            }
          return pe(t);
        }),
          (t.ens_emoji = function () {
            let e = [];
            return (
              (function t(r, n, i) {
                if (r.S) i = n[n.length - 1];
                else if (r.C && i === n[n.length - 1]) return;
                r.F && n.push(F), r.V && e.push(Ee(n, r));
                for (let e of r.B) for (let r of e.Q) t(e, [...n, r], i);
              })(se, []),
              e.sort(g)
            );
          }),
          (t.ens_normalize = function (e) {
            return pe(fe(e));
          }),
          (t.ens_normalize_fragment = function (e, t) {
            let r = t ? L : U;
            return e
              .split(H)
              .map((e) =>
                y(ve(m(e), r).flatMap((e) => (e.is_emoji ? be(e) : e))),
              )
              .join(H);
          }),
          (t.ens_split = fe),
          (t.ens_tokenize = function e(t, { nf: r = !0 } = {}) {
            let n = m(t).reverse(),
              i = [],
              s = [];
            for (; n.length; ) {
              let e = we(n, i);
              if (e)
                s.push({
                  type: "emoji",
                  emoji: e,
                  input: i.slice(),
                  cps: be(e),
                });
              else {
                let e = n.pop();
                if (46 == e) s.push({ type: "stop", cp: e });
                else if (ne.has(e)) s.push({ type: Ae, cps: [e] });
                else if (W.has(e)) s.push({ type: Te, cp: e });
                else {
                  let t = V.get(e);
                  t
                    ? s.push({ type: _e, cp: e, cps: t.slice() })
                    : s.push({ type: "disallowed", cp: e });
                }
              }
            }
            if (r)
              for (let t = 0, r = -1; t < s.length; t++) {
                let n = s[t];
                if (Re(n.type))
                  if (Ie(n.cps)) {
                    let n = t + 1;
                    for (let e = n; e < s.length; e++) {
                      let { type: t, cps: r } = s[e];
                      if (Re(t)) {
                        if (!Ie(r)) break;
                        n = e + 1;
                      } else if (t !== Te) break;
                    }
                    r < 0 && (r = t);
                    let i = s.slice(r, n),
                      o = i.flatMap((e) => (Re(e.type) ? e.cps : [])),
                      a = U(o);
                    g(a, o)
                      ? (s.splice(r, n - r, {
                          type: "nfc",
                          input: o,
                          cps: a,
                          tokens0: Se(i),
                          tokens: e(y(a), { nf: !1 }),
                        }),
                        (t = r))
                      : (t = n - 1),
                      (r = -1);
                  } else r = t;
                else n.type !== Te && (r = -1);
              }
            return Se(s);
          }),
          (t.is_combining_mark = le),
          (t.nfc = U),
          (t.nfd = L),
          (t.safe_str_from_cps = ae),
          (t.should_escape = he);
      },
      5550: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.outputSyncingFormatter =
            t.outputPostFormatter =
            t.inputPostFormatter =
            t.outputBlockFormatter =
            t.outputTransactionReceiptFormatter =
            t.outputLogFormatter =
            t.inputLogFormatter =
            t.inputTopicFormatter =
            t.outputTransactionFormatter =
            t.inputSignFormatter =
            t.inputTransactionFormatter =
            t.inputCallFormatter =
            t.txInputOptionsFormatter =
            t.inputAddressFormatter =
            t.inputDefaultBlockNumberFormatter =
            t.inputBlockNumberFormatter =
            t.outputBigIntegerFormatter =
            t.outputProofFormatter =
            t.inputStorageKeysFormatter =
              void 0);
        const n = r(3087),
          i = r(2235),
          s = r(2823),
          o = r(9150),
          a = r(8840);
        (t.inputStorageKeysFormatter = (e) =>
          e.map((e) => (0, o.numberToHex)(e))),
          (t.outputProofFormatter = (e) => ({
            address: (0, o.toChecksumAddress)(e.address),
            nonce: (0, o.hexToNumberString)(e.nonce),
            balance: (0, o.hexToNumberString)(e.balance),
          })),
          (t.outputBigIntegerFormatter = (e) => (0, o.toNumber)(e)),
          (t.inputBlockNumberFormatter = (e) => {
            if (!(0, a.isNullish)(e))
              return "string" == typeof e && (0, a.isBlockTag)(e)
                ? e
                : "genesis" === e
                ? "0x0"
                : "string" == typeof e && (0, o.isHexStrict)(e)
                ? e.toLowerCase()
                : (0, o.numberToHex)(e);
          }),
          (t.inputDefaultBlockNumberFormatter = (e, r) =>
            e
              ? (0, t.inputBlockNumberFormatter)(e)
              : (0, t.inputBlockNumberFormatter)(r)),
          (t.inputAddressFormatter = (e) => {
            if (i.Iban.isValid(e) && i.Iban.isDirect(e))
              return new i.Iban(e).toAddress().toLowerCase();
            if ((0, o.isAddress)(e))
              return `0x${e.toLowerCase().replace("0x", "")}`;
            throw new n.FormatterError(
              `Provided address ${e} is invalid, the capitalization checksum test failed, or it's an indirect IBAN address which can't be converted.`,
            );
          }),
          (t.txInputOptionsFormatter = (e) => {
            var r;
            const i = Object.assign({}, e);
            if (
              (e.to && (i.to = (0, t.inputAddressFormatter)(e.to)),
              e.data && e.input)
            )
              throw new n.FormatterError(
                'You can\'t have "data" and "input" as properties of transactions at the same time, please use either "data" or "input" instead.',
              );
            if (
              (!e.input && e.data && ((i.input = e.data), delete i.data),
              e.input &&
                !e.input.startsWith("0x") &&
                (i.input = `0x${e.input}`),
              i.input && !(0, o.isHexStrict)(i.input))
            )
              throw new n.FormatterError(
                "The input field must be HEX encoded data.",
              );
            return (
              (e.gas || e.gasLimit) &&
                (i.gas = (0, o.toNumber)(
                  null !== (r = e.gas) && void 0 !== r ? r : e.gasLimit,
                )),
              (e.maxPriorityFeePerGas || e.maxFeePerGas) && delete i.gasPrice,
              [
                "gasPrice",
                "gas",
                "value",
                "maxPriorityFeePerGas",
                "maxFeePerGas",
                "nonce",
                "chainId",
              ]
                .filter((e) => !(0, a.isNullish)(i[e]))
                .forEach((e) => {
                  i[e] = (0, o.numberToHex)(i[e]);
                }),
              i
            );
          }),
          (t.inputCallFormatter = (e, r) => {
            var n;
            const i = (0, t.txInputOptionsFormatter)(e),
              s = null !== (n = i.from) && void 0 !== n ? n : r;
            return s && (i.from = (0, t.inputAddressFormatter)(s)), i;
          }),
          (t.inputTransactionFormatter = (e, r) => {
            var i;
            const s = (0, t.txInputOptionsFormatter)(e);
            if (
              "number" != typeof s.from &&
              (!s.from || "object" != typeof s.from)
            ) {
              if (
                ((s.from = null !== (i = s.from) && void 0 !== i ? i : r),
                !e.from && "number" != typeof e.from)
              )
                throw new n.FormatterError(
                  'The send transactions "from" field must be defined!',
                );
              s.from = (0, t.inputAddressFormatter)(e.from);
            }
            return s;
          }),
          (t.inputSignFormatter = (e) =>
            (0, o.isHexStrict)(e) ? e : (0, o.utf8ToHex)(e)),
          (t.outputTransactionFormatter = (e) => {
            const r = Object.assign({}, e);
            return (
              e.blockNumber &&
                (r.blockNumber = (0, o.hexToNumber)(e.blockNumber)),
              e.transactionIndex &&
                (r.transactionIndex = (0, o.hexToNumber)(e.transactionIndex)),
              (r.nonce = (0, o.hexToNumber)(e.nonce)),
              (r.gas = (0, o.hexToNumber)(e.gas)),
              e.gasPrice &&
                (r.gasPrice = (0, t.outputBigIntegerFormatter)(e.gasPrice)),
              e.maxFeePerGas &&
                (r.maxFeePerGas = (0, t.outputBigIntegerFormatter)(
                  e.maxFeePerGas,
                )),
              e.maxPriorityFeePerGas &&
                (r.maxPriorityFeePerGas = (0, t.outputBigIntegerFormatter)(
                  e.maxPriorityFeePerGas,
                )),
              e.type && (r.type = (0, o.hexToNumber)(e.type)),
              (r.value = (0, t.outputBigIntegerFormatter)(e.value)),
              e.to && (0, o.isAddress)(e.to)
                ? (r.to = (0, o.toChecksumAddress)(e.to))
                : (r.to = void 0),
              e.from && (r.from = (0, o.toChecksumAddress)(e.from)),
              r
            );
          }),
          (t.inputTopicFormatter = (e) => {
            if ((0, a.isNullish)(e)) return null;
            const t = String(e);
            return (0, a.isHex)(t) ? t : (0, o.fromUtf8)(t);
          }),
          (t.inputLogFormatter = (e) => {
            var r;
            const n = (0, a.isNullish)(e) ? {} : (0, o.mergeDeep)({}, e);
            return (
              (0, a.isNullish)(n.fromBlock) &&
                (n.fromBlock = s.BlockTags.LATEST),
              (n.fromBlock = (0, t.inputBlockNumberFormatter)(n.fromBlock)),
              (0, a.isNullish)(n.toBlock) ||
                (n.toBlock = (0, t.inputBlockNumberFormatter)(n.toBlock)),
              (n.topics = null !== (r = n.topics) && void 0 !== r ? r : []),
              (n.topics = n.topics.map((e) =>
                Array.isArray(e)
                  ? e.map(t.inputTopicFormatter)
                  : (0, t.inputTopicFormatter)(e),
              )),
              n.address &&
                (n.address = Array.isArray(n.address)
                  ? n.address.map((e) => (0, t.inputAddressFormatter)(e))
                  : (0, t.inputAddressFormatter)(n.address)),
              n
            );
          }),
          (t.outputLogFormatter = (e) => {
            const t = Object.assign({}, e),
              r =
                "string" == typeof e.logIndex
                  ? e.logIndex
                  : (0, o.numberToHex)(e.logIndex);
            if (
              "string" == typeof e.blockHash &&
              "string" == typeof e.transactionHash
            ) {
              const n = (0, o.sha3Raw)(
                `${e.blockHash.replace("0x", "")}${e.transactionHash.replace(
                  "0x",
                  "",
                )}${r.replace("0x", "")}`,
              );
              t.id = `log_${n.replace("0x", "").slice(0, 8)}`;
            } else e.id || (t.id = void 0);
            return (
              e.blockNumber &&
                (0, o.isHexStrict)(e.blockNumber) &&
                (t.blockNumber = (0, o.hexToNumber)(e.blockNumber)),
              e.transactionIndex &&
                (0, o.isHexStrict)(e.transactionIndex) &&
                (t.transactionIndex = (0, o.hexToNumber)(e.transactionIndex)),
              e.logIndex &&
                (0, o.isHexStrict)(e.logIndex) &&
                (t.logIndex = (0, o.hexToNumber)(e.logIndex)),
              e.address && (t.address = (0, o.toChecksumAddress)(e.address)),
              t
            );
          }),
          (t.outputTransactionReceiptFormatter = (e) => {
            if ("object" != typeof e)
              throw new n.FormatterError(
                `Received receipt is invalid: ${String(e)}`,
              );
            const r = Object.assign({}, e);
            return (
              e.blockNumber &&
                (r.blockNumber = (0, o.hexToNumber)(e.blockNumber)),
              e.transactionIndex &&
                (r.transactionIndex = (0, o.hexToNumber)(e.transactionIndex)),
              (r.cumulativeGasUsed = (0, o.hexToNumber)(e.cumulativeGasUsed)),
              (r.gasUsed = (0, o.hexToNumber)(e.gasUsed)),
              e.logs &&
                Array.isArray(e.logs) &&
                (r.logs = e.logs.map(t.outputLogFormatter)),
              e.effectiveGasPrice &&
                (r.effectiveGasPrice = (0, o.hexToNumber)(e.effectiveGasPrice)),
              e.contractAddress &&
                (r.contractAddress = (0, o.toChecksumAddress)(
                  e.contractAddress,
                )),
              e.status && (r.status = Boolean(parseInt(e.status, 10))),
              r
            );
          }),
          (t.outputBlockFormatter = (e) => {
            const r = Object.assign({}, e);
            return (
              (r.gasLimit = (0, o.hexToNumber)(e.gasLimit)),
              (r.gasUsed = (0, o.hexToNumber)(e.gasUsed)),
              (r.size = (0, o.hexToNumber)(e.size)),
              (r.timestamp = (0, o.hexToNumber)(e.timestamp)),
              e.number && (r.number = (0, o.hexToNumber)(e.number)),
              e.difficulty &&
                (r.difficulty = (0, t.outputBigIntegerFormatter)(e.difficulty)),
              e.totalDifficulty &&
                (r.totalDifficulty = (0, t.outputBigIntegerFormatter)(
                  e.totalDifficulty,
                )),
              e.transactions &&
                Array.isArray(e.transactions) &&
                (r.transactions = e.transactions.map(
                  t.outputTransactionFormatter,
                )),
              e.miner && (r.miner = (0, o.toChecksumAddress)(e.miner)),
              e.baseFeePerGas &&
                (r.baseFeePerGas = (0, o.hexToNumber)(e.baseFeePerGas)),
              r
            );
          }),
          (t.inputPostFormatter = (e) => {
            var t;
            const r = Object.assign({}, e);
            return (
              e.ttl && (r.ttl = (0, o.numberToHex)(e.ttl)),
              e.workToProve &&
                (r.workToProve = (0, o.numberToHex)(e.workToProve)),
              e.priority && (r.priority = (0, o.numberToHex)(e.priority)),
              e.topics &&
                !Array.isArray(e.topics) &&
                (r.topics = e.topics ? [e.topics] : []),
              (r.topics =
                null === (t = r.topics) || void 0 === t
                  ? void 0
                  : t.map((e) =>
                      e.startsWith("0x") ? e : (0, o.fromUtf8)(e),
                    )),
              r
            );
          }),
          (t.outputPostFormatter = (e) => {
            var t;
            const r = Object.assign({}, e);
            return (
              e.expiry && (r.expiry = (0, o.hexToNumber)(e.expiry)),
              e.sent && (r.sent = (0, o.hexToNumber)(e.sent)),
              e.ttl && (r.ttl = (0, o.hexToNumber)(e.ttl)),
              e.workProved && (r.workProved = (0, o.hexToNumber)(e.workProved)),
              e.topics || (r.topics = []),
              (r.topics =
                null === (t = r.topics) || void 0 === t
                  ? void 0
                  : t.map(o.toUtf8)),
              r
            );
          }),
          (t.outputSyncingFormatter = (e) => {
            const t = Object.assign({}, e);
            return (
              (t.startingBlock = (0, o.hexToNumber)(e.startingBlock)),
              (t.currentBlock = (0, o.hexToNumber)(e.currentBlock)),
              (t.highestBlock = (0, o.hexToNumber)(e.highestBlock)),
              e.knownStates &&
                (t.knownStates = (0, o.hexToNumber)(e.knownStates)),
              e.pulledStates &&
                (t.pulledStates = (0, o.hexToNumber)(e.pulledStates)),
              t
            );
          });
      },
      8557: function (e, t, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (e, t, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(t, r);
                  (i &&
                    !("get" in i
                      ? !t.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return t[r];
                      },
                    }),
                    Object.defineProperty(e, n, i);
                }
              : function (e, t, r, n) {
                  void 0 === n && (n = r), (e[n] = t[r]);
                }),
          i =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (e, t) {
                  Object.defineProperty(e, "default", {
                    enumerable: !0,
                    value: t,
                  });
                }
              : function (e, t) {
                  e.default = t;
                }),
          s =
            (this && this.__exportStar) ||
            function (e, t) {
              for (var r in e)
                "default" === r ||
                  Object.prototype.hasOwnProperty.call(t, r) ||
                  n(t, e, r);
            },
          o =
            (this && this.__importStar) ||
            function (e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(e, r) &&
                    n(t, e, r);
              return i(t, e), t;
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.formatters = void 0),
          s(r(8639), t),
          s(r(3189), t),
          s(r(3604), t),
          s(r(7608), t),
          s(r(5570), t),
          s(r(8024), t),
          s(r(5896), t),
          s(r(4018), t),
          s(r(5550), t),
          s(r(483), t),
          s(r(1541), t),
          (t.formatters = o(r(5550)));
      },
      4018: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
      },
      5896: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.isSupportSubscriptions =
            t.isSupportedProvider =
            t.isLegacySendAsyncProvider =
            t.isLegacySendProvider =
            t.isEIP1193Provider =
            t.isLegacyRequestProvider =
            t.isWeb3Provider =
              void 0);
        const n = r(2823);
        (t.isWeb3Provider = (e) => n.Web3BaseProvider.isWeb3Provider(e)),
          (t.isLegacyRequestProvider = (e) =>
            "string" != typeof e &&
            "request" in e &&
            "Function" === e.request.constructor.name),
          (t.isEIP1193Provider = (e) =>
            "string" != typeof e &&
            "request" in e &&
            "AsyncFunction" === e.request.constructor.name),
          (t.isLegacySendProvider = (e) => "string" != typeof e && "send" in e),
          (t.isLegacySendAsyncProvider = (e) =>
            "string" != typeof e && "sendAsync" in e),
          (t.isSupportedProvider = (e) =>
            e &&
            ((0, t.isWeb3Provider)(e) ||
              (0, t.isEIP1193Provider)(e) ||
              (0, t.isLegacyRequestProvider)(e) ||
              (0, t.isLegacySendAsyncProvider)(e) ||
              (0, t.isLegacySendProvider)(e))),
          (t.isSupportSubscriptions = (e) =>
            e && "supportsSubscriptions" in e
              ? e.supportsSubscriptions()
              : !(!e || "string" == typeof e || !("on" in e)));
      },
      8024: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__awaiter) ||
          function (e, t, r, n) {
            return new (r || (r = Promise))(function (i, s) {
              function o(e) {
                try {
                  c(n.next(e));
                } catch (e) {
                  s(e);
                }
              }
              function a(e) {
                try {
                  c(n.throw(e));
                } catch (e) {
                  s(e);
                }
              }
              function c(e) {
                var t;
                e.done
                  ? i(e.value)
                  : ((t = e.value),
                    t instanceof r
                      ? t
                      : new r(function (e) {
                          e(t);
                        })).then(o, a);
              }
              c((n = n.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Web3BatchRequest = t.DEFAULT_BATCH_REQUEST_TIMEOUT = void 0);
        const i = r(9150),
          s = r(3087);
        (t.DEFAULT_BATCH_REQUEST_TIMEOUT = 1e3),
          (t.Web3BatchRequest = class {
            constructor(e) {
              (this._requestManager = e), (this._requests = new Map());
            }
            get requests() {
              return [...this._requests.values()].map((e) => e.payload);
            }
            add(e) {
              const t = i.jsonRpc.toPayload(e),
                r = new i.Web3DeferredPromise();
              return this._requests.set(t.id, { payload: t, promise: r }), r;
            }
            execute() {
              return n(this, void 0, void 0, function* () {
                if (0 === this.requests.length) return Promise.resolve([]);
                const e = new i.Web3DeferredPromise({
                  timeout: t.DEFAULT_BATCH_REQUEST_TIMEOUT,
                  eagerStart: !0,
                  timeoutMessage: "Batch request timeout",
                });
                return (
                  this._processBatchRequest(e).catch((t) => e.reject(t)),
                  e.catch((t) => {
                    t instanceof s.OperationTimeoutError &&
                      this._abortAllRequests("Batch request timeout"),
                      e.reject(t);
                  }),
                  e
                );
              });
            }
            _processBatchRequest(e) {
              var t, r;
              return n(this, void 0, void 0, function* () {
                const n = yield this._requestManager.sendBatch(
                  [...this._requests.values()].map((e) => e.payload),
                );
                if (n.length !== this._requests.size)
                  throw (
                    (this._abortAllRequests("Invalid batch response"),
                    new s.ResponseError(
                      n,
                      `Batch request size mismatch the results size. Requests: ${this._requests.size}, Responses: ${n.length}`,
                    ))
                  );
                const o = this.requests
                    .map((e) => e.id)
                    .map(Number)
                    .sort((e, t) => e - t),
                  a = n
                    .map((e) => e.id)
                    .map(Number)
                    .sort((e, t) => e - t);
                if (JSON.stringify(o) !== JSON.stringify(a))
                  throw (
                    (this._abortAllRequests("Invalid batch response"),
                    new s.ResponseError(
                      n,
                      `Batch request mismatch the results. Requests: [${o.join()}], Responses: [${a.join()}]`,
                    ))
                  );
                for (const e of n)
                  i.jsonRpc.isResponseWithResult(e)
                    ? null === (t = this._requests.get(e.id)) ||
                      void 0 === t ||
                      t.promise.resolve(e.result)
                    : i.jsonRpc.isResponseWithError(e) &&
                      (null === (r = this._requests.get(e.id)) ||
                        void 0 === r ||
                        r.promise.reject(e.error));
                e.resolve(n);
              });
            }
            _abortAllRequests(e) {
              for (const { promise: t } of this._requests.values())
                t.reject(new s.OperationAbortError(e));
            }
          });
      },
      8639: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Web3Config = t.Web3ConfigEvent = void 0);
        const n = r(3087),
          i = r(9150),
          s = r(1541);
        var o;
        !(function (e) {
          e.CONFIG_CHANGE = "CONFIG_CHANGE";
        })((o = t.Web3ConfigEvent || (t.Web3ConfigEvent = {})));
        class a extends s.Web3EventEmitter {
          constructor(e) {
            super(),
              (this.config = {
                handleRevert: !1,
                defaultAccount: void 0,
                defaultBlock: "latest",
                transactionBlockTimeout: 50,
                transactionConfirmationBlocks: 24,
                transactionPollingInterval: 1e3,
                transactionPollingTimeout: 75e4,
                transactionReceiptPollingInterval: void 0,
                transactionSendTimeout: 75e4,
                transactionConfirmationPollingInterval: void 0,
                blockHeaderTimeout: 10,
                maxListenersWarningThreshold: 100,
                defaultNetworkId: void 0,
                defaultChain: "mainnet",
                defaultHardfork: "london",
                defaultCommon: void 0,
                defaultTransactionType: "0x0",
                defaultMaxPriorityFeePerGas: (0, i.toHex)(25e8),
                enableExperimentalFeatures: {
                  useSubscriptionWhenCheckingBlockTimeout: !1,
                  useRpcCallSpecification: !1,
                },
                transactionBuilder: void 0,
                transactionTypeParser: void 0,
              }),
              this.setConfig(null != e ? e : {});
          }
          setConfig(e) {
            Object.assign(this.config, e);
          }
          get handleRevert() {
            return this.config.handleRevert;
          }
          set handleRevert(e) {
            this._triggerConfigChange("handleRevert", e),
              (this.config.handleRevert = e);
          }
          get defaultAccount() {
            return this.config.defaultAccount;
          }
          set defaultAccount(e) {
            this._triggerConfigChange("defaultAccount", e),
              (this.config.defaultAccount = e);
          }
          get defaultBlock() {
            return this.config.defaultBlock;
          }
          set defaultBlock(e) {
            this._triggerConfigChange("defaultBlock", e),
              (this.config.defaultBlock = e);
          }
          get transactionSendTimeout() {
            return this.config.transactionSendTimeout;
          }
          set transactionSendTimeout(e) {
            this._triggerConfigChange("transactionSendTimeout", e),
              (this.config.transactionSendTimeout = e);
          }
          get transactionBlockTimeout() {
            return this.config.transactionBlockTimeout;
          }
          set transactionBlockTimeout(e) {
            this._triggerConfigChange("transactionBlockTimeout", e),
              (this.config.transactionBlockTimeout = e);
          }
          get transactionConfirmationBlocks() {
            return this.config.transactionConfirmationBlocks;
          }
          set transactionConfirmationBlocks(e) {
            this._triggerConfigChange("transactionConfirmationBlocks", e),
              (this.config.transactionConfirmationBlocks = e);
          }
          get transactionPollingInterval() {
            return this.config.transactionPollingInterval;
          }
          set transactionPollingInterval(e) {
            this._triggerConfigChange("transactionPollingInterval", e),
              (this.config.transactionPollingInterval = e),
              (this.transactionReceiptPollingInterval = e),
              (this.transactionConfirmationPollingInterval = e);
          }
          get transactionPollingTimeout() {
            return this.config.transactionPollingTimeout;
          }
          set transactionPollingTimeout(e) {
            this._triggerConfigChange("transactionPollingTimeout", e),
              (this.config.transactionPollingTimeout = e);
          }
          get transactionReceiptPollingInterval() {
            return this.config.transactionReceiptPollingInterval;
          }
          set transactionReceiptPollingInterval(e) {
            this._triggerConfigChange("transactionReceiptPollingInterval", e),
              (this.config.transactionReceiptPollingInterval = e);
          }
          get transactionConfirmationPollingInterval() {
            return this.config.transactionConfirmationPollingInterval;
          }
          set transactionConfirmationPollingInterval(e) {
            this._triggerConfigChange(
              "transactionConfirmationPollingInterval",
              e,
            ),
              (this.config.transactionConfirmationPollingInterval = e);
          }
          get blockHeaderTimeout() {
            return this.config.blockHeaderTimeout;
          }
          set blockHeaderTimeout(e) {
            this._triggerConfigChange("blockHeaderTimeout", e),
              (this.config.blockHeaderTimeout = e);
          }
          get enableExperimentalFeatures() {
            return this.config.enableExperimentalFeatures;
          }
          set enableExperimentalFeatures(e) {
            this._triggerConfigChange("enableExperimentalFeatures", e),
              (this.config.enableExperimentalFeatures = e);
          }
          get maxListenersWarningThreshold() {
            return this.config.maxListenersWarningThreshold;
          }
          set maxListenersWarningThreshold(e) {
            this._triggerConfigChange("maxListenersWarningThreshold", e),
              this.setMaxListenerWarningThreshold(e),
              (this.config.maxListenersWarningThreshold = e);
          }
          get defaultNetworkId() {
            return this.config.defaultNetworkId;
          }
          set defaultNetworkId(e) {
            this._triggerConfigChange("defaultNetworkId", e),
              (this.config.defaultNetworkId = e);
          }
          get defaultChain() {
            return this.config.defaultChain;
          }
          set defaultChain(e) {
            if (
              !(0, i.isNullish)(this.config.defaultCommon) &&
              !(0, i.isNullish)(this.config.defaultCommon.baseChain) &&
              e !== this.config.defaultCommon.baseChain
            )
              throw new n.ConfigChainMismatchError(this.config.defaultChain, e);
            this._triggerConfigChange("defaultChain", e),
              (this.config.defaultChain = e);
          }
          get defaultHardfork() {
            return this.config.defaultHardfork;
          }
          set defaultHardfork(e) {
            if (
              !(0, i.isNullish)(this.config.defaultCommon) &&
              !(0, i.isNullish)(this.config.defaultCommon.hardfork) &&
              e !== this.config.defaultCommon.hardfork
            )
              throw new n.ConfigHardforkMismatchError(
                this.config.defaultCommon.hardfork,
                e,
              );
            this._triggerConfigChange("defaultHardfork", e),
              (this.config.defaultHardfork = e);
          }
          get defaultCommon() {
            return this.config.defaultCommon;
          }
          set defaultCommon(e) {
            if (
              !(0, i.isNullish)(this.config.defaultHardfork) &&
              !(0, i.isNullish)(e) &&
              !(0, i.isNullish)(e.hardfork) &&
              this.config.defaultHardfork !== e.hardfork
            )
              throw new n.ConfigHardforkMismatchError(
                this.config.defaultHardfork,
                e.hardfork,
              );
            if (
              !(0, i.isNullish)(this.config.defaultChain) &&
              !(0, i.isNullish)(e) &&
              !(0, i.isNullish)(e.baseChain) &&
              this.config.defaultChain !== e.baseChain
            )
              throw new n.ConfigChainMismatchError(
                this.config.defaultChain,
                e.baseChain,
              );
            this._triggerConfigChange("defaultCommon", e),
              (this.config.defaultCommon = e);
          }
          get defaultTransactionType() {
            return this.config.defaultTransactionType;
          }
          set defaultTransactionType(e) {
            this._triggerConfigChange("defaultTransactionType", e),
              (this.config.defaultTransactionType = e);
          }
          get defaultMaxPriorityFeePerGas() {
            return this.config.defaultMaxPriorityFeePerGas;
          }
          set defaultMaxPriorityFeePerGas(e) {
            this._triggerConfigChange("defaultMaxPriorityFeePerGas", e),
              (this.config.defaultMaxPriorityFeePerGas = e);
          }
          get transactionBuilder() {
            return this.config.transactionBuilder;
          }
          set transactionBuilder(e) {
            this._triggerConfigChange("transactionBuilder", e),
              (this.config.transactionBuilder = e);
          }
          get transactionTypeParser() {
            return this.config.transactionTypeParser;
          }
          set transactionTypeParser(e) {
            this._triggerConfigChange("transactionTypeParser", e),
              (this.config.transactionTypeParser = e);
          }
          _triggerConfigChange(e, t) {
            this.emit(o.CONFIG_CHANGE, {
              name: e,
              oldValue: this.config[e],
              newValue: t,
            });
          }
        }
        t.Web3Config = a;
      },
      5570: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__awaiter) ||
          function (e, t, r, n) {
            return new (r || (r = Promise))(function (i, s) {
              function o(e) {
                try {
                  c(n.next(e));
                } catch (e) {
                  s(e);
                }
              }
              function a(e) {
                try {
                  c(n.throw(e));
                } catch (e) {
                  s(e);
                }
              }
              function c(e) {
                var t;
                e.done
                  ? i(e.value)
                  : ((t = e.value),
                    t instanceof r
                      ? t
                      : new r(function (e) {
                          e(t);
                        })).then(o, a);
              }
              c((n = n.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Web3EthPluginBase = t.Web3PluginBase = t.Web3Context = void 0);
        const i = r(9150),
          s = r(3087),
          o = r(5896),
          a = r(8639),
          c = r(3189),
          d = r(3604),
          u = r(8024);
        class l extends a.Web3Config {
          constructor(e) {
            var t;
            if (
              (super(),
              (this.providers = c.Web3RequestManager.providers),
              (0, i.isNullish)(e) ||
                ("string" == typeof e && "" !== e.trim()) ||
                (0, o.isSupportedProvider)(e))
            )
              return (
                (this._requestManager = new c.Web3RequestManager(e)),
                void (this._subscriptionManager = new d.Web3SubscriptionManager(
                  this._requestManager,
                  {},
                ))
              );
            const {
              config: r,
              provider: n,
              requestManager: s,
              subscriptionManager: a,
              registeredSubscriptions: u,
              accountProvider: l,
              wallet: h,
            } = e;
            this.setConfig(null != r ? r : {}),
              (this._requestManager =
                null != s
                  ? s
                  : new c.Web3RequestManager(
                      n,
                      null ===
                        (t =
                          null == r ? void 0 : r.enableExperimentalFeatures) ||
                      void 0 === t
                        ? void 0
                        : t.useSubscriptionWhenCheckingBlockTimeout,
                    )),
              (this._subscriptionManager =
                a ||
                new d.Web3SubscriptionManager(
                  this.requestManager,
                  null != u ? u : {},
                )),
              l && (this._accountProvider = l),
              h && (this._wallet = h);
          }
          get requestManager() {
            return this._requestManager;
          }
          get subscriptionManager() {
            return this._subscriptionManager;
          }
          get wallet() {
            return this._wallet;
          }
          get accountProvider() {
            return this._accountProvider;
          }
          static fromContextObject(...e) {
            return new this(...e.reverse());
          }
          getContextObject() {
            var e;
            return {
              config: this.config,
              provider: this.provider,
              requestManager: this.requestManager,
              subscriptionManager: this.subscriptionManager,
              registeredSubscriptions:
                null === (e = this.subscriptionManager) || void 0 === e
                  ? void 0
                  : e.registeredSubscriptions,
              providers: this.providers,
              wallet: this.wallet,
              accountProvider: this.accountProvider,
            };
          }
          use(e, ...t) {
            const r = new e(...[...t, this.getContextObject()]);
            return (
              this.on(a.Web3ConfigEvent.CONFIG_CHANGE, (e) => {
                r.setConfig({ [e.name]: e.newValue });
              }),
              r
            );
          }
          link(e) {
            this.setConfig(e.config),
              (this._requestManager = e.requestManager),
              (this.provider = e.provider),
              (this._subscriptionManager = e.subscriptionManager),
              (this._wallet = e.wallet),
              (this._accountProvider = e._accountProvider),
              e.on(a.Web3ConfigEvent.CONFIG_CHANGE, (e) => {
                this.setConfig({ [e.name]: e.newValue });
              });
          }
          registerPlugin(e) {
            if (void 0 !== this[e.pluginNamespace])
              throw new s.ExistingPluginNamespaceError(e.pluginNamespace);
            const t = { [e.pluginNamespace]: e };
            t[e.pluginNamespace].link(this), Object.assign(this, t);
          }
          get provider() {
            return this.currentProvider;
          }
          set provider(e) {
            this.requestManager.setProvider(e);
          }
          get currentProvider() {
            return this.requestManager.provider;
          }
          set currentProvider(e) {
            this.requestManager.setProvider(e);
          }
          get givenProvider() {
            return l.givenProvider;
          }
          setProvider(e) {
            return (this.provider = e), !0;
          }
          get BatchRequest() {
            return u.Web3BatchRequest.bind(void 0, this._requestManager);
          }
          extend(e) {
            var t;
            return (
              e.property && !this[e.property] && (this[e.property] = {}),
              null === (t = e.methods) ||
                void 0 === t ||
                t.forEach((t) => {
                  const r = (...e) =>
                    n(this, void 0, void 0, function* () {
                      return this.requestManager.send({
                        method: t.call,
                        params: e,
                      });
                    });
                  e.property
                    ? (this[e.property][t.name] = r)
                    : (this[t.name] = r);
                }),
              this
            );
          }
        }
        (t.Web3Context = l), (l.providers = c.Web3RequestManager.providers);
        class h extends l {}
        (t.Web3PluginBase = h), (t.Web3EthPluginBase = class extends h {});
      },
      1541: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Web3EventEmitter = void 0);
        const n = r(7187);
        t.Web3EventEmitter = class {
          constructor() {
            this._emitter = new n.EventEmitter();
          }
          on(e, t) {
            this._emitter.on(e, t);
          }
          once(e, t) {
            this._emitter.once(e, t);
          }
          off(e, t) {
            this._emitter.off(e, t);
          }
          emit(e, t) {
            this._emitter.emit(e, t);
          }
          listenerCount(e) {
            return this._emitter.listenerCount(e);
          }
          listeners(e) {
            return this._emitter.listeners(e);
          }
          eventNames() {
            return this._emitter.eventNames();
          }
          removeAllListeners() {
            return this._emitter.removeAllListeners();
          }
          setMaxListenerWarningThreshold(e) {
            this._emitter.setMaxListeners(e);
          }
          getMaxListeners() {
            return this._emitter.getMaxListeners();
          }
        };
      },
      483: function (e, t, r) {
        "use strict";
        var n,
          i =
            (this && this.__awaiter) ||
            function (e, t, r, n) {
              return new (r || (r = Promise))(function (i, s) {
                function o(e) {
                  try {
                    c(n.next(e));
                  } catch (e) {
                    s(e);
                  }
                }
                function a(e) {
                  try {
                    c(n.throw(e));
                  } catch (e) {
                    s(e);
                  }
                }
                function c(e) {
                  var t;
                  e.done
                    ? i(e.value)
                    : ((t = e.value),
                      t instanceof r
                        ? t
                        : new r(function (e) {
                            e(t);
                          })).then(o, a);
                }
                c((n = n.apply(e, t || [])).next());
              });
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Web3PromiEvent = void 0);
        const s = r(1541);
        class o extends s.Web3EventEmitter {
          constructor(e) {
            super(), (this[n] = "Promise"), (this._promise = new Promise(e));
          }
          then(e, t) {
            return i(this, void 0, void 0, function* () {
              return this._promise.then(e, t);
            });
          }
          catch(e) {
            return i(this, void 0, void 0, function* () {
              return this._promise.catch(e);
            });
          }
          finally(e) {
            return i(this, void 0, void 0, function* () {
              return this._promise.finally(e);
            });
          }
          on(e, t) {
            return super.on(e, t), this;
          }
          once(e, t) {
            return super.once(e, t), this;
          }
        }
        (t.Web3PromiEvent = o), (n = Symbol.toStringTag);
      },
      3189: function (e, t, r) {
        "use strict";
        var n =
            (this && this.__awaiter) ||
            function (e, t, r, n) {
              return new (r || (r = Promise))(function (i, s) {
                function o(e) {
                  try {
                    c(n.next(e));
                  } catch (e) {
                    s(e);
                  }
                }
                function a(e) {
                  try {
                    c(n.throw(e));
                  } catch (e) {
                    s(e);
                  }
                }
                function c(e) {
                  var t;
                  e.done
                    ? i(e.value)
                    : ((t = e.value),
                      t instanceof r
                        ? t
                        : new r(function (e) {
                            e(t);
                          })).then(o, a);
                }
                c((n = n.apply(e, t || [])).next());
              });
            },
          i =
            (this && this.__importDefault) ||
            function (e) {
              return e && e.__esModule ? e : { default: e };
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Web3RequestManager = t.Web3RequestManagerEvent = void 0);
        const s = r(3087),
          o = i(r(9701)),
          a = i(r(4417)),
          c = r(9150),
          d = r(5896),
          u = r(1541);
        var l;
        !(function (e) {
          (e.PROVIDER_CHANGED = "PROVIDER_CHANGED"),
            (e.BEFORE_PROVIDER_CHANGE = "BEFORE_PROVIDER_CHANGE");
        })((l = t.Web3RequestManagerEvent || (t.Web3RequestManagerEvent = {})));
        const h = { HttpProvider: o.default, WebsocketProvider: a.default };
        class f extends u.Web3EventEmitter {
          constructor(e, t) {
            super(),
              (0, c.isNullish)(e) || this.setProvider(e),
              (this.useRpcCallSpecification = t);
          }
          static get providers() {
            return h;
          }
          get provider() {
            return this._provider;
          }
          get providers() {
            return h;
          }
          setProvider(e) {
            let t;
            if (e && "string" == typeof e && this.providers)
              if (/^http(s)?:\/\//i.test(e))
                t = new this.providers.HttpProvider(e);
              else {
                if (!/^ws(s)?:\/\//i.test(e))
                  throw new s.ProviderError(
                    `Can't autodetect provider for "${e}"`,
                  );
                t = new this.providers.WebsocketProvider(e);
              }
            else t = (0, c.isNullish)(e) ? void 0 : e;
            return (
              this.emit(l.BEFORE_PROVIDER_CHANGE, this._provider),
              (this._provider = t),
              this.emit(l.PROVIDER_CHANGED, this._provider),
              !0
            );
          }
          send(e) {
            return n(this, void 0, void 0, function* () {
              const t = yield this._sendRequest(e);
              if (c.jsonRpc.isResponseWithResult(t)) return t.result;
              throw new s.ResponseError(t);
            });
          }
          sendBatch(e) {
            return n(this, void 0, void 0, function* () {
              return yield this._sendRequest(e);
            });
          }
          _sendRequest(e) {
            return n(this, void 0, void 0, function* () {
              const { provider: t } = this;
              if ((0, c.isNullish)(t))
                throw new s.ProviderError(
                  "Provider not available. Use `.setProvider` or `.provider=` to initialize the provider.",
                );
              const r = c.jsonRpc.isBatchRequest(e)
                ? c.jsonRpc.toBatchPayload(e)
                : c.jsonRpc.toPayload(e);
              if ((0, d.isWeb3Provider)(t)) {
                let e;
                try {
                  e = yield t.request(r);
                } catch (t) {
                  e = t;
                }
                return this._processJsonRpcResponse(r, e, {
                  legacy: !1,
                  error: !1,
                });
              }
              if ((0, d.isEIP1193Provider)(t))
                return t
                  .request(r)
                  .then((e) =>
                    this._processJsonRpcResponse(r, e, {
                      legacy: !0,
                      error: !1,
                    }),
                  )
                  .catch((e) =>
                    this._processJsonRpcResponse(r, e, {
                      legacy: !0,
                      error: !0,
                    }),
                  );
              if ((0, d.isLegacyRequestProvider)(t))
                return new Promise((e, n) => {
                  const i = (e) =>
                      n(
                        this._processJsonRpcResponse(r, e, {
                          legacy: !0,
                          error: !0,
                        }),
                      ),
                    s = (t) =>
                      e(
                        this._processJsonRpcResponse(r, t, {
                          legacy: !0,
                          error: !1,
                        }),
                      ),
                    o = t.request(r, (e, t) => (e ? i(e) : s(t)));
                  (0, c.isPromise)(o) && o.then(s).catch(i);
                });
              if ((0, d.isLegacySendProvider)(t))
                return new Promise((e, n) => {
                  t.send(r, (t, i) => {
                    if (t)
                      return n(
                        this._processJsonRpcResponse(r, t, {
                          legacy: !0,
                          error: !0,
                        }),
                      );
                    if ((0, c.isNullish)(i))
                      throw new s.ResponseError(
                        "",
                        'Got a "nullish" response from provider.',
                      );
                    return e(
                      this._processJsonRpcResponse(r, i, {
                        legacy: !0,
                        error: !1,
                      }),
                    );
                  });
                });
              if ((0, d.isLegacySendAsyncProvider)(t))
                return t
                  .sendAsync(r)
                  .then((e) =>
                    this._processJsonRpcResponse(r, e, {
                      legacy: !0,
                      error: !1,
                    }),
                  )
                  .catch((e) =>
                    this._processJsonRpcResponse(r, e, {
                      legacy: !0,
                      error: !0,
                    }),
                  );
              throw new s.ProviderError(
                "Provider does not have a request or send method to use.",
              );
            });
          }
          _processJsonRpcResponse(e, t, { legacy: r, error: n }) {
            if ((0, c.isNullish)(t)) return this._buildResponse(e, null, n);
            if (c.jsonRpc.isResponseWithError(t)) {
              if (
                this.useRpcCallSpecification &&
                (0, c.isResponseRpcError)(t)
              ) {
                const e = t;
                if (s.rpcErrorsMap.get(e.error.code))
                  throw new (0, s.rpcErrorsMap.get(e.error.code).error)(e);
                throw new s.RpcError(e);
              }
              if (!f._isReverted(t)) throw new s.InvalidResponseError(t, e);
            }
            if (c.jsonRpc.isResponseWithResult(t)) return t;
            if (t instanceof Error) throw (f._isReverted(t), t);
            if (
              !r &&
              c.jsonRpc.isBatchRequest(e) &&
              c.jsonRpc.isBatchResponse(t)
            )
              return t;
            if (r && !n && c.jsonRpc.isBatchRequest(e)) return t;
            if (r && n && c.jsonRpc.isBatchRequest(e)) throw t;
            if (
              r &&
              !c.jsonRpc.isResponseWithError(t) &&
              !c.jsonRpc.isResponseWithResult(t)
            )
              return this._buildResponse(e, t, n);
            if (c.jsonRpc.isBatchRequest(e) && !Array.isArray(t))
              throw new s.ResponseError(
                t,
                "Got normal response for a batch request.",
              );
            if (!c.jsonRpc.isBatchRequest(e) && Array.isArray(t))
              throw new s.ResponseError(
                t,
                "Got batch response for a normal request.",
              );
            if (
              (c.jsonRpc.isResponseWithError(t) ||
                c.jsonRpc.isResponseWithResult(t)) &&
              !c.jsonRpc.isBatchRequest(e) &&
              t.id &&
              e.id !== t.id
            )
              throw new s.InvalidResponseError(t);
            throw new s.ResponseError(t, "Invalid response");
          }
          static _isReverted(e) {
            let t;
            if (
              (c.jsonRpc.isResponseWithError(e)
                ? (t = e.error)
                : e instanceof Error && (t = e),
              null == t ? void 0 : t.message.includes("revert"))
            )
              throw new s.ContractExecutionError(t);
            return !1;
          }
          _buildResponse(e, t, r) {
            const n = {
              jsonrpc: "2.0",
              id: c.jsonRpc.isBatchRequest(e)
                ? e[0].id
                : "id" in e
                ? e.id
                : null,
            };
            return r
              ? Object.assign(Object.assign({}, n), { error: t })
              : Object.assign(Object.assign({}, n), { result: t });
          }
        }
        t.Web3RequestManager = f;
      },
      3604: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__awaiter) ||
          function (e, t, r, n) {
            return new (r || (r = Promise))(function (i, s) {
              function o(e) {
                try {
                  c(n.next(e));
                } catch (e) {
                  s(e);
                }
              }
              function a(e) {
                try {
                  c(n.throw(e));
                } catch (e) {
                  s(e);
                }
              }
              function c(e) {
                var t;
                e.done
                  ? i(e.value)
                  : ((t = e.value),
                    t instanceof r
                      ? t
                      : new r(function (e) {
                          e(t);
                        })).then(o, a);
              }
              c((n = n.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Web3SubscriptionManager = void 0);
        const i = r(2823),
          s = r(3087),
          o = r(9150),
          a = r(5896),
          c = r(3189);
        t.Web3SubscriptionManager = class {
          constructor(e, t, r = !1) {
            (this.requestManager = e),
              (this.registeredSubscriptions = t),
              (this.tolerateUnlinkedSubscription = r),
              (this._subscriptions = new Map()),
              this.requestManager.on(
                c.Web3RequestManagerEvent.BEFORE_PROVIDER_CHANGE,
                () =>
                  n(this, void 0, void 0, function* () {
                    yield this.unsubscribe();
                  }),
              ),
              this.requestManager.on(
                c.Web3RequestManagerEvent.PROVIDER_CHANGED,
                () => {
                  this.clear(), this.listenToProviderEvents();
                },
              ),
              this.listenToProviderEvents();
          }
          listenToProviderEvents() {
            const e = this.requestManager.provider;
            this.requestManager.provider &&
              ("function" !=
                typeof (null == e ? void 0 : e.supportsSubscriptions) ||
                (null == e ? void 0 : e.supportsSubscriptions())) &&
              "function" == typeof this.requestManager.provider.on &&
              ("function" == typeof this.requestManager.provider.request
                ? this.requestManager.provider.on("message", (e) =>
                    this.messageListener(e),
                  )
                : e.on("data", (e) => this.messageListener(e)));
          }
          messageListener(e) {
            var t, r, n;
            if (!e)
              throw new s.SubscriptionError(
                "Should not call messageListener with no data. Type was",
              );
            const i =
              (null === (t = e.params) || void 0 === t
                ? void 0
                : t.subscription) ||
              (null === (r = e.data) || void 0 === r
                ? void 0
                : r.subscription) ||
              (null === (n = e.id) || void 0 === n ? void 0 : n.toString(16));
            if (i) {
              const t = this._subscriptions.get(i);
              null == t || t.processSubscriptionData(e);
            }
          }
          subscribe(e, t, r = i.DEFAULT_RETURN_FORMAT) {
            return n(this, void 0, void 0, function* () {
              const n = this.registeredSubscriptions[e];
              if (!n)
                throw new s.SubscriptionError("Invalid subscription type");
              const i = new n(null != t ? t : void 0, {
                subscriptionManager: this,
                returnFormat: r,
              });
              return yield this.addSubscription(i), i;
            });
          }
          get subscriptions() {
            return this._subscriptions;
          }
          addSubscription(e) {
            return n(this, void 0, void 0, function* () {
              if (!this.requestManager.provider)
                throw new s.ProviderError("Provider not available");
              if (!this.supportsSubscriptions())
                throw new s.SubscriptionError(
                  "The current provider does not support subscriptions",
                );
              if (e.id && this._subscriptions.has(e.id))
                throw new s.SubscriptionError(
                  `Subscription with id "${e.id}" already exists`,
                );
              if ((yield e.sendSubscriptionRequest(), (0, o.isNullish)(e.id)))
                throw new s.SubscriptionError(
                  "Subscription is not subscribed yet.",
                );
              return this._subscriptions.set(e.id, e), e.id;
            });
          }
          removeSubscription(e) {
            return n(this, void 0, void 0, function* () {
              const { id: t } = e;
              if ((0, o.isNullish)(t))
                throw new s.SubscriptionError(
                  "Subscription is not subscribed yet. Or, had already been unsubscribed but not through the Subscription Manager.",
                );
              if (
                !this._subscriptions.has(t) &&
                !this.tolerateUnlinkedSubscription
              )
                throw new s.SubscriptionError(
                  `Subscription with id "${t.toString()}" does not exists`,
                );
              return (
                yield e.sendUnsubscribeRequest(),
                this._subscriptions.delete(t),
                t
              );
            });
          }
          unsubscribe(e) {
            return n(this, void 0, void 0, function* () {
              const t = [];
              for (const [r, n] of this.subscriptions.entries())
                (!e || ("function" == typeof e && e({ id: r, sub: n }))) &&
                  t.push(this.removeSubscription(n));
              return Promise.all(t);
            });
          }
          clear() {
            this._subscriptions.clear();
          }
          supportsSubscriptions() {
            return (
              !(0, o.isNullish)(this.requestManager.provider) &&
              (0, a.isSupportSubscriptions)(this.requestManager.provider)
            );
          }
        };
      },
      7608: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__awaiter) ||
          function (e, t, r, n) {
            return new (r || (r = Promise))(function (i, s) {
              function o(e) {
                try {
                  c(n.next(e));
                } catch (e) {
                  s(e);
                }
              }
              function a(e) {
                try {
                  c(n.throw(e));
                } catch (e) {
                  s(e);
                }
              }
              function c(e) {
                var t;
                e.done
                  ? i(e.value)
                  : ((t = e.value),
                    t instanceof r
                      ? t
                      : new r(function (e) {
                          e(t);
                        })).then(o, a);
              }
              c((n = n.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Web3Subscription = void 0);
        const i = r(2823),
          s = r(9150),
          o = r(3087),
          a = r(3604),
          c = r(1541);
        class d extends c.Web3EventEmitter {
          constructor(e, t) {
            var r;
            super(), (this.args = e);
            const { requestManager: n } = t,
              { subscriptionManager: s } = t;
            if (n && s)
              throw new o.SubscriptionError(
                "Only requestManager or subscriptionManager should be provided at Subscription constructor",
              );
            if (!n && !s)
              throw new o.SubscriptionError(
                "Either requestManager or subscriptionManager should be provided at Subscription constructor",
              );
            (this._subscriptionManager = n
              ? new a.Web3SubscriptionManager(n, {}, !0)
              : s),
              (this._returnFormat =
                null !== (r = null == t ? void 0 : t.returnFormat) &&
                void 0 !== r
                  ? r
                  : i.DEFAULT_RETURN_FORMAT);
          }
          get id() {
            return this._id;
          }
          get lastBlock() {
            return this._lastBlock;
          }
          subscribe() {
            return n(this, void 0, void 0, function* () {
              return this._subscriptionManager.addSubscription(this);
            });
          }
          processSubscriptionData(e) {
            var t, r;
            (null == e ? void 0 : e.data)
              ? this._processSubscriptionResult(
                  null !==
                    (r =
                      null === (t = null == e ? void 0 : e.data) || void 0 === t
                        ? void 0
                        : t.result) && void 0 !== r
                    ? r
                    : null == e
                    ? void 0
                    : e.data,
                )
              : e &&
                s.jsonRpc.isResponseWithNotification(e) &&
                this._processSubscriptionResult(
                  null == e ? void 0 : e.params.result,
                );
          }
          sendSubscriptionRequest() {
            return n(this, void 0, void 0, function* () {
              return (
                (this._id = yield this._subscriptionManager.requestManager.send(
                  {
                    method: "eth_subscribe",
                    params: this._buildSubscriptionParams(),
                  },
                )),
                this.emit("connected", this._id),
                this._id
              );
            });
          }
          get returnFormat() {
            return this._returnFormat;
          }
          get subscriptionManager() {
            return this._subscriptionManager;
          }
          resubscribe() {
            return n(this, void 0, void 0, function* () {
              yield this.unsubscribe(), yield this.subscribe();
            });
          }
          unsubscribe() {
            return n(this, void 0, void 0, function* () {
              this.id &&
                (yield this._subscriptionManager.removeSubscription(this));
            });
          }
          sendUnsubscribeRequest() {
            return n(this, void 0, void 0, function* () {
              yield this._subscriptionManager.requestManager.send({
                method: "eth_unsubscribe",
                params: [this.id],
              }),
                (this._id = void 0);
            });
          }
          formatSubscriptionResult(e) {
            return e;
          }
          _processSubscriptionResult(e) {
            this.emit("data", this.formatSubscriptionResult(e));
          }
          _processSubscriptionError(e) {
            this.emit("error", e);
          }
          _buildSubscriptionParams() {
            throw new Error("Implement in the child class");
          }
        }
        t.Web3Subscription = d;
      },
      6901: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ERR_TX_RECEIPT_MISSING_OR_BLOCKHASH_NULL =
            t.ERR_TX_POLLING_TIMEOUT =
            t.ERR_TX_DATA_AND_INPUT =
            t.ERR_TX_UNSUPPORTED_TYPE =
            t.ERR_TX_UNSUPPORTED_EIP_1559 =
            t.ERR_TX_UNABLE_TO_POPULATE_NONCE =
            t.ERR_TX_INVALID_NONCE_OR_CHAIN_ID =
            t.ERR_TX_INVALID_OBJECT =
            t.ERR_TX_INVALID_LEGACY_FEE_MARKET =
            t.ERR_TX_INVALID_FEE_MARKET_GAS_PRICE =
            t.ERR_TX_INVALID_FEE_MARKET_GAS =
            t.ERR_TX_INVALID_LEGACY_GAS =
            t.ERR_TX_MISSING_GAS =
            t.ERR_TX_MISSING_CHAIN_INFO =
            t.ERR_TX_INVALID_CHAIN_INFO =
            t.ERR_TX_CHAIN_ID_MISMATCH =
            t.ERR_TX_MISSING_CUSTOM_CHAIN_ID =
            t.ERR_TX_MISSING_CUSTOM_CHAIN =
            t.ERR_TX_INVALID_CALL =
            t.ERR_TX_INVALID_SENDER =
            t.ERR_RAW_TX_UNDEFINED =
            t.ERR_TX_OUT_OF_GAS =
            t.ERR_TX_REVERT_WITHOUT_REASON =
            t.ERR_TX_CONTRACT_NOT_STORED =
            t.ERR_TX_NO_CONTRACT_ADDRESS =
            t.ERR_TX_REVERT_TRANSACTION =
            t.ERR_TX_REVERT_INSTRUCTION =
            t.ERR_TX =
            t.ERR_CONTRACT_TX_DATA_AND_INPUT =
            t.ERR_CONTRACT_EXECUTION_REVERTED =
            t.ERR_CONTRACT_INSTANTIATION =
            t.ERR_CONTRACT_MISSING_FROM_ADDRESS =
            t.ERR_CONTRACT_MISSING_ADDRESS =
            t.ERR_CONTRACT_MISSING_DEPLOY_DATA =
            t.ERR_CONTRACT_RESERVED_EVENT =
            t.ERR_CONTRACT_EVENT_NOT_EXISTS =
            t.ERR_CONTRACT_REQUIRED_CALLBACK =
            t.ERR_CONTRACT_ABI_MISSING =
            t.ERR_CONTRACT_RESOLVER_MISSING =
            t.ERR_CONTRACT =
            t.ERR_INVALID_METHOD_PARAMS =
            t.ERR_EXISTING_PLUGIN_NAMESPACE =
            t.ERR_ABI_ENCODING =
            t.ERR_OPERATION_ABORT =
            t.ERR_OPERATION_TIMEOUT =
            t.ERR_METHOD_NOT_IMPLEMENTED =
            t.ERR_FORMATTERS =
            t.ERR_PARAM =
            t.ERR_INVALID_RESPONSE =
            t.ERR_RESPONSE =
              void 0),
          (t.ERR_INVALID_NUMBER =
            t.ERR_INVALID_BYTES =
            t.ERR_INVALID_STRING =
            t.ERR_ENS_NETWORK_NOT_SYNCED =
            t.ERR_ENS_UNSUPPORTED_NETWORK =
            t.ERR_ENS_CHECK_INTERFACE_SUPPORT =
            t.JSONRPC_ERR_CHAIN_DISCONNECTED =
            t.JSONRPC_ERR_DISCONNECTED =
            t.JSONRPC_ERR_UNSUPPORTED_METHOD =
            t.JSONRPC_ERR_UNAUTHORIZED =
            t.JSONRPC_ERR_REJECTED_REQUEST =
            t.GENESIS_BLOCK_NUMBER =
            t.ERR_INVALID_SIGNATURE =
            t.ERR_SIGNATURE_FAILED =
            t.ERR_PBKDF2_ITERATIONS =
            t.ERR_INVALID_KEYSTORE =
            t.ERR_IV_LENGTH =
            t.ERR_INVALID_PASSWORD =
            t.ERR_KEY_VERSION_UNSUPPORTED =
            t.ERR_KEY_DERIVATION_FAIL =
            t.ERR_UNSUPPORTED_KDF =
            t.ERR_INVALID_PRIVATE_KEY =
            t.ERR_PRIVATE_KEY_LENGTH =
            t.ERR_WS_PROVIDER =
            t.ERR_SUBSCRIPTION =
            t.ERR_INVALID_CLIENT =
            t.ERR_INVALID_PROVIDER =
            t.ERR_PROVIDER =
            t.ERR_REQ_ALREADY_SENT =
            t.ERR_CONN_PENDING_REQUESTS =
            t.ERR_CONN_MAX_ATTEMPTS =
            t.ERR_CONN_CLOSE =
            t.ERR_CONN_NOT_OPEN =
            t.ERR_CONN_TIMEOUT =
            t.ERR_CONN_INVALID =
            t.ERR_CONN =
            t.ERR_TX_GAS_MISMATCH_INNER_ERROR =
            t.ERR_TX_MISSING_GAS_INNER_ERROR =
            t.ERR_TX_INVALID_PROPERTIES_FOR_TYPE =
            t.ERR_TX_REVERT_TRANSACTION_CUSTOM_ERROR =
            t.ERR_TX_INVALID_RECEIVER =
            t.ERR_TX_HARDFORK_MISMATCH =
            t.ERR_TX_CHAIN_MISMATCH =
            t.ERR_TX_GAS_MISMATCH =
            t.ERR_TX_SIGNING =
            t.ERR_TX_BLOCK_TIMEOUT =
            t.ERR_TX_SEND_TIMEOUT =
            t.ERR_TX_NOT_FOUND =
            t.ERR_TX_LOCAL_WALLET_NOT_AVAILABLE =
            t.ERR_TX_RECEIPT_MISSING_BLOCK_NUMBER =
              void 0),
          (t.ERR_RPC_NOT_SUPPORTED =
            t.ERR_RPC_LIMIT_EXCEEDED =
            t.ERR_RPC_UNSUPPORTED_METHOD =
            t.ERR_RPC_TRANSACTION_REJECTED =
            t.ERR_RPC_UNAVAILABLE_RESOURCE =
            t.ERR_RPC_MISSING_RESOURCE =
            t.ERR_RPC_INVALID_INPUT =
            t.ERR_RPC_INTERNAL_ERROR =
            t.ERR_RPC_INVALID_PARAMS =
            t.ERR_RPC_INVALID_METHOD =
            t.ERR_RPC_INVALID_REQUEST =
            t.ERR_RPC_INVALID_JSON =
            t.ERR_CORE_CHAIN_MISMATCH =
            t.ERR_CORE_HARDFORK_MISMATCH =
            t.ERR_VALIDATION =
            t.ERR_INVALID_NIBBLE_WIDTH =
            t.ERR_INVALID_TYPE_ABI =
            t.ERR_INVALID_BLOCK =
            t.ERR_INVALID_LARGE_VALUE =
            t.ERR_INVALID_SIZE =
            t.ERR_INVALID_UNSIGNED_INTEGER =
            t.ERR_INVALID_BOOLEAN =
            t.ERR_INVALID_TYPE =
            t.ERR_INVALID_HEX =
            t.ERR_INVALID_ADDRESS =
            t.ERR_INVALID_UNIT =
              void 0),
          (t.ERR_RESPONSE = 100),
          (t.ERR_INVALID_RESPONSE = 101),
          (t.ERR_PARAM = 200),
          (t.ERR_FORMATTERS = 201),
          (t.ERR_METHOD_NOT_IMPLEMENTED = 202),
          (t.ERR_OPERATION_TIMEOUT = 203),
          (t.ERR_OPERATION_ABORT = 204),
          (t.ERR_ABI_ENCODING = 205),
          (t.ERR_EXISTING_PLUGIN_NAMESPACE = 206),
          (t.ERR_INVALID_METHOD_PARAMS = 207),
          (t.ERR_CONTRACT = 300),
          (t.ERR_CONTRACT_RESOLVER_MISSING = 301),
          (t.ERR_CONTRACT_ABI_MISSING = 302),
          (t.ERR_CONTRACT_REQUIRED_CALLBACK = 303),
          (t.ERR_CONTRACT_EVENT_NOT_EXISTS = 304),
          (t.ERR_CONTRACT_RESERVED_EVENT = 305),
          (t.ERR_CONTRACT_MISSING_DEPLOY_DATA = 306),
          (t.ERR_CONTRACT_MISSING_ADDRESS = 307),
          (t.ERR_CONTRACT_MISSING_FROM_ADDRESS = 308),
          (t.ERR_CONTRACT_INSTANTIATION = 309),
          (t.ERR_CONTRACT_EXECUTION_REVERTED = 310),
          (t.ERR_CONTRACT_TX_DATA_AND_INPUT = 311),
          (t.ERR_TX = 400),
          (t.ERR_TX_REVERT_INSTRUCTION = 401),
          (t.ERR_TX_REVERT_TRANSACTION = 402),
          (t.ERR_TX_NO_CONTRACT_ADDRESS = 403),
          (t.ERR_TX_CONTRACT_NOT_STORED = 404),
          (t.ERR_TX_REVERT_WITHOUT_REASON = 405),
          (t.ERR_TX_OUT_OF_GAS = 406),
          (t.ERR_RAW_TX_UNDEFINED = 407),
          (t.ERR_TX_INVALID_SENDER = 408),
          (t.ERR_TX_INVALID_CALL = 409),
          (t.ERR_TX_MISSING_CUSTOM_CHAIN = 410),
          (t.ERR_TX_MISSING_CUSTOM_CHAIN_ID = 411),
          (t.ERR_TX_CHAIN_ID_MISMATCH = 412),
          (t.ERR_TX_INVALID_CHAIN_INFO = 413),
          (t.ERR_TX_MISSING_CHAIN_INFO = 414),
          (t.ERR_TX_MISSING_GAS = 415),
          (t.ERR_TX_INVALID_LEGACY_GAS = 416),
          (t.ERR_TX_INVALID_FEE_MARKET_GAS = 417),
          (t.ERR_TX_INVALID_FEE_MARKET_GAS_PRICE = 418),
          (t.ERR_TX_INVALID_LEGACY_FEE_MARKET = 419),
          (t.ERR_TX_INVALID_OBJECT = 420),
          (t.ERR_TX_INVALID_NONCE_OR_CHAIN_ID = 421),
          (t.ERR_TX_UNABLE_TO_POPULATE_NONCE = 422),
          (t.ERR_TX_UNSUPPORTED_EIP_1559 = 423),
          (t.ERR_TX_UNSUPPORTED_TYPE = 424),
          (t.ERR_TX_DATA_AND_INPUT = 425),
          (t.ERR_TX_POLLING_TIMEOUT = 426),
          (t.ERR_TX_RECEIPT_MISSING_OR_BLOCKHASH_NULL = 427),
          (t.ERR_TX_RECEIPT_MISSING_BLOCK_NUMBER = 428),
          (t.ERR_TX_LOCAL_WALLET_NOT_AVAILABLE = 429),
          (t.ERR_TX_NOT_FOUND = 430),
          (t.ERR_TX_SEND_TIMEOUT = 431),
          (t.ERR_TX_BLOCK_TIMEOUT = 432),
          (t.ERR_TX_SIGNING = 433),
          (t.ERR_TX_GAS_MISMATCH = 434),
          (t.ERR_TX_CHAIN_MISMATCH = 435),
          (t.ERR_TX_HARDFORK_MISMATCH = 436),
          (t.ERR_TX_INVALID_RECEIVER = 437),
          (t.ERR_TX_REVERT_TRANSACTION_CUSTOM_ERROR = 438),
          (t.ERR_TX_INVALID_PROPERTIES_FOR_TYPE = 439),
          (t.ERR_TX_MISSING_GAS_INNER_ERROR = 440),
          (t.ERR_TX_GAS_MISMATCH_INNER_ERROR = 441),
          (t.ERR_CONN = 500),
          (t.ERR_CONN_INVALID = 501),
          (t.ERR_CONN_TIMEOUT = 502),
          (t.ERR_CONN_NOT_OPEN = 503),
          (t.ERR_CONN_CLOSE = 504),
          (t.ERR_CONN_MAX_ATTEMPTS = 505),
          (t.ERR_CONN_PENDING_REQUESTS = 506),
          (t.ERR_REQ_ALREADY_SENT = 507),
          (t.ERR_PROVIDER = 600),
          (t.ERR_INVALID_PROVIDER = 601),
          (t.ERR_INVALID_CLIENT = 602),
          (t.ERR_SUBSCRIPTION = 603),
          (t.ERR_WS_PROVIDER = 604),
          (t.ERR_PRIVATE_KEY_LENGTH = 701),
          (t.ERR_INVALID_PRIVATE_KEY = 702),
          (t.ERR_UNSUPPORTED_KDF = 703),
          (t.ERR_KEY_DERIVATION_FAIL = 704),
          (t.ERR_KEY_VERSION_UNSUPPORTED = 705),
          (t.ERR_INVALID_PASSWORD = 706),
          (t.ERR_IV_LENGTH = 707),
          (t.ERR_INVALID_KEYSTORE = 708),
          (t.ERR_PBKDF2_ITERATIONS = 709),
          (t.ERR_SIGNATURE_FAILED = 801),
          (t.ERR_INVALID_SIGNATURE = 802),
          (t.GENESIS_BLOCK_NUMBER = "0x0"),
          (t.JSONRPC_ERR_REJECTED_REQUEST = 4001),
          (t.JSONRPC_ERR_UNAUTHORIZED = 4100),
          (t.JSONRPC_ERR_UNSUPPORTED_METHOD = 4200),
          (t.JSONRPC_ERR_DISCONNECTED = 4900),
          (t.JSONRPC_ERR_CHAIN_DISCONNECTED = 4901),
          (t.ERR_ENS_CHECK_INTERFACE_SUPPORT = 901),
          (t.ERR_ENS_UNSUPPORTED_NETWORK = 902),
          (t.ERR_ENS_NETWORK_NOT_SYNCED = 903),
          (t.ERR_INVALID_STRING = 1001),
          (t.ERR_INVALID_BYTES = 1002),
          (t.ERR_INVALID_NUMBER = 1003),
          (t.ERR_INVALID_UNIT = 1004),
          (t.ERR_INVALID_ADDRESS = 1005),
          (t.ERR_INVALID_HEX = 1006),
          (t.ERR_INVALID_TYPE = 1007),
          (t.ERR_INVALID_BOOLEAN = 1008),
          (t.ERR_INVALID_UNSIGNED_INTEGER = 1009),
          (t.ERR_INVALID_SIZE = 1010),
          (t.ERR_INVALID_LARGE_VALUE = 1011),
          (t.ERR_INVALID_BLOCK = 1012),
          (t.ERR_INVALID_TYPE_ABI = 1013),
          (t.ERR_INVALID_NIBBLE_WIDTH = 1014),
          (t.ERR_VALIDATION = 1100),
          (t.ERR_CORE_HARDFORK_MISMATCH = 1101),
          (t.ERR_CORE_CHAIN_MISMATCH = 1102),
          (t.ERR_RPC_INVALID_JSON = -32700),
          (t.ERR_RPC_INVALID_REQUEST = -32600),
          (t.ERR_RPC_INVALID_METHOD = -32601),
          (t.ERR_RPC_INVALID_PARAMS = -32602),
          (t.ERR_RPC_INTERNAL_ERROR = -32603),
          (t.ERR_RPC_INVALID_INPUT = -32e3),
          (t.ERR_RPC_MISSING_RESOURCE = -32001),
          (t.ERR_RPC_UNAVAILABLE_RESOURCE = -32002),
          (t.ERR_RPC_TRANSACTION_REJECTED = -32003),
          (t.ERR_RPC_UNSUPPORTED_METHOD = -32004),
          (t.ERR_RPC_LIMIT_EXCEEDED = -32005),
          (t.ERR_RPC_NOT_SUPPORTED = -32006);
      },
      8572: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PBKDF2IterationsError =
            t.IVLengthError =
            t.InvalidPasswordError =
            t.KeyStoreVersionError =
            t.KeyDerivationError =
            t.InvalidKdfError =
            t.InvalidSignatureError =
            t.InvalidPrivateKeyError =
            t.PrivateKeyLengthError =
              void 0);
        const n = r(6901),
          i = r(7646);
        class s extends i.BaseWeb3Error {
          constructor() {
            super("Private key must be 32 bytes."),
              (this.code = n.ERR_PRIVATE_KEY_LENGTH);
          }
        }
        t.PrivateKeyLengthError = s;
        class o extends i.BaseWeb3Error {
          constructor() {
            super("Invalid Private Key, Not a valid string or uint8Array"),
              (this.code = n.ERR_INVALID_PRIVATE_KEY);
          }
        }
        t.InvalidPrivateKeyError = o;
        class a extends i.BaseWeb3Error {
          constructor(e) {
            super(`"${e}"`), (this.code = n.ERR_INVALID_SIGNATURE);
          }
        }
        t.InvalidSignatureError = a;
        class c extends i.BaseWeb3Error {
          constructor() {
            super("Invalid key derivation function"),
              (this.code = n.ERR_UNSUPPORTED_KDF);
          }
        }
        t.InvalidKdfError = c;
        class d extends i.BaseWeb3Error {
          constructor() {
            super("Key derivation failed - possibly wrong password"),
              (this.code = n.ERR_KEY_DERIVATION_FAIL);
          }
        }
        t.KeyDerivationError = d;
        class u extends i.BaseWeb3Error {
          constructor() {
            super("Unsupported key store version"),
              (this.code = n.ERR_KEY_VERSION_UNSUPPORTED);
          }
        }
        t.KeyStoreVersionError = u;
        class l extends i.BaseWeb3Error {
          constructor() {
            super("Password cannot be empty"),
              (this.code = n.ERR_INVALID_PASSWORD);
          }
        }
        t.InvalidPasswordError = l;
        class h extends i.BaseWeb3Error {
          constructor() {
            super("Initialization vector must be 16 bytes"),
              (this.code = n.ERR_IV_LENGTH);
          }
        }
        t.IVLengthError = h;
        class f extends i.BaseWeb3Error {
          constructor() {
            super("c > 1000, pbkdf2 is less secure with less iterations"),
              (this.code = n.ERR_PBKDF2_ITERATIONS);
          }
        }
        t.PBKDF2IterationsError = f;
      },
      8286: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.RequestAlreadySentError =
            t.PendingRequestsOnReconnectingError =
            t.MaxAttemptsReachedOnReconnectingError =
            t.ConnectionCloseError =
            t.ConnectionNotOpenError =
            t.ConnectionTimeoutError =
            t.InvalidConnectionError =
            t.ConnectionError =
              void 0);
        const n = r(6901),
          i = r(7646);
        class s extends i.BaseWeb3Error {
          constructor(e, t) {
            super(e),
              (this.code = n.ERR_CONN),
              t && ((this.errorCode = t.code), (this.errorReason = t.reason));
          }
          toJSON() {
            return Object.assign(Object.assign({}, super.toJSON()), {
              errorCode: this.errorCode,
              errorReason: this.errorReason,
            });
          }
        }
        (t.ConnectionError = s),
          (t.InvalidConnectionError = class extends s {
            constructor(e, t) {
              super(`CONNECTION ERROR: Couldn't connect to node ${e}.`, t),
                (this.host = e),
                (this.code = n.ERR_CONN_INVALID);
            }
            toJSON() {
              return Object.assign(Object.assign({}, super.toJSON()), {
                host: this.host,
              });
            }
          }),
          (t.ConnectionTimeoutError = class extends s {
            constructor(e) {
              super(`CONNECTION TIMEOUT: timeout of ${e}ms achieved`),
                (this.duration = e),
                (this.code = n.ERR_CONN_TIMEOUT);
            }
            toJSON() {
              return Object.assign(Object.assign({}, super.toJSON()), {
                duration: this.duration,
              });
            }
          }),
          (t.ConnectionNotOpenError = class extends s {
            constructor(e) {
              super("Connection not open", e),
                (this.code = n.ERR_CONN_NOT_OPEN);
            }
          }),
          (t.ConnectionCloseError = class extends s {
            constructor(e) {
              var t, r;
              super(
                `CONNECTION ERROR: The connection got closed with the close code ${
                  null !== (t = null == e ? void 0 : e.code) && void 0 !== t
                    ? t
                    : ""
                } and the following reason string ${
                  null !== (r = null == e ? void 0 : e.reason) && void 0 !== r
                    ? r
                    : ""
                }`,
                e,
              ),
                (this.code = n.ERR_CONN_CLOSE);
            }
          }),
          (t.MaxAttemptsReachedOnReconnectingError = class extends s {
            constructor(e) {
              super(`Maximum number of reconnect attempts reached! (${e})`),
                (this.code = n.ERR_CONN_MAX_ATTEMPTS);
            }
          }),
          (t.PendingRequestsOnReconnectingError = class extends s {
            constructor() {
              super(
                "CONNECTION ERROR: Provider started to reconnect before the response got received!",
              ),
                (this.code = n.ERR_CONN_PENDING_REQUESTS);
            }
          }),
          (t.RequestAlreadySentError = class extends s {
            constructor(e) {
              super(`Request already sent with following id: ${e}`),
                (this.code = n.ERR_REQ_ALREADY_SENT);
            }
          });
      },
      6161: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ContractTransactionDataAndInputError =
            t.ContractExecutionError =
            t.Eip838ExecutionError =
            t.ContractInstantiationError =
            t.ContractNoFromAddressDefinedError =
            t.ContractNoAddressDefinedError =
            t.ContractMissingDeployDataError =
            t.ContractReservedEventError =
            t.ContractEventDoesNotExistError =
            t.ContractOnceRequiresCallbackError =
            t.ContractMissingABIError =
            t.ResolverMethodMissingError =
            t.Web3ContractError =
              void 0);
        const n = r(6901),
          i = r(7646);
        class s extends i.BaseWeb3Error {
          constructor(e, t) {
            super(e), (this.code = n.ERR_CONTRACT), (this.receipt = t);
          }
        }
        t.Web3ContractError = s;
        class o extends i.BaseWeb3Error {
          constructor(e, t) {
            super(
              `The resolver at ${e} does not implement requested method: "${t}".`,
            ),
              (this.address = e),
              (this.name = t),
              (this.code = n.ERR_CONTRACT_RESOLVER_MISSING);
          }
          toJSON() {
            return Object.assign(Object.assign({}, super.toJSON()), {
              address: this.address,
              name: this.name,
            });
          }
        }
        t.ResolverMethodMissingError = o;
        class a extends i.BaseWeb3Error {
          constructor() {
            super(
              "You must provide the json interface of the contract when instantiating a contract object.",
            ),
              (this.code = n.ERR_CONTRACT_ABI_MISSING);
          }
        }
        t.ContractMissingABIError = a;
        class c extends i.BaseWeb3Error {
          constructor() {
            super("Once requires a callback as the second parameter."),
              (this.code = n.ERR_CONTRACT_REQUIRED_CALLBACK);
          }
        }
        t.ContractOnceRequiresCallbackError = c;
        class d extends i.BaseWeb3Error {
          constructor(e) {
            super(`Event "${e}" doesn't exist in this contract.`),
              (this.eventName = e),
              (this.code = n.ERR_CONTRACT_EVENT_NOT_EXISTS);
          }
          toJSON() {
            return Object.assign(Object.assign({}, super.toJSON()), {
              eventName: this.eventName,
            });
          }
        }
        t.ContractEventDoesNotExistError = d;
        class u extends i.BaseWeb3Error {
          constructor(e) {
            super(`Event "${e}" doesn't exist in this contract.`),
              (this.type = e),
              (this.code = n.ERR_CONTRACT_RESERVED_EVENT);
          }
          toJSON() {
            return Object.assign(Object.assign({}, super.toJSON()), {
              type: this.type,
            });
          }
        }
        t.ContractReservedEventError = u;
        class l extends i.BaseWeb3Error {
          constructor() {
            super(
              'No "data" specified in neither the given options, nor the default options.',
            ),
              (this.code = n.ERR_CONTRACT_MISSING_DEPLOY_DATA);
          }
        }
        t.ContractMissingDeployDataError = l;
        class h extends i.BaseWeb3Error {
          constructor() {
            super(
              "This contract object doesn't have address set yet, please set an address first.",
            ),
              (this.code = n.ERR_CONTRACT_MISSING_ADDRESS);
          }
        }
        t.ContractNoAddressDefinedError = h;
        class f extends i.BaseWeb3Error {
          constructor() {
            super(
              'No "from" address specified in neither the given options, nor the default options.',
            ),
              (this.code = n.ERR_CONTRACT_MISSING_FROM_ADDRESS);
          }
        }
        t.ContractNoFromAddressDefinedError = f;
        class p extends i.BaseWeb3Error {
          constructor() {
            super(...arguments), (this.code = n.ERR_CONTRACT_INSTANTIATION);
          }
        }
        t.ContractInstantiationError = p;
        class m extends s {
          constructor(e) {
            if (
              (super(e.message || "Error"),
              (this.name = ("name" in e && e.name) || this.constructor.name),
              (this.stack = ("stack" in e && e.stack) || void 0),
              (this.code = e.code),
              "object" == typeof e.data)
            ) {
              let t;
              (t = "originalError" in e.data ? e.data.originalError : e.data),
                (this.data = t.data),
                (this.innerError = new m(t));
            } else this.data = e.data;
          }
          setDecodedProperties(e, t, r) {
            (this.errorName = e),
              (this.errorSignature = t),
              (this.errorArgs = r);
          }
          toJSON() {
            let e = Object.assign(Object.assign({}, super.toJSON()), {
              data: this.data,
            });
            return (
              this.errorName &&
                (e = Object.assign(Object.assign({}, e), {
                  errorName: this.errorName,
                  errorSignature: this.errorSignature,
                  errorArgs: this.errorArgs,
                })),
              e
            );
          }
        }
        (t.Eip838ExecutionError = m),
          (t.ContractExecutionError = class extends s {
            constructor(e) {
              super(
                "Error happened while trying to execute a function inside a smart contract",
              ),
                (this.code = n.ERR_CONTRACT_EXECUTION_REVERTED),
                (this.innerError = new m(e));
            }
          });
        class y extends i.InvalidValueError {
          constructor(e) {
            var t, r;
            super(
              `data: ${
                null !== (t = e.data) && void 0 !== t ? t : "undefined"
              }, input: ${
                null !== (r = e.input) && void 0 !== r ? r : "undefined"
              }`,
              'You can\'t have "data" and "input" as properties of a contract at the same time, please use either "data" or "input" instead.',
            ),
              (this.code = n.ERR_CONTRACT_TX_DATA_AND_INPUT);
          }
        }
        t.ContractTransactionDataAndInputError = y;
      },
      1438: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ConfigChainMismatchError = t.ConfigHardforkMismatchError = void 0);
        const n = r(7646),
          i = r(6901);
        class s extends n.BaseWeb3Error {
          constructor(e, t) {
            super(
              `Web3Config hardfork doesnt match in defaultHardfork ${e} and common.hardfork ${t}`,
            ),
              (this.code = i.ERR_CORE_HARDFORK_MISMATCH);
          }
        }
        t.ConfigHardforkMismatchError = s;
        class o extends n.BaseWeb3Error {
          constructor(e, t) {
            super(
              `Web3Config chain doesnt match in defaultHardfork ${e} and common.hardfork ${t}`,
            ),
              (this.code = i.ERR_CORE_HARDFORK_MISMATCH);
          }
        }
        t.ConfigChainMismatchError = o;
      },
      4155: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ENSNetworkNotSyncedError =
            t.ENSUnsupportedNetworkError =
            t.ENSCheckInterfaceSupportError =
              void 0);
        const n = r(6901),
          i = r(7646);
        class s extends i.BaseWeb3Error {
          constructor(e) {
            super(`ENS resolver check interface support error. "${e}"`),
              (this.code = n.ERR_ENS_CHECK_INTERFACE_SUPPORT);
          }
        }
        t.ENSCheckInterfaceSupportError = s;
        class o extends i.BaseWeb3Error {
          constructor(e) {
            super(`ENS is not supported on network ${e}`),
              (this.code = n.ERR_ENS_UNSUPPORTED_NETWORK);
          }
        }
        t.ENSUnsupportedNetworkError = o;
        class a extends i.BaseWeb3Error {
          constructor() {
            super("Network not synced"),
              (this.code = n.ERR_ENS_NETWORK_NOT_SYNCED);
          }
        }
        t.ENSNetworkNotSyncedError = a;
      },
      7896: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ExistingPluginNamespaceError =
            t.AbiError =
            t.OperationAbortError =
            t.OperationTimeoutError =
            t.MethodNotImplementedError =
            t.FormatterError =
            t.InvalidMethodParamsError =
            t.InvalidNumberOfParamsError =
              void 0);
        const n = r(6901),
          i = r(7646);
        class s extends i.BaseWeb3Error {
          constructor(e, t, r) {
            super(
              `Invalid number of parameters for "${r}". Got "${e}" expected "${t}"!`,
            ),
              (this.got = e),
              (this.expected = t),
              (this.method = r),
              (this.code = n.ERR_PARAM);
          }
          toJSON() {
            return Object.assign(Object.assign({}, super.toJSON()), {
              got: this.got,
              expected: this.expected,
              method: this.method,
            });
          }
        }
        t.InvalidNumberOfParamsError = s;
        class o extends i.BaseWeb3Error {
          constructor(e) {
            super(`Invalid parameters passed. "${void 0 !== e ? e : ""}"`),
              (this.hint = e),
              (this.code = n.ERR_INVALID_METHOD_PARAMS);
          }
          toJSON() {
            return Object.assign(Object.assign({}, super.toJSON()), {
              hint: this.hint,
            });
          }
        }
        t.InvalidMethodParamsError = o;
        class a extends i.BaseWeb3Error {
          constructor() {
            super(...arguments), (this.code = n.ERR_FORMATTERS);
          }
        }
        t.FormatterError = a;
        class c extends i.BaseWeb3Error {
          constructor() {
            super("The method you're trying to call is not implemented."),
              (this.code = n.ERR_METHOD_NOT_IMPLEMENTED);
          }
        }
        t.MethodNotImplementedError = c;
        class d extends i.BaseWeb3Error {
          constructor() {
            super(...arguments), (this.code = n.ERR_OPERATION_TIMEOUT);
          }
        }
        t.OperationTimeoutError = d;
        class u extends i.BaseWeb3Error {
          constructor() {
            super(...arguments), (this.code = n.ERR_OPERATION_ABORT);
          }
        }
        t.OperationAbortError = u;
        class l extends i.BaseWeb3Error {
          constructor() {
            super(...arguments), (this.code = n.ERR_ABI_ENCODING);
          }
        }
        t.AbiError = l;
        class h extends i.BaseWeb3Error {
          constructor(e) {
            super(
              `A plugin with the namespace: ${e} has already been registered.`,
            ),
              (this.code = n.ERR_EXISTING_PLUGIN_NAMESPACE);
          }
        }
        t.ExistingPluginNamespaceError = h;
      },
      9894: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Web3WSProviderError =
            t.SubscriptionError =
            t.InvalidClientError =
            t.InvalidProviderError =
            t.ProviderError =
              void 0);
        const n = r(6901),
          i = r(7646);
        class s extends i.BaseWeb3Error {
          constructor() {
            super(...arguments), (this.code = n.ERR_PROVIDER);
          }
        }
        t.ProviderError = s;
        class o extends i.BaseWeb3Error {
          constructor(e) {
            super(`Provider with url "${e}" is not set or invalid`),
              (this.clientUrl = e),
              (this.code = n.ERR_INVALID_PROVIDER);
          }
        }
        t.InvalidProviderError = o;
        class a extends i.BaseWeb3Error {
          constructor(e) {
            super(`Client URL "${e}" is invalid.`),
              (this.code = n.ERR_INVALID_CLIENT);
          }
        }
        t.InvalidClientError = a;
        class c extends i.BaseWeb3Error {
          constructor() {
            super(...arguments), (this.code = n.ERR_SUBSCRIPTION);
          }
        }
        t.SubscriptionError = c;
        class d extends i.BaseWeb3Error {
          constructor() {
            super(...arguments), (this.code = n.ERR_WS_PROVIDER);
          }
        }
        t.Web3WSProviderError = d;
      },
      8402: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.InvalidResponseError = t.ResponseError = void 0);
        const n = r(7646),
          i = r(6901),
          s = (e) =>
            ((e) =>
              !(
                Array.isArray(e) ||
                "2.0" !== e.jsonrpc ||
                !e ||
                (void 0 !== e.result && null !== e.result) ||
                !("error" in e) ||
                ("number" != typeof e.id && "string" != typeof e.id)
              ))(e)
              ? e.error.message
              : "";
        class o extends n.BaseWeb3Error {
          constructor(e, t, r) {
            var n;
            super(
              null != t
                ? t
                : `Returned error: ${
                    Array.isArray(e) ? e.map((e) => s(e)).join(",") : s(e)
                  }`,
            ),
              (this.code = i.ERR_RESPONSE),
              t ||
                (this.data = Array.isArray(e)
                  ? e.map((e) => {
                      var t;
                      return null === (t = e.error) || void 0 === t
                        ? void 0
                        : t.data;
                    })
                  : null === (n = null == e ? void 0 : e.error) || void 0 === n
                  ? void 0
                  : n.data),
              (this.request = r);
          }
          toJSON() {
            return Object.assign(Object.assign({}, super.toJSON()), {
              data: this.data,
              request: this.request,
            });
          }
        }
        (t.ResponseError = o),
          (t.InvalidResponseError = class extends o {
            constructor(e, t) {
              let r;
              super(e, void 0, t),
                (this.code = i.ERR_INVALID_RESPONSE),
                "error" in e
                  ? (r = e.error)
                  : e instanceof Array && (r = e.map((e) => e.error)),
                (this.innerError = r);
            }
          });
      },
      1145: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.RpcErrorMessages = t.genericRpcErrorMessageTemplate = void 0);
        const n = r(6901);
        (t.genericRpcErrorMessageTemplate =
          "An Rpc error has occured with a code of *code*"),
          (t.RpcErrorMessages = {
            [n.ERR_RPC_INVALID_JSON]: {
              message: "Parse error",
              description: "Invalid JSON",
            },
            [n.ERR_RPC_INVALID_REQUEST]: {
              message: "Invalid request",
              description: "JSON is not a valid request object\t",
            },
            [n.ERR_RPC_INVALID_METHOD]: {
              message: "Method not found",
              description: "Method does not exist\t",
            },
            [n.ERR_RPC_INVALID_PARAMS]: {
              message: "Invalid params",
              description: "Invalid method parameters",
            },
            [n.ERR_RPC_INTERNAL_ERROR]: {
              message: "Internal error",
              description: "Internal JSON-RPC error",
            },
            [n.ERR_RPC_INVALID_INPUT]: {
              message: "Invalid input",
              description: "Missing or invalid parameters",
            },
            [n.ERR_RPC_MISSING_RESOURCE]: {
              message: "Resource not found",
              description: "Requested resource not found",
            },
            [n.ERR_RPC_UNAVAILABLE_RESOURCE]: {
              message: "Resource unavailable",
              description: "Requested resource not available",
            },
            [n.ERR_RPC_TRANSACTION_REJECTED]: {
              message: "Transaction rejected",
              description: "Transaction creation failed",
            },
            [n.ERR_RPC_UNSUPPORTED_METHOD]: {
              message: "Method not supported",
              description: "Method is not implemented",
            },
            [n.ERR_RPC_LIMIT_EXCEEDED]: {
              message: "Limit exceeded",
              description: "Request exceeds defined limit",
            },
            [n.ERR_RPC_NOT_SUPPORTED]: {
              message: "JSON-RPC version not supported",
              description: "Version of JSON-RPC protocol is not supported",
            },
            [n.JSONRPC_ERR_REJECTED_REQUEST]: {
              name: "User Rejected Request",
              message: "The user rejected the request.",
            },
            [n.JSONRPC_ERR_UNAUTHORIZED]: {
              name: "Unauthorized",
              message:
                "The requested method and/or account has not been authorized by the user.",
            },
            [n.JSONRPC_ERR_UNSUPPORTED_METHOD]: {
              name: "Unsupported Method",
              message: "The Provider does not support the requested method.",
            },
            [n.JSONRPC_ERR_DISCONNECTED]: {
              name: "Disconnected",
              message: "The Provider is disconnected from all chains.",
            },
            [n.JSONRPC_ERR_CHAIN_DISCONNECTED]: {
              name: "Chain Disconnected",
              message: "The Provider is not connected to the requested chain.",
            },
            "0-999": { name: "", message: "Not used." },
            1e3: {
              name: "Normal Closure",
              message:
                "The connection successfully completed the purpose for which it was created.",
            },
            1001: {
              name: "Going Away",
              message:
                "The endpoint is going away, either because of a server failure or because the browser is navigating away from the page that opened the connection.",
            },
            1002: {
              name: "Protocol error",
              message:
                "The endpoint is terminating the connection due to a protocol error.",
            },
            1003: {
              name: "Unsupported Data",
              message:
                "The connection is being terminated because the endpoint received data of a type it cannot accept. (For example, a text-only endpoint received binary data.)",
            },
            1004: {
              name: "Reserved",
              message: "Reserved. A meaning might be defined in the future.",
            },
            1005: {
              name: "No Status Rcvd",
              message:
                "Reserved. Indicates that no status code was provided even though one was expected.",
            },
            1006: {
              name: "Abnormal Closure",
              message:
                "Reserved. Indicates that a connection was closed abnormally (that is, with no close frame being sent) when a status code is expected.",
            },
            1007: {
              name: "Invalid frame payload data",
              message:
                "The endpoint is terminating the connection because a message was received that contained inconsistent data (e.g., non-UTF-8 data within a text message).",
            },
            1008: {
              name: "Policy Violation",
              message:
                "The endpoint is terminating the connection because it received a message that violates its policy. This is a generic status code, used when codes 1003 and 1009 are not suitable.",
            },
            1009: {
              name: "Message Too Big",
              message:
                "The endpoint is terminating the connection because a data frame was received that is too large.",
            },
            1010: {
              name: "Mandatory Ext.",
              message:
                "The client is terminating the connection because it expected the server to negotiate one or more extension, but the server didn't.",
            },
            1011: {
              name: "Internal Error",
              message:
                "The server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request.",
            },
            1012: {
              name: "Service Restart",
              message:
                "The server is terminating the connection because it is restarting.",
            },
            1013: {
              name: "Try Again Later",
              message:
                "The server is terminating the connection due to a temporary condition, e.g. it is overloaded and is casting off some of its clients.",
            },
            1014: {
              name: "Bad Gateway",
              message:
                "The server was acting as a gateway or proxy and received an invalid response from the upstream server. This is similar to 502 HTTP Status Code.",
            },
            1015: {
              name: "TLS handshake",
              message:
                "Reserved. Indicates that the connection was closed due to a failure to perform a TLS handshake (e.g., the server certificate can't be verified).",
            },
            "1016-2999": {
              name: "",
              message:
                "For definition by future revisions of the WebSocket Protocol specification, and for definition by extension specifications.",
            },
            "3000-3999": {
              name: "",
              message:
                "For use by libraries, frameworks, and applications. These status codes are registered directly with IANA. The interpretation of these codes is undefined by the WebSocket protocol.",
            },
            "4000-4999": {
              name: "",
              message:
                "For private use, and thus can't be registered. Such codes can be used by prior agreements between WebSocket applications. The interpretation of these codes is undefined by the WebSocket protocol.",
            },
          });
      },
      744: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.rpcErrorsMap =
            t.LimitExceededError =
            t.TransactionRejectedError =
            t.VersionNotSupportedError =
            t.ResourcesNotFoundError =
            t.ResourceUnavailableError =
            t.MethodNotSupported =
            t.InvalidInputError =
            t.InternalError =
            t.InvalidParamsError =
            t.MethodNotFoundError =
            t.InvalidRequestError =
            t.ParseError =
            t.EIP1193ProviderRpcError =
            t.RpcError =
              void 0);
        const n = r(7646),
          i = r(6901),
          s = r(1145);
        class o extends n.BaseWeb3Error {
          constructor(e, t) {
            super(
              null != t
                ? t
                : s.genericRpcErrorMessageTemplate.replace(
                    "*code*",
                    e.error.code.toString(),
                  ),
            ),
              (this.code = e.error.code),
              (this.id = e.id),
              (this.jsonrpc = e.jsonrpc),
              (this.jsonRpcError = e.error);
          }
          toJSON() {
            return Object.assign(Object.assign({}, super.toJSON()), {
              error: this.jsonRpcError,
              id: this.id,
              jsonRpc: this.jsonrpc,
            });
          }
        }
        t.RpcError = o;
        class a extends n.BaseWeb3Error {
          constructor(e, t) {
            var r, n, i, o;
            if (e)
              if (
                null === (r = s.RpcErrorMessages[e]) || void 0 === r
                  ? void 0
                  : r.message
              )
                super(s.RpcErrorMessages[e].message);
              else {
                const t = Object.keys(s.RpcErrorMessages).find(
                  (t) =>
                    "string" == typeof t &&
                    e >= parseInt(t.split("-")[0], 10) &&
                    e <= parseInt(t.split("-")[1], 10),
                );
                super(
                  null !==
                    (i =
                      null === (n = s.RpcErrorMessages[null != t ? t : ""]) ||
                      void 0 === n
                        ? void 0
                        : n.message) && void 0 !== i
                    ? i
                    : s.genericRpcErrorMessageTemplate.replace(
                        "*code*",
                        null !== (o = null == e ? void 0 : e.toString()) &&
                          void 0 !== o
                          ? o
                          : '""',
                      ),
                );
              }
            else super();
            (this.code = e), (this.data = t);
          }
        }
        t.EIP1193ProviderRpcError = a;
        class c extends o {
          constructor(e) {
            super(e, s.RpcErrorMessages[i.ERR_RPC_INVALID_JSON].message),
              (this.code = i.ERR_RPC_INVALID_JSON);
          }
        }
        t.ParseError = c;
        class d extends o {
          constructor(e) {
            super(e, s.RpcErrorMessages[i.ERR_RPC_INVALID_REQUEST].message),
              (this.code = i.ERR_RPC_INVALID_REQUEST);
          }
        }
        t.InvalidRequestError = d;
        class u extends o {
          constructor(e) {
            super(e, s.RpcErrorMessages[i.ERR_RPC_INVALID_METHOD].message),
              (this.code = i.ERR_RPC_INVALID_METHOD);
          }
        }
        t.MethodNotFoundError = u;
        class l extends o {
          constructor(e) {
            super(e, s.RpcErrorMessages[i.ERR_RPC_INVALID_PARAMS].message),
              (this.code = i.ERR_RPC_INVALID_PARAMS);
          }
        }
        t.InvalidParamsError = l;
        class h extends o {
          constructor(e) {
            super(e, s.RpcErrorMessages[i.ERR_RPC_INTERNAL_ERROR].message),
              (this.code = i.ERR_RPC_INTERNAL_ERROR);
          }
        }
        t.InternalError = h;
        class f extends o {
          constructor(e) {
            super(e, s.RpcErrorMessages[i.ERR_RPC_INVALID_INPUT].message),
              (this.code = i.ERR_RPC_INVALID_INPUT);
          }
        }
        t.InvalidInputError = f;
        class p extends o {
          constructor(e) {
            super(e, s.RpcErrorMessages[i.ERR_RPC_UNSUPPORTED_METHOD].message),
              (this.code = i.ERR_RPC_UNSUPPORTED_METHOD);
          }
        }
        t.MethodNotSupported = p;
        class m extends o {
          constructor(e) {
            super(
              e,
              s.RpcErrorMessages[i.ERR_RPC_UNAVAILABLE_RESOURCE].message,
            ),
              (this.code = i.ERR_RPC_UNAVAILABLE_RESOURCE);
          }
        }
        t.ResourceUnavailableError = m;
        class y extends o {
          constructor(e) {
            super(e, s.RpcErrorMessages[i.ERR_RPC_MISSING_RESOURCE].message),
              (this.code = i.ERR_RPC_MISSING_RESOURCE);
          }
        }
        t.ResourcesNotFoundError = y;
        class g extends o {
          constructor(e) {
            super(e, s.RpcErrorMessages[i.ERR_RPC_NOT_SUPPORTED].message),
              (this.code = i.ERR_RPC_NOT_SUPPORTED);
          }
        }
        t.VersionNotSupportedError = g;
        class v extends o {
          constructor(e) {
            super(
              e,
              s.RpcErrorMessages[i.ERR_RPC_TRANSACTION_REJECTED].message,
            ),
              (this.code = i.ERR_RPC_TRANSACTION_REJECTED);
          }
        }
        t.TransactionRejectedError = v;
        class b extends o {
          constructor(e) {
            super(e, s.RpcErrorMessages[i.ERR_RPC_LIMIT_EXCEEDED].message),
              (this.code = i.ERR_RPC_LIMIT_EXCEEDED);
          }
        }
        (t.LimitExceededError = b),
          (t.rpcErrorsMap = new Map()),
          t.rpcErrorsMap.set(i.ERR_RPC_INVALID_JSON, { error: c }),
          t.rpcErrorsMap.set(i.ERR_RPC_INVALID_REQUEST, { error: d }),
          t.rpcErrorsMap.set(i.ERR_RPC_INVALID_METHOD, { error: u }),
          t.rpcErrorsMap.set(i.ERR_RPC_INVALID_PARAMS, { error: l }),
          t.rpcErrorsMap.set(i.ERR_RPC_INTERNAL_ERROR, { error: h }),
          t.rpcErrorsMap.set(i.ERR_RPC_INVALID_INPUT, { error: f }),
          t.rpcErrorsMap.set(i.ERR_RPC_UNSUPPORTED_METHOD, { error: p }),
          t.rpcErrorsMap.set(i.ERR_RPC_UNAVAILABLE_RESOURCE, { error: m }),
          t.rpcErrorsMap.set(i.ERR_RPC_TRANSACTION_REJECTED, { error: v }),
          t.rpcErrorsMap.set(i.ERR_RPC_MISSING_RESOURCE, { error: y }),
          t.rpcErrorsMap.set(i.ERR_RPC_NOT_SUPPORTED, { error: g }),
          t.rpcErrorsMap.set(i.ERR_RPC_LIMIT_EXCEEDED, { error: b });
      },
      9030: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SignatureError = void 0);
        const n = r(6901),
          i = r(7646);
        class s extends i.InvalidValueError {
          constructor() {
            super(...arguments), (this.code = n.ERR_SIGNATURE_FAILED);
          }
        }
        t.SignatureError = s;
      },
      2360: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.InvalidPropertiesForTransactionTypeError =
            t.LocalWalletNotAvailableError =
            t.TransactionSigningError =
            t.TransactionReceiptMissingBlockNumberError =
            t.TransactionMissingReceiptOrBlockHashError =
            t.TransactionBlockTimeoutError =
            t.TransactionPollingTimeoutError =
            t.TransactionSendTimeoutError =
            t.TransactionDataAndInputError =
            t.UnsupportedTransactionTypeError =
            t.Eip1559NotSupportedError =
            t.UnableToPopulateNonceError =
            t.InvalidNonceOrChainIdError =
            t.InvalidTransactionObjectError =
            t.UnsupportedFeeMarketError =
            t.Eip1559GasPriceError =
            t.InvalidMaxPriorityFeePerGasOrMaxFeePerGas =
            t.InvalidGasOrGasPrice =
            t.TransactionGasMismatchError =
            t.TransactionGasMismatchInnerError =
            t.MissingGasError =
            t.MissingGasInnerError =
            t.MissingChainOrHardforkError =
            t.CommonOrChainAndHardforkError =
            t.HardforkMismatchError =
            t.ChainMismatchError =
            t.ChainIdMismatchError =
            t.MissingCustomChainIdError =
            t.MissingCustomChainError =
            t.InvalidTransactionCall =
            t.InvalidTransactionWithReceiver =
            t.InvalidTransactionWithSender =
            t.TransactionNotFound =
            t.UndefinedRawTransactionError =
            t.TransactionOutOfGasError =
            t.TransactionRevertedWithoutReasonError =
            t.ContractCodeNotStoredError =
            t.NoContractAddressFoundError =
            t.TransactionRevertWithCustomError =
            t.TransactionRevertInstructionError =
            t.RevertInstructionError =
            t.TransactionError =
              void 0);
        const n = r(6901),
          i = r(7646);
        class s extends i.BaseWeb3Error {
          constructor(e, t) {
            super(e), (this.receipt = t), (this.code = n.ERR_TX);
          }
          toJSON() {
            return Object.assign(Object.assign({}, super.toJSON()), {
              receipt: this.receipt,
            });
          }
        }
        t.TransactionError = s;
        class o extends i.BaseWeb3Error {
          constructor(e, t) {
            super(
              `Your request got reverted with the following reason string: ${e}`,
            ),
              (this.reason = e),
              (this.signature = t),
              (this.code = n.ERR_TX_REVERT_INSTRUCTION);
          }
          toJSON() {
            return Object.assign(Object.assign({}, super.toJSON()), {
              reason: this.reason,
              signature: this.signature,
            });
          }
        }
        t.RevertInstructionError = o;
        class a extends i.BaseWeb3Error {
          constructor(e, t, r, s) {
            super(
              "Transaction has been reverted by the EVM" +
                (void 0 === r
                  ? ""
                  : `:\n ${i.BaseWeb3Error.convertToString(r)}`),
            ),
              (this.reason = e),
              (this.signature = t),
              (this.receipt = r),
              (this.data = s),
              (this.code = n.ERR_TX_REVERT_TRANSACTION);
          }
          toJSON() {
            return Object.assign(Object.assign({}, super.toJSON()), {
              reason: this.reason,
              signature: this.signature,
              receipt: this.receipt,
              data: this.data,
            });
          }
        }
        (t.TransactionRevertInstructionError = a),
          (t.TransactionRevertWithCustomError = class extends a {
            constructor(e, t, r, i, s, o, a) {
              super(e),
                (this.reason = e),
                (this.customErrorName = t),
                (this.customErrorDecodedSignature = r),
                (this.customErrorArguments = i),
                (this.signature = s),
                (this.receipt = o),
                (this.data = a),
                (this.code = n.ERR_TX_REVERT_TRANSACTION_CUSTOM_ERROR);
            }
            toJSON() {
              return Object.assign(Object.assign({}, super.toJSON()), {
                reason: this.reason,
                customErrorName: this.customErrorName,
                customErrorDecodedSignature: this.customErrorDecodedSignature,
                customErrorArguments: this.customErrorArguments,
                signature: this.signature,
                receipt: this.receipt,
                data: this.data,
              });
            }
          }),
          (t.NoContractAddressFoundError = class extends s {
            constructor(e) {
              super(
                "The transaction receipt didn't contain a contract address.",
                e,
              ),
                (this.code = n.ERR_TX_NO_CONTRACT_ADDRESS);
            }
            toJSON() {
              return Object.assign(Object.assign({}, super.toJSON()), {
                receipt: this.receipt,
              });
            }
          }),
          (t.ContractCodeNotStoredError = class extends s {
            constructor(e) {
              super(
                "The contract code couldn't be stored, please check your gas limit.",
                e,
              ),
                (this.code = n.ERR_TX_CONTRACT_NOT_STORED);
            }
          }),
          (t.TransactionRevertedWithoutReasonError = class extends s {
            constructor(e) {
              super(
                "Transaction has been reverted by the EVM" +
                  (void 0 === e
                    ? ""
                    : `:\n ${i.BaseWeb3Error.convertToString(e)}`),
                e,
              ),
                (this.code = n.ERR_TX_REVERT_WITHOUT_REASON);
            }
          }),
          (t.TransactionOutOfGasError = class extends s {
            constructor(e) {
              super(
                `Transaction ran out of gas. Please provide more gas:\n ${JSON.stringify(
                  e,
                  void 0,
                  2,
                )}`,
                e,
              ),
                (this.code = n.ERR_TX_OUT_OF_GAS);
            }
          }),
          (t.UndefinedRawTransactionError = class extends s {
            constructor() {
              super("Raw transaction undefined"),
                (this.code = n.ERR_RAW_TX_UNDEFINED);
            }
          }),
          (t.TransactionNotFound = class extends s {
            constructor() {
              super("Transaction not found"), (this.code = n.ERR_TX_NOT_FOUND);
            }
          });
        class c extends i.InvalidValueError {
          constructor(e) {
            super(e, "invalid transaction with invalid sender"),
              (this.code = n.ERR_TX_INVALID_SENDER);
          }
        }
        t.InvalidTransactionWithSender = c;
        class d extends i.InvalidValueError {
          constructor(e) {
            super(e, "invalid transaction with invalid receiver"),
              (this.code = n.ERR_TX_INVALID_RECEIVER);
          }
        }
        t.InvalidTransactionWithReceiver = d;
        class u extends i.InvalidValueError {
          constructor(e) {
            super(e, "invalid transaction call"),
              (this.code = n.ERR_TX_INVALID_CALL);
          }
        }
        t.InvalidTransactionCall = u;
        class l extends i.InvalidValueError {
          constructor() {
            super(
              "MissingCustomChainError",
              "If tx.common is provided it must have tx.common.customChain",
            ),
              (this.code = n.ERR_TX_MISSING_CUSTOM_CHAIN);
          }
        }
        t.MissingCustomChainError = l;
        class h extends i.InvalidValueError {
          constructor() {
            super(
              "MissingCustomChainIdError",
              "If tx.common is provided it must have tx.common.customChain and tx.common.customChain.chainId",
            ),
              (this.code = n.ERR_TX_MISSING_CUSTOM_CHAIN_ID);
          }
        }
        t.MissingCustomChainIdError = h;
        class f extends i.InvalidValueError {
          constructor(e) {
            super(
              JSON.stringify(e),
              "Chain Id doesnt match in tx.chainId tx.common.customChain.chainId",
            ),
              (this.code = n.ERR_TX_CHAIN_ID_MISMATCH);
          }
        }
        t.ChainIdMismatchError = f;
        class p extends i.InvalidValueError {
          constructor(e) {
            super(
              JSON.stringify(e),
              "Chain doesnt match in tx.chain tx.common.basechain",
            ),
              (this.code = n.ERR_TX_CHAIN_MISMATCH);
          }
        }
        t.ChainMismatchError = p;
        class m extends i.InvalidValueError {
          constructor(e) {
            super(
              JSON.stringify(e),
              "hardfork doesnt match in tx.hardfork tx.common.hardfork",
            ),
              (this.code = n.ERR_TX_HARDFORK_MISMATCH);
          }
        }
        t.HardforkMismatchError = m;
        class y extends i.InvalidValueError {
          constructor() {
            super(
              "CommonOrChainAndHardforkError",
              "Please provide the common object or the chain and hardfork property but not all together.",
            ),
              (this.code = n.ERR_TX_INVALID_CHAIN_INFO);
          }
        }
        t.CommonOrChainAndHardforkError = y;
        class g extends i.InvalidValueError {
          constructor(e) {
            var t, r;
            super(
              "MissingChainOrHardforkError",
              `When specifying chain and hardfork, both values must be defined. Received "chain": ${
                null !== (t = e.chain) && void 0 !== t ? t : "undefined"
              }, "hardfork": ${
                null !== (r = e.hardfork) && void 0 !== r ? r : "undefined"
              }`,
            ),
              (this.code = n.ERR_TX_MISSING_CHAIN_INFO);
          }
        }
        t.MissingChainOrHardforkError = g;
        class v extends i.BaseWeb3Error {
          constructor() {
            super(
              'Missing properties in transaction, either define "gas" and "gasPrice" for type 0 transactions or "gas", "maxPriorityFeePerGas" and "maxFeePerGas" for type 2 transactions',
            ),
              (this.code = n.ERR_TX_MISSING_GAS_INNER_ERROR);
          }
        }
        t.MissingGasInnerError = v;
        class b extends i.InvalidValueError {
          constructor(e) {
            var t, r, i, s;
            super(
              `gas: ${
                null !== (t = e.gas) && void 0 !== t ? t : "undefined"
              }, gasPrice: ${
                null !== (r = e.gasPrice) && void 0 !== r ? r : "undefined"
              }, maxPriorityFeePerGas: ${
                null !== (i = e.maxPriorityFeePerGas) && void 0 !== i
                  ? i
                  : "undefined"
              }, maxFeePerGas: ${
                null !== (s = e.maxFeePerGas) && void 0 !== s ? s : "undefined"
              }`,
              '"gas" is missing',
            ),
              (this.code = n.ERR_TX_MISSING_GAS),
              (this.innerError = new v());
          }
        }
        t.MissingGasError = b;
        class w extends i.BaseWeb3Error {
          constructor() {
            super(
              'Missing properties in transaction, either define "gas" and "gasPrice" for type 0 transactions or "gas", "maxPriorityFeePerGas" and "maxFeePerGas" for type 2 transactions, not both',
            ),
              (this.code = n.ERR_TX_GAS_MISMATCH_INNER_ERROR);
          }
        }
        t.TransactionGasMismatchInnerError = w;
        class E extends i.InvalidValueError {
          constructor(e) {
            var t, r, i, s;
            super(
              `gas: ${
                null !== (t = e.gas) && void 0 !== t ? t : "undefined"
              }, gasPrice: ${
                null !== (r = e.gasPrice) && void 0 !== r ? r : "undefined"
              }, maxPriorityFeePerGas: ${
                null !== (i = e.maxPriorityFeePerGas) && void 0 !== i
                  ? i
                  : "undefined"
              }, maxFeePerGas: ${
                null !== (s = e.maxFeePerGas) && void 0 !== s ? s : "undefined"
              }`,
              "transaction must specify legacy or fee market gas properties, not both",
            ),
              (this.code = n.ERR_TX_GAS_MISMATCH),
              (this.innerError = new w());
          }
        }
        t.TransactionGasMismatchError = E;
        class A extends i.InvalidValueError {
          constructor(e) {
            var t, r;
            super(
              `gas: ${
                null !== (t = e.gas) && void 0 !== t ? t : "undefined"
              }, gasPrice: ${
                null !== (r = e.gasPrice) && void 0 !== r ? r : "undefined"
              }`,
              "Gas or gasPrice is lower than 0",
            ),
              (this.code = n.ERR_TX_INVALID_LEGACY_GAS);
          }
        }
        t.InvalidGasOrGasPrice = A;
        class _ extends i.InvalidValueError {
          constructor(e) {
            var t, r;
            super(
              `maxPriorityFeePerGas: ${
                null !== (t = e.maxPriorityFeePerGas) && void 0 !== t
                  ? t
                  : "undefined"
              }, maxFeePerGas: ${
                null !== (r = e.maxFeePerGas) && void 0 !== r ? r : "undefined"
              }`,
              "maxPriorityFeePerGas or maxFeePerGas is lower than 0",
            ),
              (this.code = n.ERR_TX_INVALID_FEE_MARKET_GAS);
          }
        }
        t.InvalidMaxPriorityFeePerGasOrMaxFeePerGas = _;
        class T extends i.InvalidValueError {
          constructor(e) {
            super(e, "eip-1559 transactions don't support gasPrice"),
              (this.code = n.ERR_TX_INVALID_FEE_MARKET_GAS_PRICE);
          }
        }
        t.Eip1559GasPriceError = T;
        class R extends i.InvalidValueError {
          constructor(e) {
            var t, r;
            super(
              `maxPriorityFeePerGas: ${
                null !== (t = e.maxPriorityFeePerGas) && void 0 !== t
                  ? t
                  : "undefined"
              }, maxFeePerGas: ${
                null !== (r = e.maxFeePerGas) && void 0 !== r ? r : "undefined"
              }`,
              "pre-eip-1559 transaction don't support maxFeePerGas/maxPriorityFeePerGas",
            ),
              (this.code = n.ERR_TX_INVALID_LEGACY_FEE_MARKET);
          }
        }
        t.UnsupportedFeeMarketError = R;
        class I extends i.InvalidValueError {
          constructor(e) {
            super(e, "invalid transaction object"),
              (this.code = n.ERR_TX_INVALID_OBJECT);
          }
        }
        t.InvalidTransactionObjectError = I;
        class S extends i.InvalidValueError {
          constructor(e) {
            var t, r;
            super(
              `nonce: ${
                null !== (t = e.nonce) && void 0 !== t ? t : "undefined"
              }, chainId: ${
                null !== (r = e.chainId) && void 0 !== r ? r : "undefined"
              }`,
              "Nonce or chainId is lower than 0",
            ),
              (this.code = n.ERR_TX_INVALID_NONCE_OR_CHAIN_ID);
          }
        }
        t.InvalidNonceOrChainIdError = S;
        class x extends i.InvalidValueError {
          constructor() {
            super(
              "UnableToPopulateNonceError",
              "unable to populate nonce, no from address available",
            ),
              (this.code = n.ERR_TX_UNABLE_TO_POPULATE_NONCE);
          }
        }
        t.UnableToPopulateNonceError = x;
        class P extends i.InvalidValueError {
          constructor() {
            super(
              "Eip1559NotSupportedError",
              "Network doesn't support eip-1559",
            ),
              (this.code = n.ERR_TX_UNSUPPORTED_EIP_1559);
          }
        }
        t.Eip1559NotSupportedError = P;
        class O extends i.InvalidValueError {
          constructor(e) {
            super(e, "unsupported transaction type"),
              (this.code = n.ERR_TX_UNSUPPORTED_TYPE);
          }
        }
        t.UnsupportedTransactionTypeError = O;
        class C extends i.InvalidValueError {
          constructor(e) {
            var t, r;
            super(
              `data: ${
                null !== (t = e.data) && void 0 !== t ? t : "undefined"
              }, input: ${
                null !== (r = e.input) && void 0 !== r ? r : "undefined"
              }`,
              'You can\'t have "data" and "input" as properties of transactions at the same time, please use either "data" or "input" instead.',
            ),
              (this.code = n.ERR_TX_DATA_AND_INPUT);
          }
        }
        t.TransactionDataAndInputError = C;
        class k extends i.BaseWeb3Error {
          constructor(e) {
            super(
              `The connected Ethereum Node did not respond within ${
                e.numberOfSeconds
              } seconds, please make sure your transaction was properly sent and you are connected to a healthy Node. Be aware that transaction might still be pending or mined!\n\tTransaction Hash: ${
                e.transactionHash
                  ? e.transactionHash.toString()
                  : "not available"
              }`,
            ),
              (this.code = n.ERR_TX_SEND_TIMEOUT);
          }
        }
        function M(e) {
          return `Please make sure your transaction was properly sent and there no pervious pending transaction for the same account. However, be aware that it might still be mined!\n\tTransaction Hash: ${
            e ? e.toString() : "not available"
          }`;
        }
        t.TransactionSendTimeoutError = k;
        class N extends i.BaseWeb3Error {
          constructor(e) {
            super(
              `Transaction was not mined within ${
                e.numberOfSeconds
              } seconds. ${M(e.transactionHash)}`,
            ),
              (this.code = n.ERR_TX_POLLING_TIMEOUT);
          }
        }
        t.TransactionPollingTimeoutError = N;
        class B extends i.BaseWeb3Error {
          constructor(e) {
            super(
              `Transaction started at ${
                e.starterBlockNumber
              } but was not mined within ${e.numberOfBlocks} blocks. ${M(
                e.transactionHash,
              )}`,
            ),
              (this.code = n.ERR_TX_BLOCK_TIMEOUT);
          }
        }
        t.TransactionBlockTimeoutError = B;
        class D extends i.InvalidValueError {
          constructor(e) {
            var t, r;
            super(
              `receipt: ${JSON.stringify(e.receipt)}, blockHash: ${
                null === (t = e.blockHash) || void 0 === t
                  ? void 0
                  : t.toString()
              }, transactionHash: ${
                null === (r = e.transactionHash) || void 0 === r
                  ? void 0
                  : r.toString()
              }`,
              "Receipt missing or blockHash null",
            ),
              (this.code = n.ERR_TX_RECEIPT_MISSING_OR_BLOCKHASH_NULL);
          }
        }
        t.TransactionMissingReceiptOrBlockHashError = D;
        class j extends i.InvalidValueError {
          constructor(e) {
            super(
              `receipt: ${JSON.stringify(e.receipt)}`,
              "Receipt missing block number",
            ),
              (this.code = n.ERR_TX_RECEIPT_MISSING_BLOCK_NUMBER);
          }
        }
        t.TransactionReceiptMissingBlockNumberError = j;
        class L extends i.BaseWeb3Error {
          constructor(e) {
            super(`Invalid signature. "${e}"`), (this.code = n.ERR_TX_SIGNING);
          }
        }
        t.TransactionSigningError = L;
        class U extends i.InvalidValueError {
          constructor() {
            super(
              "LocalWalletNotAvailableError",
              "Attempted to index account in local wallet, but no wallet is available",
            ),
              (this.code = n.ERR_TX_LOCAL_WALLET_NOT_AVAILABLE);
          }
        }
        t.LocalWalletNotAvailableError = U;
        class F extends i.BaseWeb3Error {
          constructor(e, t) {
            const r = [];
            e.forEach((e) => r.push(e.keyword)),
              super(
                `The following properties are invalid for the transaction type ${t}: ${r.join(
                  ", ",
                )}`,
              ),
              (this.code = n.ERR_TX_INVALID_PROPERTIES_FOR_TYPE);
          }
        }
        t.InvalidPropertiesForTransactionTypeError = F;
      },
      9355: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.InvalidTypeAbiInputError =
            t.InvalidBlockError =
            t.InvalidLargeValueError =
            t.InvalidSizeError =
            t.InvalidUnsignedIntegerError =
            t.InvalidBooleanError =
            t.InvalidTypeError =
            t.NibbleWidthError =
            t.HexProcessingError =
            t.InvalidUnitError =
            t.InvalidStringError =
            t.InvalidAddressError =
            t.InvalidNumberError =
            t.InvalidBytesError =
              void 0);
        const n = r(6901),
          i = r(7646);
        class s extends i.InvalidValueError {
          constructor(e) {
            super(e, "can not parse as byte data"),
              (this.code = n.ERR_INVALID_BYTES);
          }
        }
        t.InvalidBytesError = s;
        class o extends i.InvalidValueError {
          constructor(e) {
            super(e, "can not parse as number data"),
              (this.code = n.ERR_INVALID_NUMBER);
          }
        }
        t.InvalidNumberError = o;
        class a extends i.InvalidValueError {
          constructor(e) {
            super(e, "invalid ethereum address"),
              (this.code = n.ERR_INVALID_ADDRESS);
          }
        }
        t.InvalidAddressError = a;
        class c extends i.InvalidValueError {
          constructor(e) {
            super(e, "not a valid string"), (this.code = n.ERR_INVALID_STRING);
          }
        }
        t.InvalidStringError = c;
        class d extends i.InvalidValueError {
          constructor(e) {
            super(e, "invalid unit"), (this.code = n.ERR_INVALID_UNIT);
          }
        }
        t.InvalidUnitError = d;
        class u extends i.InvalidValueError {
          constructor(e) {
            super(e, "can not be converted to hex"),
              (this.code = n.ERR_INVALID_HEX);
          }
        }
        t.HexProcessingError = u;
        class l extends i.InvalidValueError {
          constructor(e) {
            super(e, "value greater than the nibble width"),
              (this.code = n.ERR_INVALID_NIBBLE_WIDTH);
          }
        }
        t.NibbleWidthError = l;
        class h extends i.InvalidValueError {
          constructor(e) {
            super(e, "invalid type, type not supported"),
              (this.code = n.ERR_INVALID_TYPE);
          }
        }
        t.InvalidTypeError = h;
        class f extends i.InvalidValueError {
          constructor(e) {
            super(e, "not a valid boolean."),
              (this.code = n.ERR_INVALID_BOOLEAN);
          }
        }
        t.InvalidBooleanError = f;
        class p extends i.InvalidValueError {
          constructor(e) {
            super(e, "not a valid unsigned integer."),
              (this.code = n.ERR_INVALID_UNSIGNED_INTEGER);
          }
        }
        t.InvalidUnsignedIntegerError = p;
        class m extends i.InvalidValueError {
          constructor(e) {
            super(e, "invalid size given."), (this.code = n.ERR_INVALID_SIZE);
          }
        }
        t.InvalidSizeError = m;
        class y extends i.InvalidValueError {
          constructor(e) {
            super(e, "value is larger than size."),
              (this.code = n.ERR_INVALID_LARGE_VALUE);
          }
        }
        t.InvalidLargeValueError = y;
        class g extends i.InvalidValueError {
          constructor(e) {
            super(e, "invalid string given"), (this.code = n.ERR_INVALID_BLOCK);
          }
        }
        t.InvalidBlockError = g;
        class v extends i.InvalidValueError {
          constructor(e) {
            super(e, "components found but type is not tuple"),
              (this.code = n.ERR_INVALID_TYPE_ABI);
          }
        }
        t.InvalidTypeAbiInputError = v;
      },
      3087: function (e, t, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (e, t, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(t, r);
                  (i &&
                    !("get" in i
                      ? !t.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return t[r];
                      },
                    }),
                    Object.defineProperty(e, n, i);
                }
              : function (e, t, r, n) {
                  void 0 === n && (n = r), (e[n] = t[r]);
                }),
          i =
            (this && this.__exportStar) ||
            function (e, t) {
              for (var r in e)
                "default" === r ||
                  Object.prototype.hasOwnProperty.call(t, r) ||
                  n(t, e, r);
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          i(r(6901), t),
          i(r(7646), t),
          i(r(8572), t),
          i(r(8286), t),
          i(r(6161), t),
          i(r(4155), t),
          i(r(7896), t),
          i(r(9894), t),
          i(r(9030), t),
          i(r(2360), t),
          i(r(9355), t),
          i(r(8402), t),
          i(r(1438), t),
          i(r(744), t),
          i(r(1145), t);
      },
      7646: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.InvalidValueError = t.BaseWeb3Error = void 0);
        class r extends Error {
          constructor(e, t) {
            super(e),
              (this.innerError = t),
              (this.name = this.constructor.name),
              "function" == typeof Error.captureStackTrace
                ? Error.captureStackTrace(new.target.constructor)
                : (this.stack = new Error().stack);
          }
          static convertToString(e, t = !1) {
            if (null == e) return "undefined";
            const r = JSON.stringify(e, (e, t) =>
              "bigint" == typeof t ? t.toString() : t,
            );
            return t && ["bigint", "string"].includes(typeof e)
              ? r.replace(/['\\"]+/g, "")
              : r;
          }
          toJSON() {
            return {
              name: this.name,
              code: this.code,
              message: this.message,
              innerError: this.innerError,
            };
          }
        }
        (t.BaseWeb3Error = r),
          (t.InvalidValueError = class extends r {
            constructor(e, t) {
              super(
                `Invalid value given "${r.convertToString(
                  e,
                  !0,
                )}". Error: ${t}.`,
              ),
                (this.name = this.constructor.name);
            }
          });
      },
      3891: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.encodeErrorSignature = void 0);
        const n = r(9150),
          i = r(3087),
          s = r(8968);
        t.encodeErrorSignature = (e) => {
          if ("string" != typeof e && !(0, s.isAbiErrorFragment)(e))
            throw new i.AbiError(
              "Invalid parameter value in encodeErrorSignature",
            );
          let t;
          return (
            (t =
              !e || ("function" != typeof e && "object" != typeof e)
                ? e
                : (0, s.jsonInterfaceMethodToString)(e)),
            (0, n.sha3Raw)(t)
          );
        };
      },
      3751: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.encodeEventSignature = void 0);
        const n = r(9150),
          i = r(3087),
          s = r(8968);
        t.encodeEventSignature = (e) => {
          if ("string" != typeof e && !(0, s.isAbiEventFragment)(e))
            throw new i.AbiError(
              "Invalid parameter value in encodeEventSignature",
            );
          let t;
          return (
            (t =
              !e || ("function" != typeof e && "object" != typeof e)
                ? e
                : (0, s.jsonInterfaceMethodToString)(e)),
            (0, n.sha3Raw)(t)
          );
        };
      },
      8590: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.encodeFunctionCall = t.encodeFunctionSignature = void 0);
        const n = r(3087),
          i = r(9150),
          s = r(8968),
          o = r(4525);
        (t.encodeFunctionSignature = (e) => {
          if ("string" != typeof e && !(0, s.isAbiFunctionFragment)(e))
            throw new n.AbiError(
              "Invalid parameter value in encodeFunctionSignature",
            );
          let t;
          return (
            (t =
              !e || ("function" != typeof e && "object" != typeof e)
                ? e
                : (0, s.jsonInterfaceMethodToString)(e)),
            (0, i.sha3Raw)(t).slice(0, 10)
          );
        }),
          (t.encodeFunctionCall = (e, r) => {
            var i;
            if (!(0, s.isAbiFunctionFragment)(e))
              throw new n.AbiError(
                "Invalid parameter value in encodeFunctionCall",
              );
            return `${(0, t.encodeFunctionSignature)(e)}${(0,
            o.encodeParameters)(
              null !== (i = e.inputs) && void 0 !== i ? i : [],
              null != r ? r : [],
            ).replace("0x", "")}`;
          });
      },
      7e3: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.decodeLog = void 0);
        const n = r(4525),
          i = ["bool", "string", "int", "uint", "address", "fixed", "ufixed"];
        t.decodeLog = (e, t, r) => {
          const s = Array.isArray(r) ? r : [r],
            o = {},
            a = {};
          for (const [t, r] of e.entries()) r.indexed ? (o[t] = r) : (a[t] = r);
          const c = t
              ? (0, n.decodeParametersWith)(Object.values(a), t, !0)
              : { __length__: 0 },
            d = s.length - Object.keys(o).length,
            u = Object.values(o).map((e, t) => {
              return i.some((t) => e.type.startsWith(t))
                ? ((r = e.type),
                  (o = s[t + d]),
                  "string" === r ? o : (0, n.decodeParameter)(r, o))
                : s[t + d];
              var r, o;
            }),
            l = { __length__: 0 };
          let h = 0,
            f = 0;
          for (const [t, r] of e.entries())
            (l[t] = "string" === r.type ? "" : void 0),
              o[t] && ((l[t] = u[h]), (h += 1)),
              a[t] && ((l[t] = c[String(f)]), (f += 1)),
              r.name && (l[r.name] = l[t]),
              (l.__length__ += 1);
          return l;
        };
      },
      4525: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__importDefault) ||
          function (e) {
            return e && e.__esModule ? e : { default: e };
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.decodeParameter =
            t.decodeParameters =
            t.decodeParametersWith =
            t.encodeParameter =
            t.encodeParameters =
              void 0);
        const i = r(3087),
          s = r(6602),
          o = n(r(4382)),
          a = r(8968);
        (t.encodeParameters = (e, t) => {
          try {
            const r = (0, a.mapTypes)(Array.isArray(e) ? e : [e]),
              n = [];
            for (const [e, i] of t.entries()) {
              const t = r[e];
              let c;
              c = (0, a.isAbiFragment)(t) && t.type ? t.type : t;
              const d = (0, a.formatParam)(c, i);
              if ("string" == typeof c && c.includes("tuple")) {
                const e = o.default._getCoder(s.ParamType.from(c));
                (0, a.modifyParams)(e, [d]);
              }
              n.push(d);
            }
            return o.default.encode(
              r.map((e) => s.ParamType.from(e)),
              n,
            );
          } catch (e) {
            throw new i.AbiError("Parameter encoding error", e);
          }
        }),
          (t.encodeParameter = (e, r) => (0, t.encodeParameters)([e], [r]));
        const c = (e) =>
            Array.isArray(e) &&
            Object.keys(e).filter((e) => Number.isInteger(+e)).length !==
              Object.keys(e).length,
          d = (e) => {
            const t = { __length__: 0 };
            for (const r of Object.keys(e))
              (t[r] = Array.isArray(e[r]) && c(e[r]) ? d(e[r]) : e[r]),
                (t.__length__ += Number.isInteger(+r) ? 1 : 0);
            return t;
          };
        (t.decodeParametersWith = (e, t, r) => {
          try {
            if (e.length > 0 && (!t || "0x" === t || "0X" === t))
              throw new i.AbiError(
                "Returned values aren't valid, did it run Out of Gas? You might also see this error if you are not using the correct ABI for the contract you are retrieving data from, requesting data from a block number that does not exist, or querying a node which is not fully synced.",
              );
            const n = o.default.decode(
              (0, a.mapTypes)(e).map((e) => s.ParamType.from(e)),
              `0x${t.replace(/0x/i, "")}`,
              r,
            );
            return d(n);
          } catch (e) {
            throw new i.AbiError(`Parameter decoding error: ${e.message}`);
          }
        }),
          (t.decodeParameters = (e, r) =>
            (0, t.decodeParametersWith)(e, r, !1)),
          (t.decodeParameter = (e, r) => (0, t.decodeParameters)([e], r)[0]);
      },
      2939: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.decodeContractErrorData = void 0);
        const n = r(3891),
          i = r(4525),
          s = r(8968);
        t.decodeContractErrorData = (e, t) => {
          if (null == t ? void 0 : t.data) {
            let r, o, a;
            try {
              const c = t.data.slice(0, 10),
                d = e.find((e) => (0, n.encodeErrorSignature)(e).startsWith(c));
              (null == d ? void 0 : d.inputs) &&
                ((r = d.name),
                (o = (0, s.jsonInterfaceMethodToString)(d)),
                (a = (0, i.decodeParameters)(
                  [...d.inputs],
                  t.data.substring(10),
                )));
            } catch (e) {
              console.error(e);
            }
            r && t.setDecodedProperties(r, o, a);
          }
        };
      },
      8580: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__importDefault) ||
          function (e) {
            return e && e.__esModule ? e : { default: e };
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getMessage = void 0);
        const i = r(9150),
          s = n(r(4382)),
          o = /^\w+/,
          a = /^(.*)\[([0-9]*?)]$/,
          c = (e, t, r = []) => {
            const n = t.match(o)[0];
            return r.includes(n)
              ? r
              : e.types[n]
              ? [
                  n,
                  ...e.types[n].reduce(
                    (t, r) => [
                      ...t,
                      ...c(e, r.type, t).filter((e) => !t.includes(e)),
                    ],
                    [],
                  ),
                ]
              : r;
          },
          d = (e, t) =>
            (0, i.keccak256)(
              ((e, t) => {
                const [r, ...n] = c(e, t);
                return [r, ...n.sort()]
                  .map(
                    (t) =>
                      `${t}(${e.types[t].map((e) => `${e.type} ${e.name}`)})`,
                  )
                  .join("");
              })(e, t),
            ),
          u = (e, t, r) => (0, i.keccak256)(h(e, t, r));
        t.getMessage = (e, t) => {
          const r = `0x1901${u(e, "EIP712Domain", e.domain).substring(2)}${u(
            e,
            e.primaryType,
            e.message,
          ).substring(2)}`;
          return t ? (0, i.keccak256)(r) : r;
        };
        const l = (e, t, r) => {
            const n = t.match(a);
            if (n) {
              const t = n[1],
                o = Number(n[2]) || void 0;
              if (!Array.isArray(r))
                throw new Error(
                  "Cannot encode data: value is not of array type",
                );
              if (o && r.length !== o)
                throw new Error(
                  `Cannot encode data: expected length of ${o}, but got ${r.length}`,
                );
              const a = r.map((r) => l(e, t, r)),
                c = a.map((e) => e[0]),
                d = a.map((e) => e[1]);
              return ["bytes32", (0, i.keccak256)(s.default.encode(c, d))];
            }
            return e.types[t]
              ? ["bytes32", u(e, t, r)]
              : "string" === t || "bytes" === t
              ? ["bytes32", (0, i.keccak256)(r)]
              : [t, r];
          },
          h = (e, t, r) => {
            const [n, o] = e.types[t].reduce(
              ([t, n], s) => {
                if ((0, i.isNullish)(r[s.name]) || (0, i.isNullish)(r[s.name]))
                  throw new Error(
                    `Cannot encode data: missing data for '${s.name}'`,
                  );
                const o = r[s.name],
                  [a, c] = l(e, s.type, o);
                return [
                  [...t, a],
                  [...n, c],
                ];
              },
              [["bytes32"], [d(e, t)]],
            );
            return s.default.encode(n, o);
          };
      },
      4382: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
        const n = new (r(6602).AbiCoder)((e, t) =>
          (null == t ? void 0 : t._isBigNumber) ? t.toBigInt() : t,
        );
        t.default = n;
      },
      3050: function (e, t, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (e, t, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(t, r);
                  (i &&
                    !("get" in i
                      ? !t.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return t[r];
                      },
                    }),
                    Object.defineProperty(e, n, i);
                }
              : function (e, t, r, n) {
                  void 0 === n && (n = r), (e[n] = t[r]);
                }),
          i =
            (this && this.__exportStar) ||
            function (e, t) {
              for (var r in e)
                "default" === r ||
                  Object.prototype.hasOwnProperty.call(t, r) ||
                  n(t, e, r);
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getEncodedEip712Data = void 0),
          i(r(3891), t),
          i(r(3751), t),
          i(r(8590), t),
          i(r(7e3), t),
          i(r(4525), t),
          i(r(8968), t),
          i(r(2939), t);
        var s = r(8580);
        Object.defineProperty(t, "getEncodedEip712Data", {
          enumerable: !0,
          get: function () {
            return s.getMessage;
          },
        });
      },
      8968: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__importDefault) ||
          function (e) {
            return e && e.__esModule ? e : { default: e };
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.jsonInterfaceMethodToString =
            t.flattenTypes =
            t.modifyParams =
            t.formatParam =
            t.formatOddHexstrings =
            t.isOddHexstring =
            t.mapTypes =
            t.mapStructToCoderFormat =
            t.mapStructNameAndType =
            t.isSimplifiedStructFormat =
            t.isAbiConstructorFragment =
            t.isAbiFunctionFragment =
            t.isAbiEventFragment =
            t.isAbiErrorFragment =
            t.isAbiFragment =
              void 0);
        const i = r(3087),
          s = r(6602),
          o = r(9150),
          a = n(r(4382));
        (t.isAbiFragment = (e) =>
          !(0, o.isNullish)(e) &&
          "object" == typeof e &&
          !(0, o.isNullish)(e.type) &&
          ["function", "event", "constructor", "error"].includes(e.type)),
          (t.isAbiErrorFragment = (e) =>
            !(0, o.isNullish)(e) &&
            "object" == typeof e &&
            !(0, o.isNullish)(e.type) &&
            "error" === e.type),
          (t.isAbiEventFragment = (e) =>
            !(0, o.isNullish)(e) &&
            "object" == typeof e &&
            !(0, o.isNullish)(e.type) &&
            "event" === e.type),
          (t.isAbiFunctionFragment = (e) =>
            !(0, o.isNullish)(e) &&
            "object" == typeof e &&
            !(0, o.isNullish)(e.type) &&
            "function" === e.type),
          (t.isAbiConstructorFragment = (e) =>
            !(0, o.isNullish)(e) &&
            "object" == typeof e &&
            !(0, o.isNullish)(e.type) &&
            "constructor" === e.type),
          (t.isSimplifiedStructFormat = (e) =>
            "object" == typeof e &&
            void 0 === e.components &&
            void 0 === e.name),
          (t.mapStructNameAndType = (e) =>
            e.includes("[]")
              ? { type: "tuple[]", name: e.slice(0, -2) }
              : { type: "tuple", name: e }),
          (t.mapStructToCoderFormat = (e) => {
            const r = [];
            for (const n of Object.keys(e)) {
              const i = e[n];
              "object" == typeof i
                ? r.push(
                    Object.assign(
                      Object.assign({}, (0, t.mapStructNameAndType)(n)),
                      { components: (0, t.mapStructToCoderFormat)(i) },
                    ),
                  )
                : r.push({ name: n, type: e[n] });
            }
            return r;
          }),
          (t.mapTypes = (e) => {
            const r = [];
            for (const n of e) {
              let e = n;
              if (
                ("object" == typeof n && (e = Object.assign({}, n)),
                "object" == typeof n &&
                  "function" === n.type &&
                  (e = Object.assign(Object.assign({}, n), {
                    type: "bytes24",
                  })),
                (0, t.isSimplifiedStructFormat)(e))
              ) {
                const n = Object.keys(e)[0];
                r.push(
                  Object.assign(
                    Object.assign({}, (0, t.mapStructNameAndType)(n)),
                    { components: (0, t.mapStructToCoderFormat)(e[n]) },
                  ),
                );
              } else r.push(e);
            }
            return r;
          }),
          (t.isOddHexstring = (e) =>
            "string" == typeof e &&
            /^(-)?0x[0-9a-f]*$/i.test(e) &&
            e.length % 2 == 1),
          (t.formatOddHexstrings = (e) =>
            (0, t.isOddHexstring)(e) ? `0x0${e.substring(2)}` : e),
          (t.formatParam = (e, r) => {
            var n;
            const i =
              "object" != typeof r || Array.isArray(r)
                ? r
                : Object.assign({}, r);
            if (i instanceof BigInt) return i.toString(10);
            if (
              /^bytes([0-9]*)\[\]$/.exec(e) ||
              /^(u?int)([0-9]*)\[\]$/.exec(e)
            )
              return [...i].map((r) =>
                (0, t.formatParam)(e.replace("[]", ""), r),
              );
            let s = /^(u?int)([0-9]*)$/.exec(e);
            if (s) {
              const e = parseInt(
                null !== (n = s[2]) && void 0 !== n ? n : "256",
                10,
              );
              if (e / 8 < i.length) return (0, o.leftPad)(i, e);
            }
            if (((s = /^bytes([0-9]*)$/.exec(e)), s)) {
              const e = i instanceof Uint8Array ? (0, o.toHex)(i) : i,
                r = parseInt(s[1], 10);
              if (r) {
                let n = 2 * r;
                i.startsWith("0x") && (n += 2);
                const s = e.length < n ? (0, o.rightPad)(i, 2 * r) : e;
                return (0, t.formatOddHexstrings)(s);
              }
              return (0, t.formatOddHexstrings)(e);
            }
            return i;
          }),
          (t.modifyParams = (e, r) =>
            "array" === e.name
              ? r.map((r) =>
                  (0, t.modifyParams)(
                    a.default._getCoder(
                      s.ParamType.from(e.type.replace("[]", "")),
                    ),
                    [r],
                  ),
                )
              : (e.coders.forEach((e, n) => {
                  "tuple" === e.name
                    ? (0, t.modifyParams)(e, [r[n]])
                    : (r[n] = (0, t.formatParam)(e.name, r[n]));
                }),
                [])),
          (t.flattenTypes = (e, r) => {
            const n = [];
            return (
              r.forEach((r) => {
                if ("object" == typeof r.components) {
                  if (!r.type.startsWith("tuple"))
                    throw new i.AbiError(
                      `Invalid value given "${r.type}". Error: components found but type is not tuple.`,
                    );
                  const s = r.type.indexOf("["),
                    o = s >= 0 ? r.type.substring(s) : "",
                    a = (0, t.flattenTypes)(e, r.components);
                  Array.isArray(a) && e
                    ? n.push(`tuple(${a.join(",")})${o}`)
                    : e
                    ? n.push(`(${a.join()})`)
                    : n.push(`(${a.join(",")})${o}`);
                } else n.push(r.type);
              }),
              n
            );
          }),
          (t.jsonInterfaceMethodToString = (e) => {
            var r, n, i, s;
            return (0, t.isAbiErrorFragment)(e) ||
              (0, t.isAbiEventFragment)(e) ||
              (0, t.isAbiFunctionFragment)(e)
              ? (
                  null === (r = e.name) || void 0 === r
                    ? void 0
                    : r.includes("(")
                )
                ? e.name
                : `${null !== (n = e.name) && void 0 !== n ? n : ""}(${(0,
                  t.flattenTypes)(
                    !1,
                    null !== (i = e.inputs) && void 0 !== i ? i : [],
                  ).join(",")})`
              : `(${(0, t.flattenTypes)(
                  !1,
                  null !== (s = e.inputs) && void 0 !== s ? s : [],
                ).join(",")})`;
          });
      },
      2872: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__awaiter) ||
          function (e, t, r, n) {
            return new (r || (r = Promise))(function (i, s) {
              function o(e) {
                try {
                  c(n.next(e));
                } catch (e) {
                  s(e);
                }
              }
              function a(e) {
                try {
                  c(n.throw(e));
                } catch (e) {
                  s(e);
                }
              }
              function c(e) {
                var t;
                e.done
                  ? i(e.value)
                  : ((t = e.value),
                    t instanceof r
                      ? t
                      : new r(function (e) {
                          e(t);
                        })).then(o, a);
              }
              c((n = n.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.decrypt =
            t.create =
            t.privateKeyToAccount =
            t.encrypt =
            t.privateKeyToAddress =
            t.recover =
            t.recoverTransaction =
            t.signTransaction =
            t.sign =
            t.hashMessage =
            t.parseAndValidatePrivateKey =
              void 0);
        const i = r(1465),
          s = r(8791),
          o = r(2535),
          a = r(3087),
          c = r(9150),
          d = r(8840),
          u = r(4457),
          l = r(1782),
          h = r(3494);
        (t.parseAndValidatePrivateKey = (e, t) => {
          let r;
          if (
            !t &&
            "string" == typeof e &&
            (0, d.isHexStrict)(e) &&
            66 !== e.length
          )
            throw new a.PrivateKeyLengthError();
          try {
            r = e instanceof Uint8Array ? e : (0, c.bytesToUint8Array)(e);
          } catch (e) {
            throw new a.InvalidPrivateKeyError();
          }
          if (!t && 32 !== r.byteLength) throw new a.PrivateKeyLengthError();
          return r;
        }),
          (t.hashMessage = (e) => {
            const t = (0, d.isHexStrict)(e) ? e : (0, c.utf8ToHex)(e),
              r = (0, c.hexToBytes)(t),
              n = (0, c.hexToBytes)(
                (0, c.fromUtf8)(`Ethereum Signed Message:\n${r.byteLength}`),
              ),
              i = (0, c.uint8ArrayConcat)(n, r);
            return (0, c.sha3Raw)(i);
          }),
          (t.sign = (e, r) => {
            const n = (0, t.parseAndValidatePrivateKey)(r),
              i = (0, t.hashMessage)(e),
              s = u.secp256k1.sign(i.substring(2), n),
              o = s.toCompactRawBytes(),
              a = s.r.toString(16),
              d = s.s.toString(16),
              l = s.recovery + 27;
            return {
              message: e,
              messageHash: i,
              v: (0, c.numberToHex)(l),
              r: `0x${a}`,
              s: `0x${d}`,
              signature: `${(0, c.bytesToHex)(o)}${l.toString(16)}`,
            };
          }),
          (t.signTransaction = (e, t) =>
            n(void 0, void 0, void 0, function* () {
              const r = e.sign((0, c.hexToBytes)(t));
              if (
                (0, d.isNullish)(r.v) ||
                (0, d.isNullish)(r.r) ||
                (0, d.isNullish)(r.s)
              )
                throw new a.TransactionSigningError("Signer Error");
              const n = r.validate(!0);
              if (n.length > 0) {
                let e = "Signer Error ";
                for (const t of n) e += `${e} ${t}.`;
                throw new a.TransactionSigningError(e);
              }
              const i = (0, c.bytesToHex)(r.serialize()),
                s = (0, c.sha3Raw)(i);
              return {
                messageHash: (0, c.bytesToHex)(r.getMessageToSign(!0)),
                v: `0x${r.v.toString(16)}`,
                r: `0x${r.r.toString(16).padStart(64, "0")}`,
                s: `0x${r.s.toString(16).padStart(64, "0")}`,
                rawTransaction: i,
                transactionHash: (0, c.bytesToHex)(s),
              };
            })),
          (t.recoverTransaction = (e) => {
            if ((0, d.isNullish)(e)) throw new a.UndefinedRawTransactionError();
            const t = h.TransactionFactory.fromSerializedData(
              (0, c.hexToBytes)(e),
            );
            return (0, c.toChecksumAddress)(t.getSenderAddress().toString());
          }),
          (t.recover = (e, r, n, i, s) => {
            if ("object" == typeof e) {
              const r = `${e.r}${e.s.slice(2)}${e.v.slice(2)}`;
              return (0, t.recover)(e.messageHash, r, n);
            }
            if (
              "string" == typeof r &&
              "string" == typeof n &&
              !(0, d.isNullish)(i)
            ) {
              const o = `${n}${i.slice(2)}${r.slice(2)}`;
              return (0, t.recover)(e, o, s);
            }
            if ((0, d.isNullish)(r))
              throw new a.InvalidSignatureError("signature string undefined");
            const o = n ? e : (0, t.hashMessage)(e),
              l = r.substring(130),
              h = u.secp256k1.Signature.fromCompact(r.slice(2, 130))
                .addRecoveryBit(parseInt(l, 16) - 27)
                .recoverPublicKey(o.replace("0x", ""))
                .toRawBytes(!1),
              f = (0, c.sha3Raw)(h.subarray(1));
            return (0, c.toChecksumAddress)(`0x${f.slice(-40)}`);
          }),
          (t.privateKeyToAddress = (e) => {
            const r = (0, t.parseAndValidatePrivateKey)(e),
              n = u.secp256k1.getPublicKey(r, !1),
              i = (0, c.sha3Raw)(n.slice(1)).slice(-40);
            return (0, c.toChecksumAddress)(`0x${i}`);
          }),
          (t.encrypt = (e, r, u) =>
            n(void 0, void 0, void 0, function* () {
              var n, l, h, f, p, m, y;
              const g = (0, t.parseAndValidatePrivateKey)(e);
              let v;
              if (
                ((v = (null == u ? void 0 : u.salt)
                  ? "string" == typeof u.salt
                    ? (0, c.hexToBytes)(u.salt)
                    : u.salt
                  : (0, c.randomBytes)(32)),
                !((0, d.isString)(r) || r instanceof Uint8Array))
              )
                throw new a.InvalidPasswordError();
              const b =
                "string" == typeof r
                  ? (0, c.hexToBytes)((0, c.utf8ToHex)(r))
                  : r;
              let w;
              if (null == u ? void 0 : u.iv) {
                if (
                  ((w =
                    "string" == typeof u.iv ? (0, c.hexToBytes)(u.iv) : u.iv),
                  16 !== w.length)
                )
                  throw new a.IVLengthError();
              } else w = (0, c.randomBytes)(16);
              const E =
                null !== (n = null == u ? void 0 : u.kdf) && void 0 !== n
                  ? n
                  : "scrypt";
              let A, _;
              if ("pbkdf2" === E) {
                if (
                  ((_ = {
                    dklen:
                      null !== (l = null == u ? void 0 : u.dklen) &&
                      void 0 !== l
                        ? l
                        : 32,
                    salt: (0, c.bytesToHex)(v).replace("0x", ""),
                    c:
                      null !== (h = null == u ? void 0 : u.c) && void 0 !== h
                        ? h
                        : 262144,
                    prf: "hmac-sha256",
                  }),
                  _.c < 1e3)
                )
                  throw new a.PBKDF2IterationsError();
                A = (0, s.pbkdf2Sync)(b, v, _.c, _.dklen, "sha256");
              } else {
                if ("scrypt" !== E) throw new a.InvalidKdfError();
                (_ = {
                  n:
                    null !== (f = null == u ? void 0 : u.n) && void 0 !== f
                      ? f
                      : 8192,
                  r:
                    null !== (p = null == u ? void 0 : u.r) && void 0 !== p
                      ? p
                      : 8,
                  p:
                    null !== (m = null == u ? void 0 : u.p) && void 0 !== m
                      ? m
                      : 1,
                  dklen:
                    null !== (y = null == u ? void 0 : u.dklen) && void 0 !== y
                      ? y
                      : 32,
                  salt: (0, c.bytesToHex)(v).replace("0x", ""),
                }),
                  (A = (0, o.scryptSync)(b, v, _.n, _.p, _.r, _.dklen));
              }
              const T = yield (0, i.encrypt)(
                  g,
                  A.slice(0, 16),
                  w,
                  "aes-128-ctr",
                ),
                R = (0, c.bytesToHex)(T).slice(2),
                I = (0, c.sha3Raw)(
                  (0, c.uint8ArrayConcat)(A.slice(16, 32), T),
                ).replace("0x", "");
              return {
                version: 3,
                id: (0, c.uuidV4)(),
                address: (0, t.privateKeyToAddress)(g)
                  .toLowerCase()
                  .replace("0x", ""),
                crypto: {
                  ciphertext: R,
                  cipherparams: { iv: (0, c.bytesToHex)(w).replace("0x", "") },
                  cipher: "aes-128-ctr",
                  kdf: E,
                  kdfparams: _,
                  mac: I,
                },
              };
            })),
          (t.privateKeyToAccount = (e, r) => {
            const i = (0, t.parseAndValidatePrivateKey)(e, r);
            return {
              address: (0, t.privateKeyToAddress)(i),
              privateKey: (0, c.bytesToHex)(i),
              signTransaction: (e) => {
                throw new a.TransactionSigningError(
                  "Do not have network access to sign the transaction",
                );
              },
              sign: (e) =>
                (0, t.sign)("string" == typeof e ? e : JSON.stringify(e), i),
              encrypt: (e, r) =>
                n(void 0, void 0, void 0, function* () {
                  return (0, t.encrypt)(i, e, r);
                }),
            };
          }),
          (t.create = () => {
            const e = u.secp256k1.utils.randomPrivateKey();
            return (0, t.privateKeyToAccount)(`${(0, c.bytesToHex)(e)}`);
          }),
          (t.decrypt = (e, r, u) =>
            n(void 0, void 0, void 0, function* () {
              const n =
                "object" == typeof e ? e : JSON.parse(u ? e.toLowerCase() : e);
              if (
                (d.validator.validateJSONSchema(l.keyStoreSchema, n),
                3 !== n.version)
              )
                throw new a.KeyStoreVersionError();
              const h =
                "string" == typeof r
                  ? (0, c.hexToBytes)((0, c.utf8ToHex)(r))
                  : r;
              let f;
              if (
                (d.validator.validate(["bytes"], [h]),
                "scrypt" === n.crypto.kdf)
              ) {
                const e = n.crypto.kdfparams,
                  t =
                    "string" == typeof e.salt
                      ? (0, c.hexToBytes)(e.salt)
                      : e.salt;
                f = (0, o.scryptSync)(h, t, e.n, e.p, e.r, e.dklen);
              } else {
                if ("pbkdf2" !== n.crypto.kdf) throw new a.InvalidKdfError();
                {
                  const e = n.crypto.kdfparams,
                    t =
                      "string" == typeof e.salt
                        ? (0, c.hexToBytes)(e.salt)
                        : e.salt;
                  f = (0, s.pbkdf2Sync)(h, t, e.c, e.dklen, "sha256");
                }
              }
              const p = (0, c.hexToBytes)(n.crypto.ciphertext);
              if (
                (0, c.sha3Raw)(
                  (0, c.uint8ArrayConcat)(f.slice(16, 32), p),
                ).replace("0x", "") !== n.crypto.mac
              )
                throw new a.KeyDerivationError();
              const m = yield (0, i.decrypt)(
                (0, c.hexToBytes)(n.crypto.ciphertext),
                f.slice(0, 16),
                (0, c.hexToBytes)(n.crypto.cipherparams.iv),
              );
              return (0, t.privateKeyToAccount)(m);
            }));
      },
      3760: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "goerli",
            chainId: 5,
            networkId: 5,
            defaultHardfork: "merge",
            consensus: {
              type: "poa",
              algorithm: "clique",
              clique: { period: 15, epoch: 3e4 },
            },
            comment: "Cross-client PoA test network",
            url: "https://github.com/goerli/testnet",
            genesis: {
              timestamp: "0x5c51a607",
              gasLimit: 10485760,
              difficulty: 1,
              nonce: "0x0000000000000000",
              extraData:
                "0x22466c6578692069732061207468696e6722202d204166726900000000000000e0a2bd4258d2768837baa26a28fe71dc079f84c70000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            },
            hardforks: [
              { name: "chainstart", block: 0, forkHash: "0xa3f5ab08" },
              { name: "homestead", block: 0, forkHash: "0xa3f5ab08" },
              { name: "tangerineWhistle", block: 0, forkHash: "0xa3f5ab08" },
              { name: "spuriousDragon", block: 0, forkHash: "0xa3f5ab08" },
              { name: "byzantium", block: 0, forkHash: "0xa3f5ab08" },
              { name: "constantinople", block: 0, forkHash: "0xa3f5ab08" },
              { name: "petersburg", block: 0, forkHash: "0xa3f5ab08" },
              { name: "istanbul", block: 1561651, forkHash: "0xc25efa5c" },
              { name: "berlin", block: 4460644, forkHash: "0x757a1c47" },
              { name: "london", block: 5062605, forkHash: "0xb8c6299d" },
              {
                "//_comment":
                  "The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://goerli.etherscan.io/block/7382818",
                name: "merge",
                ttd: "10790000",
                block: 7382819,
                forkHash: "0xb8c6299d",
              },
              { name: "mergeForkIdTransition", block: null, forkHash: null },
              { name: "shanghai", block: null, forkHash: null },
            ],
            bootstrapNodes: [],
            dnsNetworks: [
              "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.goerli.ethdisco.net",
            ],
          });
      },
      5760: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "mainnet",
            chainId: 1,
            networkId: 1,
            defaultHardfork: "merge",
            consensus: { type: "pow", algorithm: "ethash", ethash: {} },
            comment: "The Ethereum main chain",
            url: "https://ethstats.net/",
            genesis: {
              gasLimit: 5e3,
              difficulty: 17179869184,
              nonce: "0x0000000000000042",
              extraData:
                "0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa",
            },
            hardforks: [
              { name: "chainstart", block: 0, forkHash: "0xfc64ec04" },
              { name: "homestead", block: 115e4, forkHash: "0x97c2c34c" },
              { name: "dao", block: 192e4, forkHash: "0x91d1f948" },
              {
                name: "tangerineWhistle",
                block: 2463e3,
                forkHash: "0x7a64da13",
              },
              { name: "spuriousDragon", block: 2675e3, forkHash: "0x3edd5b10" },
              { name: "byzantium", block: 437e4, forkHash: "0xa00bc324" },
              { name: "constantinople", block: 728e4, forkHash: "0x668db0af" },
              { name: "petersburg", block: 728e4, forkHash: "0x668db0af" },
              { name: "istanbul", block: 9069e3, forkHash: "0x879d6e30" },
              { name: "muirGlacier", block: 92e5, forkHash: "0xe029e991" },
              { name: "berlin", block: 12244e3, forkHash: "0x0eb440f6" },
              { name: "london", block: 12965e3, forkHash: "0xb715077d" },
              { name: "arrowGlacier", block: 13773e3, forkHash: "0x20c327fc" },
              { name: "grayGlacier", block: 1505e4, forkHash: "0xf0afd0e3" },
              {
                "//_comment":
                  "The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://etherscan.io/block/15537393",
                name: "merge",
                ttd: "58750000000000000000000",
                block: 15537394,
                forkHash: "0xf0afd0e3",
              },
              { name: "mergeForkIdTransition", block: null, forkHash: null },
              { name: "shanghai", block: null, forkHash: null },
            ],
            bootstrapNodes: [],
            dnsNetworks: [
              "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.mainnet.ethdisco.net",
            ],
          });
      },
      7520: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "sepolia",
            chainId: 11155111,
            networkId: 11155111,
            defaultHardfork: "merge",
            consensus: { type: "pow", algorithm: "ethash", ethash: {} },
            comment: "PoW test network to replace Ropsten",
            url: "https://github.com/ethereum/go-ethereum/pull/23730",
            genesis: {
              timestamp: "0x6159af19",
              gasLimit: 3e7,
              difficulty: 131072,
              nonce: "0x0000000000000000",
              extraData:
                "0x5365706f6c69612c20417468656e732c204174746963612c2047726565636521",
            },
            hardforks: [
              { name: "chainstart", block: 0, forkHash: "0xfe3366e7" },
              { name: "homestead", block: 0, forkHash: "0xfe3366e7" },
              { name: "tangerineWhistle", block: 0, forkHash: "0xfe3366e7" },
              { name: "spuriousDragon", block: 0, forkHash: "0xfe3366e7" },
              { name: "byzantium", block: 0, forkHash: "0xfe3366e7" },
              { name: "constantinople", block: 0, forkHash: "0xfe3366e7" },
              { name: "petersburg", block: 0, forkHash: "0xfe3366e7" },
              { name: "istanbul", block: 0, forkHash: "0xfe3366e7" },
              { name: "muirGlacier", block: 0, forkHash: "0xfe3366e7" },
              { name: "berlin", block: 0, forkHash: "0xfe3366e7" },
              { name: "london", block: 0, forkHash: "0xfe3366e7" },
              {
                "//_comment":
                  "The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://sepolia.etherscan.io/block/1450408",
                name: "merge",
                ttd: "17000000000000000",
                block: 1450409,
                forkHash: "0xfe3366e7",
              },
              {
                name: "mergeForkIdTransition",
                block: 1735371,
                forkHash: "0xb96cbd13",
              },
              {
                name: "shanghai",
                block: null,
                timestamp: "1677557088",
                forkHash: "0xf7f9bc08",
              },
            ],
            bootstrapNodes: [],
            dnsNetworks: [
              "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.sepolia.ethdisco.net",
            ],
          });
      },
      9290: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__importDefault) ||
          function (e) {
            return e && e.__esModule ? e : { default: e };
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Common = void 0);
        const i = n(r(4606)),
          s = r(7187),
          o = r(9150),
          a = r(2379),
          c = r(9953),
          d = n(r(3760)),
          u = n(r(5760)),
          l = n(r(7520)),
          h = r(6358),
          f = r(2007),
          p = r(9257),
          { buf: m } = i.default;
        class y extends s.EventEmitter {
          constructor(e) {
            var t, r;
            super(),
              (this._eips = []),
              (this._customChains =
                null !== (t = e.customChains) && void 0 !== t ? t : []),
              (this._chainParams = this.setChain(e.chain)),
              (this.DEFAULT_HARDFORK =
                null !== (r = this._chainParams.defaultHardfork) && void 0 !== r
                  ? r
                  : f.Hardfork.Merge),
              (this.HARDFORK_CHANGES = this.hardforks().map((e) => [
                e.name,
                p.hardforks[e.name],
              ])),
              (this._hardfork = this.DEFAULT_HARDFORK),
              void 0 !== e.hardfork && this.setHardfork(e.hardfork),
              e.eips && this.setEIPs(e.eips);
          }
          static custom(e, t = {}) {
            var r;
            const n =
                null !== (r = t.baseChain) && void 0 !== r ? r : "mainnet",
              i = Object.assign({}, y._getChainParams(n));
            if (((i.name = "custom-chain"), "string" != typeof e))
              return new y(
                Object.assign(
                  { chain: Object.assign(Object.assign({}, i), e) },
                  t,
                ),
              );
            if (e === f.CustomChain.PolygonMainnet)
              return y.custom(
                {
                  name: f.CustomChain.PolygonMainnet,
                  chainId: 137,
                  networkId: 137,
                },
                t,
              );
            if (e === f.CustomChain.PolygonMumbai)
              return y.custom(
                {
                  name: f.CustomChain.PolygonMumbai,
                  chainId: 80001,
                  networkId: 80001,
                },
                t,
              );
            if (e === f.CustomChain.ArbitrumRinkebyTestnet)
              return y.custom(
                {
                  name: f.CustomChain.ArbitrumRinkebyTestnet,
                  chainId: 421611,
                  networkId: 421611,
                },
                t,
              );
            if (e === f.CustomChain.ArbitrumOne)
              return y.custom(
                {
                  name: f.CustomChain.ArbitrumOne,
                  chainId: 42161,
                  networkId: 42161,
                },
                t,
              );
            if (e === f.CustomChain.xDaiChain)
              return y.custom(
                { name: f.CustomChain.xDaiChain, chainId: 100, networkId: 100 },
                t,
              );
            if (e === f.CustomChain.OptimisticKovan)
              return y.custom(
                {
                  name: f.CustomChain.OptimisticKovan,
                  chainId: 69,
                  networkId: 69,
                },
                Object.assign({ hardfork: f.Hardfork.Berlin }, t),
              );
            if (e === f.CustomChain.OptimisticEthereum)
              return y.custom(
                {
                  name: f.CustomChain.OptimisticEthereum,
                  chainId: 10,
                  networkId: 10,
                },
                Object.assign({ hardfork: f.Hardfork.Berlin }, t),
              );
            throw new Error(`Custom chain ${e} not supported`);
          }
          static fromGethGenesis(
            e,
            {
              chain: t,
              eips: r,
              genesisHash: n,
              hardfork: i,
              mergeForkIdPostMerge: s,
            },
          ) {
            var o;
            const a = (0, c.parseGethGenesis)(e, t, s),
              d = new y({
                chain: null !== (o = a.name) && void 0 !== o ? o : "custom",
                customChains: [a],
                eips: r,
                hardfork: null != i ? i : a.hardfork,
              });
            return void 0 !== n && d.setForkHashes(n), d;
          }
          static isSupportedChainId(e) {
            const t = this._getInitializedChains();
            return Boolean(t.names[e.toString()]);
          }
          static _getChainParams(e, t) {
            let r = e;
            const n = this._getInitializedChains(t);
            if ("number" == typeof r || "bigint" == typeof r) {
              if (((r = r.toString()), n.names[r])) return n[n.names[r]];
              throw new Error(`Chain with ID ${r} not supported`);
            }
            if (void 0 !== n[r]) return n[r];
            throw new Error(`Chain with name ${r} not supported`);
          }
          setChain(e) {
            if (
              "number" == typeof e ||
              "bigint" == typeof e ||
              "string" == typeof e
            )
              this._chainParams = y._getChainParams(e, this._customChains);
            else {
              if ("object" != typeof e) throw new Error("Wrong input format");
              {
                if (this._customChains.length > 0)
                  throw new Error(
                    "Chain must be a string, number, or bigint when initialized with customChains passed in",
                  );
                const t = [
                  "networkId",
                  "genesis",
                  "hardforks",
                  "bootstrapNodes",
                ];
                for (const r of t)
                  if (!(r in e))
                    throw new Error(`Missing required chain parameter: ${r}`);
                this._chainParams = e;
              }
            }
            for (const e of this.hardforks())
              if (void 0 === e.block)
                throw new Error("Hardfork cannot have undefined block number");
            return this._chainParams;
          }
          setHardfork(e) {
            let t = !1;
            for (const r of this.HARDFORK_CHANGES)
              r[0] === e &&
                (this._hardfork !== e &&
                  ((this._hardfork = e), this.emit("hardforkChanged", e)),
                (t = !0));
            if (!t) throw new Error(`Hardfork with name ${e} not supported`);
          }
          getHardforkByBlockNumber(e, t, r) {
            const n = (0, c.toType)(e, a.TypeOutput.BigInt),
              i = (0, c.toType)(t, a.TypeOutput.BigInt),
              s = (0, c.toType)(r, a.TypeOutput.Number),
              o = this.hardforks().filter(
                (e) =>
                  null !== e.block ||
                  (null !== e.ttd && void 0 !== e.ttd) ||
                  void 0 !== e.timestamp,
              ),
              d = o.findIndex((e) => null !== e.ttd && void 0 !== e.ttd);
            if (
              o
                .slice(d + 1)
                .findIndex((e) => null !== e.ttd && void 0 !== e.ttd) >= 0
            )
              throw Error(
                "More than one merge hardforks found with ttd specified",
              );
            let u = o.findIndex(
              (e) =>
                (null !== e.block && e.block > n) ||
                (void 0 !== s && Number(e.timestamp) > s),
            );
            if (-1 === u) u = o.length;
            else if (0 === u)
              throw Error("Must have at least one hardfork at block 0");
            if (
              (void 0 === s &&
                (u -= o
                  .slice(0, u)
                  .reverse()
                  .findIndex((e) => null !== e.block || void 0 !== e.ttd)),
              (u -= 1),
              null === o[u].block && void 0 === o[u].timestamp)
            )
              (null == i || BigInt(o[u].ttd) > i) && (u -= 1);
            else if (d >= 0 && null != i) {
              if (u >= d && BigInt(o[d].ttd) > i)
                throw Error(
                  "Maximum HF determined by total difficulty is lower than the block number HF",
                );
              if (u < d && BigInt(o[d].ttd) <= i)
                throw Error(
                  "HF determined by block number is lower than the minimum total difficulty HF",
                );
            }
            const l = u;
            for (
              ;
              u < o.length - 1 &&
              o[u].block === o[u + 1].block &&
              o[u].timestamp === o[u + 1].timestamp;
              u += 1
            );
            if (s) {
              if (
                o.slice(0, l).reduce((e, t) => {
                  var r;
                  return Math.max(
                    Number(
                      null !== (r = t.timestamp) && void 0 !== r ? r : "0",
                    ),
                    e,
                  );
                }, 0) > s
              )
                throw Error(
                  "Maximum HF determined by timestamp is lower than the block number/ttd HF",
                );
              if (
                o.slice(u + 1).reduce((e, t) => {
                  var r;
                  return Math.min(
                    Number(null !== (r = t.timestamp) && void 0 !== r ? r : s),
                    e,
                  );
                }, s) < s
              )
                throw Error(
                  "Maximum HF determined by block number/ttd is lower than timestamp HF",
                );
            }
            return o[u].name;
          }
          setHardforkByBlockNumber(e, t, r) {
            const n = this.getHardforkByBlockNumber(e, t, r);
            return this.setHardfork(n), n;
          }
          _getHardfork(e) {
            const t = this.hardforks();
            for (const r of t) if (r.name === e) return r;
            return null;
          }
          setEIPs(e = []) {
            for (const t of e) {
              if (!(t in h.EIPs)) throw new Error(`${t} not supported`);
              const r = this.gteHardfork(h.EIPs[t].minimumHardfork);
              if (!r)
                throw new Error(
                  `${t} cannot be activated on hardfork ${this.hardfork()}, minimumHardfork: ${r}`,
                );
              if (void 0 !== h.EIPs[t].requiredEIPs)
                for (const r of h.EIPs[t].requiredEIPs)
                  if (!e.includes(r) && !this.isActivatedEIP(r))
                    throw new Error(
                      `${t} requires EIP ${r}, but is not included in the EIP list`,
                    );
            }
            this._eips = e;
          }
          param(e, t) {
            let r;
            for (const n of this._eips)
              if (((r = this.paramByEIP(e, t, n)), void 0 !== r)) return r;
            return this.paramByHardfork(e, t, this._hardfork);
          }
          paramByHardfork(e, t, r) {
            let n = null;
            for (const i of this.HARDFORK_CHANGES) {
              if ("eips" in i[1]) {
                const r = i[1].eips;
                for (const i of r) {
                  const r = this.paramByEIP(e, t, i);
                  n = "bigint" == typeof r ? r : n;
                }
              } else {
                if (void 0 === i[1][e])
                  throw new Error(`Topic ${e} not defined`);
                void 0 !== i[1][e][t] && (n = i[1][e][t].v);
              }
              if (i[0] === r) break;
            }
            return BigInt(null != n ? n : 0);
          }
          paramByEIP(e, t, r) {
            if (!(r in h.EIPs)) throw new Error(`${r} not supported`);
            const n = h.EIPs[r];
            if (!(e in n)) throw new Error(`Topic ${e} not defined`);
            if (void 0 === n[e][t]) return;
            const i = n[e][t].v;
            return BigInt(i);
          }
          paramByBlock(e, t, r, n, i) {
            const s = this.getHardforkByBlockNumber(r, n, i);
            return this.paramByHardfork(e, t, s);
          }
          isActivatedEIP(e) {
            if (this.eips().includes(e)) return !0;
            for (const t of this.HARDFORK_CHANGES) {
              const r = t[1];
              if (this.gteHardfork(r.name) && "eips" in r && r.eips.includes(e))
                return !0;
            }
            return !1;
          }
          hardforkIsActiveOnBlock(e, t) {
            const r = (0, c.toType)(t, a.TypeOutput.BigInt),
              n = null != e ? e : this._hardfork,
              i = this.hardforkBlock(n);
            return "bigint" == typeof i && i !== BigInt(0) && r >= i;
          }
          activeOnBlock(e) {
            return this.hardforkIsActiveOnBlock(null, e);
          }
          hardforkGteHardfork(e, t) {
            const r = null != e ? e : this._hardfork,
              n = this.hardforks();
            let i = -1,
              s = -1,
              o = 0;
            for (const e of n)
              e.name === r && (i = o), e.name === t && (s = o), (o += 1);
            return i >= s && -1 !== s;
          }
          gteHardfork(e) {
            return this.hardforkGteHardfork(null, e);
          }
          hardforkBlock(e) {
            var t;
            const r = null != e ? e : this._hardfork,
              n =
                null === (t = this._getHardfork(r)) || void 0 === t
                  ? void 0
                  : t.block;
            return null == n ? null : BigInt(n);
          }
          hardforkTimestamp(e) {
            var t;
            const r = null != e ? e : this._hardfork,
              n =
                null === (t = this._getHardfork(r)) || void 0 === t
                  ? void 0
                  : t.timestamp;
            return null == n ? null : BigInt(n);
          }
          eipBlock(e) {
            for (const t of this.HARDFORK_CHANGES) {
              const r = t[1];
              if ("eips" in r && r.eips.includes(e))
                return this.hardforkBlock(
                  "number" == typeof t[0] ? String(t[0]) : t[0],
                );
            }
            return null;
          }
          hardforkTTD(e) {
            var t;
            const r = null != e ? e : this._hardfork,
              n =
                null === (t = this._getHardfork(r)) || void 0 === t
                  ? void 0
                  : t.ttd;
            return null == n ? null : BigInt(n);
          }
          isHardforkBlock(e, t) {
            const r = (0, c.toType)(e, a.TypeOutput.BigInt),
              n = null != t ? t : this._hardfork,
              i = this.hardforkBlock(n);
            return "bigint" == typeof i && i !== BigInt(0) && i === r;
          }
          nextHardforkBlockOrTimestamp(e) {
            var t, r;
            const n = null != e ? e : this._hardfork,
              i = this.hardforks();
            let s = i.findIndex((e) => e.name === n);
            if ((n === f.Hardfork.Merge && (s -= 1), s < 0)) return null;
            let o =
              null !== (t = i[s].timestamp) && void 0 !== t ? t : i[s].block;
            o = null != o ? Number(o) : null;
            const a = i.slice(s + 1).find((e) => {
              var t;
              let r = null !== (t = e.timestamp) && void 0 !== t ? t : e.block;
              return (
                (r = null != r ? Number(r) : null),
                e.name !== f.Hardfork.Merge && null != r && r !== o
              );
            });
            if (void 0 === a) return null;
            const c = null !== (r = a.timestamp) && void 0 !== r ? r : a.block;
            return null == c ? null : BigInt(c);
          }
          nextHardforkBlock(e) {
            const t = null != e ? e : this._hardfork;
            let r = this.hardforkBlock(t);
            if (null === r && t === f.Hardfork.Merge) {
              const e = this.hardforks(),
                t = e.findIndex((e) => null !== e.ttd && void 0 !== e.ttd);
              if (t < 0) throw Error("Merge hardfork should have been found");
              r = this.hardforkBlock(e[t - 1].name);
            }
            return null === r
              ? null
              : this.hardforks().reduce((e, t) => {
                  const n = BigInt(
                    null === t.block || (void 0 !== t.ttd && null !== t.ttd)
                      ? 0
                      : t.block,
                  );
                  return n > r && null === e ? n : e;
                }, null);
          }
          isNextHardforkBlock(e, t) {
            const r = (0, c.toType)(e, a.TypeOutput.BigInt),
              n = null != t ? t : this._hardfork,
              i = this.nextHardforkBlock(n);
            return null !== i && i === r;
          }
          _calcForkHash(e, t) {
            let r = new Uint8Array(),
              n = 0;
            for (const t of this.hardforks()) {
              const { block: i, timestamp: s, name: a } = t;
              let c = null != s ? s : i;
              if (
                ((c = null !== c ? Number(c) : null),
                "number" == typeof c &&
                  0 !== c &&
                  c !== n &&
                  a !== f.Hardfork.Merge)
              ) {
                const e = (0, o.hexToBytes)(c.toString(16).padStart(16, "0"));
                (r = (0, o.uint8ArrayConcat)(r, e)), (n = c);
              }
              if (t.name === e) break;
            }
            const i = (0, o.uint8ArrayConcat)(t, r);
            return (0, o.bytesToHex)((0, c.intToUint8Array)(m(i) >>> 0));
          }
          forkHash(e, t) {
            const r = null != e ? e : this._hardfork,
              n = this._getHardfork(r);
            if (
              null === n ||
              (null === (null == n ? void 0 : n.block) &&
                void 0 === (null == n ? void 0 : n.timestamp) &&
                void 0 === (null == n ? void 0 : n.ttd))
            )
              throw new Error(
                "No fork hash calculation possible for future hardfork",
              );
            if (
              null !== (null == n ? void 0 : n.forkHash) &&
              void 0 !== (null == n ? void 0 : n.forkHash)
            )
              return n.forkHash;
            if (!t)
              throw new Error("genesisHash required for forkHash calculation");
            return this._calcForkHash(r, t);
          }
          hardforkForForkHash(e) {
            const t = this.hardforks().filter((t) => t.forkHash === e);
            return t.length >= 1 ? t[t.length - 1] : null;
          }
          setForkHashes(e) {
            var t;
            for (const r of this.hardforks()) {
              const n =
                null !== (t = r.timestamp) && void 0 !== t ? t : r.block;
              (null !== r.forkHash && void 0 !== r.forkHash) ||
                (null == n && void 0 === r.ttd) ||
                (r.forkHash = this.forkHash(r.name, e));
            }
          }
          genesis() {
            return this._chainParams.genesis;
          }
          hardforks() {
            return this._chainParams.hardforks;
          }
          bootstrapNodes() {
            return this._chainParams.bootstrapNodes;
          }
          dnsNetworks() {
            return this._chainParams.dnsNetworks;
          }
          hardfork() {
            return this._hardfork;
          }
          chainId() {
            return BigInt(this._chainParams.chainId);
          }
          chainName() {
            return this._chainParams.name;
          }
          networkId() {
            return BigInt(this._chainParams.networkId);
          }
          eips() {
            return this._eips;
          }
          consensusType() {
            const e = this.hardfork();
            let t;
            for (const r of this.HARDFORK_CHANGES)
              if (
                ("consensus" in r[1] && (t = r[1].consensus.type), r[0] === e)
              )
                break;
            return null != t ? t : this._chainParams.consensus.type;
          }
          consensusAlgorithm() {
            const e = this.hardfork();
            let t;
            for (const r of this.HARDFORK_CHANGES)
              if (
                ("consensus" in r[1] && (t = r[1].consensus.algorithm),
                r[0] === e)
              )
                break;
            return null != t ? t : this._chainParams.consensus.algorithm;
          }
          consensusConfig() {
            var e;
            const t = this.hardfork();
            let r;
            for (const e of this.HARDFORK_CHANGES)
              if (
                ("consensus" in e[1] &&
                  (r = e[1].consensus[e[1].consensus.algorithm]),
                e[0] === t)
              )
                break;
            return null !==
              (e =
                null != r
                  ? r
                  : this._chainParams.consensus[this.consensusAlgorithm()]) &&
              void 0 !== e
              ? e
              : {};
          }
          copy() {
            const e = Object.assign(
              Object.create(Object.getPrototypeOf(this)),
              this,
            );
            return e.removeAllListeners(), e;
          }
          static _getInitializedChains(e) {
            const t = {};
            for (const [e, r] of Object.entries(f.Chain))
              t[r] = e.toLowerCase();
            const r = {
              mainnet: u.default,
              goerli: d.default,
              sepolia: l.default,
            };
            if (e)
              for (const n of e) {
                const { name: e } = n;
                (t[n.chainId.toString()] = e), (r[e] = n);
              }
            return (r.names = t), r;
          }
        }
        t.Common = y;
      },
      1822: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "EIP-1153",
            number: 1153,
            comment: "Transient Storage",
            url: "https://eips.ethereum.org/EIPS/eip-1153",
            status: "Review",
            minimumHardfork: "chainstart",
            requiredEIPs: [],
            gasConfig: {},
            gasPrices: {
              tstore: { v: 100, d: "Base fee of the TSTORE opcode" },
              tload: { v: 100, d: "Base fee of the TLOAD opcode" },
            },
            vm: {},
            pow: {},
          });
      },
      6994: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "EIP-1559",
            number: 1559,
            comment: "Fee market change for ETH 1.0 chain",
            url: "https://eips.ethereum.org/EIPS/eip-1559",
            status: "Final",
            minimumHardfork: "berlin",
            requiredEIPs: [2930],
            gasConfig: {
              baseFeeMaxChangeDenominator: {
                v: 8,
                d: "Maximum base fee change denominator",
              },
              elasticityMultiplier: {
                v: 2,
                d: "Maximum block gas target elasticity",
              },
              initialBaseFee: {
                v: 1e9,
                d: "Initial base fee on first EIP1559 block",
              },
            },
            gasPrices: {},
            vm: {},
            pow: {},
          });
      },
      2252: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "EIP-2315",
            number: 2315,
            comment: "Simple subroutines for the EVM",
            url: "https://eips.ethereum.org/EIPS/eip-2315",
            status: "Draft",
            minimumHardfork: "istanbul",
            gasConfig: {},
            gasPrices: {
              beginsub: { v: 2, d: "Base fee of the BEGINSUB opcode" },
              returnsub: { v: 5, d: "Base fee of the RETURNSUB opcode" },
              jumpsub: { v: 10, d: "Base fee of the JUMPSUB opcode" },
            },
            vm: {},
            pow: {},
          });
      },
      6883: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "EIP-2537",
            number: 2537,
            comment: "BLS12-381 precompiles",
            url: "https://eips.ethereum.org/EIPS/eip-2537",
            status: "Draft",
            minimumHardfork: "chainstart",
            gasConfig: {},
            gasPrices: {
              Bls12381G1AddGas: {
                v: 600,
                d: "Gas cost of a single BLS12-381 G1 addition precompile-call",
              },
              Bls12381G1MulGas: {
                v: 12e3,
                d: "Gas cost of a single BLS12-381 G1 multiplication precompile-call",
              },
              Bls12381G2AddGas: {
                v: 4500,
                d: "Gas cost of a single BLS12-381 G2 addition precompile-call",
              },
              Bls12381G2MulGas: {
                v: 55e3,
                d: "Gas cost of a single BLS12-381 G2 multiplication precompile-call",
              },
              Bls12381PairingBaseGas: {
                v: 115e3,
                d: "Base gas cost of BLS12-381 pairing check",
              },
              Bls12381PairingPerPairGas: {
                v: 23e3,
                d: "Per-pair gas cost of BLS12-381 pairing check",
              },
              Bls12381MapG1Gas: {
                v: 5500,
                d: "Gas cost of BLS12-381 map field element to G1",
              },
              Bls12381MapG2Gas: {
                v: 11e4,
                d: "Gas cost of BLS12-381 map field element to G2",
              },
              Bls12381MultiExpGasDiscount: {
                v: [
                  [1, 1200],
                  [2, 888],
                  [3, 764],
                  [4, 641],
                  [5, 594],
                  [6, 547],
                  [7, 500],
                  [8, 453],
                  [9, 438],
                  [10, 423],
                  [11, 408],
                  [12, 394],
                  [13, 379],
                  [14, 364],
                  [15, 349],
                  [16, 334],
                  [17, 330],
                  [18, 326],
                  [19, 322],
                  [20, 318],
                  [21, 314],
                  [22, 310],
                  [23, 306],
                  [24, 302],
                  [25, 298],
                  [26, 294],
                  [27, 289],
                  [28, 285],
                  [29, 281],
                  [30, 277],
                  [31, 273],
                  [32, 269],
                  [33, 268],
                  [34, 266],
                  [35, 265],
                  [36, 263],
                  [37, 262],
                  [38, 260],
                  [39, 259],
                  [40, 257],
                  [41, 256],
                  [42, 254],
                  [43, 253],
                  [44, 251],
                  [45, 250],
                  [46, 248],
                  [47, 247],
                  [48, 245],
                  [49, 244],
                  [50, 242],
                  [51, 241],
                  [52, 239],
                  [53, 238],
                  [54, 236],
                  [55, 235],
                  [56, 233],
                  [57, 232],
                  [58, 231],
                  [59, 229],
                  [60, 228],
                  [61, 226],
                  [62, 225],
                  [63, 223],
                  [64, 222],
                  [65, 221],
                  [66, 220],
                  [67, 219],
                  [68, 219],
                  [69, 218],
                  [70, 217],
                  [71, 216],
                  [72, 216],
                  [73, 215],
                  [74, 214],
                  [75, 213],
                  [76, 213],
                  [77, 212],
                  [78, 211],
                  [79, 211],
                  [80, 210],
                  [81, 209],
                  [82, 208],
                  [83, 208],
                  [84, 207],
                  [85, 206],
                  [86, 205],
                  [87, 205],
                  [88, 204],
                  [89, 203],
                  [90, 202],
                  [91, 202],
                  [92, 201],
                  [93, 200],
                  [94, 199],
                  [95, 199],
                  [96, 198],
                  [97, 197],
                  [98, 196],
                  [99, 196],
                  [100, 195],
                  [101, 194],
                  [102, 193],
                  [103, 193],
                  [104, 192],
                  [105, 191],
                  [106, 191],
                  [107, 190],
                  [108, 189],
                  [109, 188],
                  [110, 188],
                  [111, 187],
                  [112, 186],
                  [113, 185],
                  [114, 185],
                  [115, 184],
                  [116, 183],
                  [117, 182],
                  [118, 182],
                  [119, 181],
                  [120, 180],
                  [121, 179],
                  [122, 179],
                  [123, 178],
                  [124, 177],
                  [125, 176],
                  [126, 176],
                  [127, 175],
                  [128, 174],
                ],
                d: "Discount gas costs of calls to the MultiExp precompiles with `k` (point, scalar) pair",
              },
            },
            vm: {},
            pow: {},
          });
      },
      8576: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "EIP-2565",
            number: 2565,
            comment: "ModExp gas cost",
            url: "https://eips.ethereum.org/EIPS/eip-2565",
            status: "Final",
            minimumHardfork: "byzantium",
            gasConfig: {},
            gasPrices: {
              modexpGquaddivisor: {
                v: 3,
                d: "Gquaddivisor from modexp precompile for gas calculation",
              },
            },
            vm: {},
            pow: {},
          });
      },
      2190: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "EIP-2718",
            comment: "Typed Transaction Envelope",
            url: "https://eips.ethereum.org/EIPS/eip-2718",
            status: "Final",
            minimumHardfork: "chainstart",
            gasConfig: {},
            gasPrices: {},
            vm: {},
            pow: {},
          });
      },
      8273: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "EIP-2929",
            comment: "Gas cost increases for state access opcodes",
            url: "https://eips.ethereum.org/EIPS/eip-2929",
            status: "Final",
            minimumHardfork: "chainstart",
            gasConfig: {},
            gasPrices: {
              coldsload: {
                v: 2100,
                d: "Gas cost of the first read of storage from a given location (per transaction)",
              },
              coldaccountaccess: {
                v: 2600,
                d: "Gas cost of the first read of a given address (per transaction)",
              },
              warmstorageread: {
                v: 100,
                d: "Gas cost of reading storage locations which have already loaded 'cold'",
              },
              sstoreCleanGasEIP2200: {
                v: 2900,
                d: "Once per SSTORE operation from clean non-zero to something else",
              },
              sstoreNoopGasEIP2200: {
                v: 100,
                d: "Once per SSTORE operation if the value doesn't change",
              },
              sstoreDirtyGasEIP2200: {
                v: 100,
                d: "Once per SSTORE operation if a dirty value is changed",
              },
              sstoreInitRefundEIP2200: {
                v: 19900,
                d: "Once per SSTORE operation for resetting to the original zero value",
              },
              sstoreCleanRefundEIP2200: {
                v: 4900,
                d: "Once per SSTORE operation for resetting to the original non-zero value",
              },
              call: { v: 0, d: "Base fee of the CALL opcode" },
              callcode: { v: 0, d: "Base fee of the CALLCODE opcode" },
              delegatecall: { v: 0, d: "Base fee of the DELEGATECALL opcode" },
              staticcall: { v: 0, d: "Base fee of the STATICCALL opcode" },
              balance: { v: 0, d: "Base fee of the BALANCE opcode" },
              extcodesize: { v: 0, d: "Base fee of the EXTCODESIZE opcode" },
              extcodecopy: { v: 0, d: "Base fee of the EXTCODECOPY opcode" },
              extcodehash: { v: 0, d: "Base fee of the EXTCODEHASH opcode" },
              sload: { v: 0, d: "Base fee of the SLOAD opcode" },
              sstore: { v: 0, d: "Base fee of the SSTORE opcode" },
            },
            vm: {},
            pow: {},
          });
      },
      7600: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "EIP-2930",
            comment: "Optional access lists",
            url: "https://eips.ethereum.org/EIPS/eip-2930",
            status: "Final",
            minimumHardfork: "istanbul",
            requiredEIPs: [2718, 2929],
            gasConfig: {},
            gasPrices: {
              accessListStorageKeyCost: {
                v: 1900,
                d: "Gas cost per storage key in an Access List transaction",
              },
              accessListAddressCost: {
                v: 2400,
                d: "Gas cost per storage key in an Access List transaction",
              },
            },
            vm: {},
            pow: {},
          });
      },
      7668: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "EIP-3198",
            number: 3198,
            comment: "BASEFEE opcode",
            url: "https://eips.ethereum.org/EIPS/eip-3198",
            status: "Final",
            minimumHardfork: "london",
            gasConfig: {},
            gasPrices: {
              basefee: { v: 2, d: "Gas cost of the BASEFEE opcode" },
            },
            vm: {},
            pow: {},
          });
      },
      1503: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "EIP-3529",
            comment: "Reduction in refunds",
            url: "https://eips.ethereum.org/EIPS/eip-3529",
            status: "Final",
            minimumHardfork: "berlin",
            requiredEIPs: [2929],
            gasConfig: {
              maxRefundQuotient: {
                v: 5,
                d: "Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)",
              },
            },
            gasPrices: {
              selfdestructRefund: {
                v: 0,
                d: "Refunded following a selfdestruct operation",
              },
              sstoreClearRefundEIP2200: {
                v: 4800,
                d: "Once per SSTORE operation for clearing an originally existing storage slot",
              },
            },
            vm: {},
            pow: {},
          });
      },
      259: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "EIP-3540",
            number: 3540,
            comment: "EVM Object Format (EOF) v1",
            url: "https://eips.ethereum.org/EIPS/eip-3540",
            status: "Review",
            minimumHardfork: "london",
            requiredEIPs: [3541],
            gasConfig: {},
            gasPrices: {},
            vm: {},
            pow: {},
          });
      },
      1081: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "EIP-3541",
            comment: "Reject new contracts starting with the 0xEF byte",
            url: "https://eips.ethereum.org/EIPS/eip-3541",
            status: "Final",
            minimumHardfork: "berlin",
            requiredEIPs: [],
            gasConfig: {},
            gasPrices: {},
            vm: {},
            pow: {},
          });
      },
      1254: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "EIP-3554",
            comment: "Reduction in refunds",
            url: "Difficulty Bomb Delay to December 1st 2021",
            status: "Final",
            minimumHardfork: "muirGlacier",
            requiredEIPs: [],
            gasConfig: {},
            gasPrices: {},
            vm: {},
            pow: {
              difficultyBombDelay: {
                v: 95e5,
                d: "the amount of blocks to delay the difficulty bomb with",
              },
            },
          });
      },
      5264: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "EIP-3607",
            number: 3607,
            comment: "Reject transactions from senders with deployed code",
            url: "https://eips.ethereum.org/EIPS/eip-3607",
            status: "Final",
            minimumHardfork: "chainstart",
            requiredEIPs: [],
            gasConfig: {},
            gasPrices: {},
            vm: {},
            pow: {},
          });
      },
      1486: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "EIP-3651",
            number: 3198,
            comment: "Warm COINBASE",
            url: "https://eips.ethereum.org/EIPS/eip-3651",
            status: "Review",
            minimumHardfork: "london",
            requiredEIPs: [2929],
            gasConfig: {},
            gasPrices: {},
            vm: {},
            pow: {},
          });
      },
      6377: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "EIP-3670",
            number: 3670,
            comment: "EOF - Code Validation",
            url: "https://eips.ethereum.org/EIPS/eip-3670",
            status: "Review",
            minimumHardfork: "london",
            requiredEIPs: [3540],
            gasConfig: {},
            gasPrices: {},
            vm: {},
            pow: {},
          });
      },
      9797: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "EIP-3675",
            number: 3675,
            comment: "Upgrade consensus to Proof-of-Stake",
            url: "https://eips.ethereum.org/EIPS/eip-3675",
            status: "Final",
            minimumHardfork: "london",
            requiredEIPs: [],
            gasConfig: {},
            gasPrices: {},
            vm: {},
            pow: {},
          });
      },
      2618: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "EIP-3855",
            number: 3855,
            comment: "PUSH0 instruction",
            url: "https://eips.ethereum.org/EIPS/eip-3855",
            status: "Review",
            minimumHardfork: "chainstart",
            requiredEIPs: [],
            gasConfig: {},
            gasPrices: { push0: { v: 2, d: "Base fee of the PUSH0 opcode" } },
            vm: {},
            pow: {},
          });
      },
      4267: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "EIP-3860",
            number: 3860,
            comment: "Limit and meter initcode",
            url: "https://eips.ethereum.org/EIPS/eip-3860",
            status: "Review",
            minimumHardfork: "spuriousDragon",
            requiredEIPs: [],
            gasConfig: {},
            gasPrices: {
              initCodeWordCost: {
                v: 2,
                d: "Gas to pay for each word (32 bytes) of initcode when creating a contract",
              },
            },
            vm: {
              maxInitCodeSize: {
                v: 49152,
                d: "Maximum length of initialization code when creating a contract",
              },
            },
            pow: {},
          });
      },
      5637: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "EIP-4345",
            number: 4345,
            comment: "Difficulty Bomb Delay to June 2022",
            url: "https://eips.ethereum.org/EIPS/eip-4345",
            status: "Final",
            minimumHardfork: "london",
            gasConfig: {},
            gasPrices: {},
            vm: {},
            pow: {
              difficultyBombDelay: {
                v: 107e5,
                d: "the amount of blocks to delay the difficulty bomb with",
              },
            },
          });
      },
      797: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "EIP-4399",
            number: 4399,
            comment: "Supplant DIFFICULTY opcode with PREVRANDAO",
            url: "https://eips.ethereum.org/EIPS/eip-4399",
            status: "Review",
            minimumHardfork: "london",
            requiredEIPs: [],
            gasConfig: {},
            gasPrices: {},
            vm: {},
            pow: {},
          });
      },
      6257: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "EIP-5133",
            number: 5133,
            comment: "Delaying Difficulty Bomb to mid-September 2022",
            url: "https://eips.ethereum.org/EIPS/eip-5133",
            status: "Draft",
            minimumHardfork: "grayGlacier",
            gasConfig: {},
            gasPrices: {},
            vm: {},
            pow: {
              difficultyBombDelay: {
                v: 114e5,
                d: "the amount of blocks to delay the difficulty bomb with",
              },
            },
          });
      },
      6358: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__importDefault) ||
          function (e) {
            return e && e.__esModule ? e : { default: e };
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EIPs = void 0);
        const i = n(r(1822)),
          s = n(r(6994)),
          o = n(r(2252)),
          a = n(r(6883)),
          c = n(r(8576)),
          d = n(r(2190)),
          u = n(r(8273)),
          l = n(r(7600)),
          h = n(r(7668)),
          f = n(r(1503)),
          p = n(r(259)),
          m = n(r(1081)),
          y = n(r(1254)),
          g = n(r(5264)),
          v = n(r(1486)),
          b = n(r(6377)),
          w = n(r(9797)),
          E = n(r(2618)),
          A = n(r(4267)),
          _ = n(r(5637)),
          T = n(r(797)),
          R = n(r(6257));
        t.EIPs = {
          1153: i.default,
          1559: s.default,
          2315: o.default,
          2537: a.default,
          2565: c.default,
          2718: d.default,
          2929: u.default,
          2930: l.default,
          3198: h.default,
          3529: f.default,
          3540: p.default,
          3541: m.default,
          3554: y.default,
          3607: g.default,
          3651: v.default,
          3670: b.default,
          3675: w.default,
          3855: E.default,
          3860: A.default,
          4345: _.default,
          4399: T.default,
          5133: R.default,
        };
      },
      2007: (e, t) => {
        "use strict";
        var r, n, i, s, o;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.CustomChain =
            t.ConsensusAlgorithm =
            t.ConsensusType =
            t.Hardfork =
            t.Chain =
              void 0),
          ((o = t.Chain || (t.Chain = {}))[(o.Mainnet = 1)] = "Mainnet"),
          (o[(o.Goerli = 5)] = "Goerli"),
          (o[(o.Sepolia = 11155111)] = "Sepolia"),
          ((s = t.Hardfork || (t.Hardfork = {})).Chainstart = "chainstart"),
          (s.Homestead = "homestead"),
          (s.Dao = "dao"),
          (s.TangerineWhistle = "tangerineWhistle"),
          (s.SpuriousDragon = "spuriousDragon"),
          (s.Byzantium = "byzantium"),
          (s.Constantinople = "constantinople"),
          (s.Petersburg = "petersburg"),
          (s.Istanbul = "istanbul"),
          (s.MuirGlacier = "muirGlacier"),
          (s.Berlin = "berlin"),
          (s.London = "london"),
          (s.ArrowGlacier = "arrowGlacier"),
          (s.GrayGlacier = "grayGlacier"),
          (s.MergeForkIdTransition = "mergeForkIdTransition"),
          (s.Merge = "merge"),
          (s.Shanghai = "shanghai"),
          (s.ShardingForkDev = "shardingFork"),
          ((i = t.ConsensusType || (t.ConsensusType = {})).ProofOfStake =
            "pos"),
          (i.ProofOfWork = "pow"),
          (i.ProofOfAuthority = "poa"),
          ((n = t.ConsensusAlgorithm || (t.ConsensusAlgorithm = {})).Ethash =
            "ethash"),
          (n.Clique = "clique"),
          (n.Casper = "casper"),
          ((r = t.CustomChain || (t.CustomChain = {})).PolygonMainnet =
            "polygon-mainnet"),
          (r.PolygonMumbai = "polygon-mumbai"),
          (r.ArbitrumRinkebyTestnet = "arbitrum-rinkeby-testnet"),
          (r.ArbitrumOne = "arbitrum-one"),
          (r.xDaiChain = "x-dai-chain"),
          (r.OptimisticKovan = "optimistic-kovan"),
          (r.OptimisticEthereum = "optimistic-ethereum");
      },
      4444: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "arrowGlacier",
            comment: "HF to delay the difficulty bomb",
            url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/arrow-glacier.md",
            status: "Final",
            eips: [4345],
            gasConfig: {},
            gasPrices: {},
            vm: {},
            pow: {},
          });
      },
      7551: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "berlin",
            comment: "HF targeted for July 2020 following the Muir Glacier HF",
            url: "https://eips.ethereum.org/EIPS/eip-2070",
            status: "Final",
            eips: [2565, 2929, 2718, 2930],
          });
      },
      3307: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "byzantium",
            comment:
              "Hardfork with new precompiles, instructions and other protocol changes",
            url: "https://eips.ethereum.org/EIPS/eip-609",
            status: "Final",
            gasConfig: {},
            gasPrices: {
              modexpGquaddivisor: {
                v: 20,
                d: "Gquaddivisor from modexp precompile for gas calculation",
              },
              ecAdd: { v: 500, d: "Gas costs for curve addition precompile" },
              ecMul: {
                v: 4e4,
                d: "Gas costs for curve multiplication precompile",
              },
              ecPairing: {
                v: 1e5,
                d: "Base gas costs for curve pairing precompile",
              },
              ecPairingWord: {
                v: 8e4,
                d: "Gas costs regarding curve pairing precompile input length",
              },
              revert: { v: 0, d: "Base fee of the REVERT opcode" },
              staticcall: { v: 700, d: "Base fee of the STATICCALL opcode" },
              returndatasize: {
                v: 2,
                d: "Base fee of the RETURNDATASIZE opcode",
              },
              returndatacopy: {
                v: 3,
                d: "Base fee of the RETURNDATACOPY opcode",
              },
            },
            vm: {},
            pow: {
              minerReward: {
                v: "3000000000000000000",
                d: "the amount a miner get rewarded for mining a block",
              },
              difficultyBombDelay: {
                v: 3e6,
                d: "the amount of blocks to delay the difficulty bomb with",
              },
            },
          });
      },
      5315: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "chainstart",
            comment: "Start of the Ethereum main chain",
            url: "",
            status: "",
            gasConfig: {
              minGasLimit: { v: 5e3, d: "Minimum the gas limit may ever be" },
              gasLimitBoundDivisor: {
                v: 1024,
                d: "The bound divisor of the gas limit, used in update calculations",
              },
              maxRefundQuotient: {
                v: 2,
                d: "Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)",
              },
            },
            gasPrices: {
              base: {
                v: 2,
                d: "Gas base cost, used e.g. for ChainID opcode (Istanbul)",
              },
              tierStep: {
                v: [0, 2, 3, 5, 8, 10, 20],
                d: "Once per operation, for a selection of them",
              },
              exp: { v: 10, d: "Base fee of the EXP opcode" },
              expByte: {
                v: 10,
                d: "Times ceil(log256(exponent)) for the EXP instruction",
              },
              sha3: { v: 30, d: "Base fee of the SHA3 opcode" },
              sha3Word: {
                v: 6,
                d: "Once per word of the SHA3 operation's data",
              },
              sload: { v: 50, d: "Base fee of the SLOAD opcode" },
              sstoreSet: {
                v: 2e4,
                d: "Once per SSTORE operation if the zeroness changes from zero",
              },
              sstoreReset: {
                v: 5e3,
                d: "Once per SSTORE operation if the zeroness does not change from zero",
              },
              sstoreRefund: {
                v: 15e3,
                d: "Once per SSTORE operation if the zeroness changes to zero",
              },
              jumpdest: { v: 1, d: "Base fee of the JUMPDEST opcode" },
              log: { v: 375, d: "Base fee of the LOG opcode" },
              logData: { v: 8, d: "Per byte in a LOG* operation's data" },
              logTopic: {
                v: 375,
                d: "Multiplied by the * of the LOG*, per LOG transaction. e.g. LOG0 incurs 0 * c_txLogTopicGas, LOG4 incurs 4 * c_txLogTopicGas",
              },
              create: { v: 32e3, d: "Base fee of the CREATE opcode" },
              call: { v: 40, d: "Base fee of the CALL opcode" },
              callStipend: {
                v: 2300,
                d: "Free gas given at beginning of call",
              },
              callValueTransfer: {
                v: 9e3,
                d: "Paid for CALL when the value transfor is non-zero",
              },
              callNewAccount: {
                v: 25e3,
                d: "Paid for CALL when the destination address didn't exist prior",
              },
              selfdestructRefund: {
                v: 24e3,
                d: "Refunded following a selfdestruct operation",
              },
              memory: {
                v: 3,
                d: "Times the address of the (highest referenced byte in memory + 1). NOTE: referencing happens on read, write and in instructions such as RETURN and CALL",
              },
              quadCoeffDiv: {
                v: 512,
                d: "Divisor for the quadratic particle of the memory cost equation",
              },
              createData: { v: 200, d: "" },
              tx: {
                v: 21e3,
                d: "Per transaction. NOTE: Not payable on data of calls between transactions",
              },
              txCreation: {
                v: 32e3,
                d: "The cost of creating a contract via tx",
              },
              txDataZero: {
                v: 4,
                d: "Per byte of data attached to a transaction that equals zero. NOTE: Not payable on data of calls between transactions",
              },
              txDataNonZero: {
                v: 68,
                d: "Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions",
              },
              copy: {
                v: 3,
                d: "Multiplied by the number of 32-byte words that are copied (round up) for any *COPY operation and added",
              },
              ecRecover: { v: 3e3, d: "" },
              sha256: { v: 60, d: "" },
              sha256Word: { v: 12, d: "" },
              ripemd160: { v: 600, d: "" },
              ripemd160Word: { v: 120, d: "" },
              identity: { v: 15, d: "" },
              identityWord: { v: 3, d: "" },
              stop: { v: 0, d: "Base fee of the STOP opcode" },
              add: { v: 3, d: "Base fee of the ADD opcode" },
              mul: { v: 5, d: "Base fee of the MUL opcode" },
              sub: { v: 3, d: "Base fee of the SUB opcode" },
              div: { v: 5, d: "Base fee of the DIV opcode" },
              sdiv: { v: 5, d: "Base fee of the SDIV opcode" },
              mod: { v: 5, d: "Base fee of the MOD opcode" },
              smod: { v: 5, d: "Base fee of the SMOD opcode" },
              addmod: { v: 8, d: "Base fee of the ADDMOD opcode" },
              mulmod: { v: 8, d: "Base fee of the MULMOD opcode" },
              signextend: { v: 5, d: "Base fee of the SIGNEXTEND opcode" },
              lt: { v: 3, d: "Base fee of the LT opcode" },
              gt: { v: 3, d: "Base fee of the GT opcode" },
              slt: { v: 3, d: "Base fee of the SLT opcode" },
              sgt: { v: 3, d: "Base fee of the SGT opcode" },
              eq: { v: 3, d: "Base fee of the EQ opcode" },
              iszero: { v: 3, d: "Base fee of the ISZERO opcode" },
              and: { v: 3, d: "Base fee of the AND opcode" },
              or: { v: 3, d: "Base fee of the OR opcode" },
              xor: { v: 3, d: "Base fee of the XOR opcode" },
              not: { v: 3, d: "Base fee of the NOT opcode" },
              byte: { v: 3, d: "Base fee of the BYTE opcode" },
              address: { v: 2, d: "Base fee of the ADDRESS opcode" },
              balance: { v: 20, d: "Base fee of the BALANCE opcode" },
              origin: { v: 2, d: "Base fee of the ORIGIN opcode" },
              caller: { v: 2, d: "Base fee of the CALLER opcode" },
              callvalue: { v: 2, d: "Base fee of the CALLVALUE opcode" },
              calldataload: { v: 3, d: "Base fee of the CALLDATALOAD opcode" },
              calldatasize: { v: 2, d: "Base fee of the CALLDATASIZE opcode" },
              calldatacopy: { v: 3, d: "Base fee of the CALLDATACOPY opcode" },
              codesize: { v: 2, d: "Base fee of the CODESIZE opcode" },
              codecopy: { v: 3, d: "Base fee of the CODECOPY opcode" },
              gasprice: { v: 2, d: "Base fee of the GASPRICE opcode" },
              extcodesize: { v: 20, d: "Base fee of the EXTCODESIZE opcode" },
              extcodecopy: { v: 20, d: "Base fee of the EXTCODECOPY opcode" },
              blockhash: { v: 20, d: "Base fee of the BLOCKHASH opcode" },
              coinbase: { v: 2, d: "Base fee of the COINBASE opcode" },
              timestamp: { v: 2, d: "Base fee of the TIMESTAMP opcode" },
              number: { v: 2, d: "Base fee of the NUMBER opcode" },
              difficulty: { v: 2, d: "Base fee of the DIFFICULTY opcode" },
              gaslimit: { v: 2, d: "Base fee of the GASLIMIT opcode" },
              pop: { v: 2, d: "Base fee of the POP opcode" },
              mload: { v: 3, d: "Base fee of the MLOAD opcode" },
              mstore: { v: 3, d: "Base fee of the MSTORE opcode" },
              mstore8: { v: 3, d: "Base fee of the MSTORE8 opcode" },
              sstore: { v: 0, d: "Base fee of the SSTORE opcode" },
              jump: { v: 8, d: "Base fee of the JUMP opcode" },
              jumpi: { v: 10, d: "Base fee of the JUMPI opcode" },
              pc: { v: 2, d: "Base fee of the PC opcode" },
              msize: { v: 2, d: "Base fee of the MSIZE opcode" },
              gas: { v: 2, d: "Base fee of the GAS opcode" },
              push: { v: 3, d: "Base fee of the PUSH opcode" },
              dup: { v: 3, d: "Base fee of the DUP opcode" },
              swap: { v: 3, d: "Base fee of the SWAP opcode" },
              callcode: { v: 40, d: "Base fee of the CALLCODE opcode" },
              return: { v: 0, d: "Base fee of the RETURN opcode" },
              invalid: { v: 0, d: "Base fee of the INVALID opcode" },
              selfdestruct: { v: 0, d: "Base fee of the SELFDESTRUCT opcode" },
            },
            vm: {
              stackLimit: { v: 1024, d: "Maximum size of VM stack allowed" },
              callCreateDepth: {
                v: 1024,
                d: "Maximum depth of call/create stack",
              },
              maxExtraDataSize: {
                v: 32,
                d: "Maximum size extra data may be after Genesis",
              },
            },
            pow: {
              minimumDifficulty: {
                v: 131072,
                d: "The minimum that the difficulty may ever be",
              },
              difficultyBoundDivisor: {
                v: 2048,
                d: "The bound divisor of the difficulty, used in the update calculations",
              },
              durationLimit: {
                v: 13,
                d: "The decision boundary on the blocktime duration used to determine whether difficulty should go up or not",
              },
              epochDuration: {
                v: 3e4,
                d: "Duration between proof-of-work epochs",
              },
              timebombPeriod: {
                v: 1e5,
                d: "Exponential difficulty timebomb period",
              },
              minerReward: {
                v: "5000000000000000000",
                d: "the amount a miner get rewarded for mining a block",
              },
              difficultyBombDelay: {
                v: 0,
                d: "the amount of blocks to delay the difficulty bomb with",
              },
            },
          });
      },
      724: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "constantinople",
            comment:
              "Postponed hardfork including EIP-1283 (SSTORE gas metering changes)",
            url: "https://eips.ethereum.org/EIPS/eip-1013",
            status: "Final",
            gasConfig: {},
            gasPrices: {
              netSstoreNoopGas: {
                v: 200,
                d: "Once per SSTORE operation if the value doesn't change",
              },
              netSstoreInitGas: {
                v: 2e4,
                d: "Once per SSTORE operation from clean zero",
              },
              netSstoreCleanGas: {
                v: 5e3,
                d: "Once per SSTORE operation from clean non-zero",
              },
              netSstoreDirtyGas: {
                v: 200,
                d: "Once per SSTORE operation from dirty",
              },
              netSstoreClearRefund: {
                v: 15e3,
                d: "Once per SSTORE operation for clearing an originally existing storage slot",
              },
              netSstoreResetRefund: {
                v: 4800,
                d: "Once per SSTORE operation for resetting to the original non-zero value",
              },
              netSstoreResetClearRefund: {
                v: 19800,
                d: "Once per SSTORE operation for resetting to the original zero value",
              },
              shl: { v: 3, d: "Base fee of the SHL opcode" },
              shr: { v: 3, d: "Base fee of the SHR opcode" },
              sar: { v: 3, d: "Base fee of the SAR opcode" },
              extcodehash: { v: 400, d: "Base fee of the EXTCODEHASH opcode" },
              create2: { v: 32e3, d: "Base fee of the CREATE2 opcode" },
            },
            vm: {},
            pow: {
              minerReward: {
                v: "2000000000000000000",
                d: "The amount a miner gets rewarded for mining a block",
              },
              difficultyBombDelay: {
                v: 5e6,
                d: "the amount of blocks to delay the difficulty bomb with",
              },
            },
          });
      },
      6255: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "dao",
            comment: "DAO rescue hardfork",
            url: "https://eips.ethereum.org/EIPS/eip-779",
            status: "Final",
            gasConfig: {},
            gasPrices: {},
            vm: {},
            pow: {},
          });
      },
      7360: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "grayGlacier",
            comment: "Delaying the difficulty bomb to Mid September 2022",
            url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/gray-glacier.md",
            status: "Draft",
            eips: [5133],
            gasConfig: {},
            gasPrices: {},
            vm: {},
            pow: {},
          });
      },
      5122: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "homestead",
            comment: "Homestead hardfork with protocol and network changes",
            url: "https://eips.ethereum.org/EIPS/eip-606",
            status: "Final",
            gasConfig: {},
            gasPrices: {
              delegatecall: { v: 40, d: "Base fee of the DELEGATECALL opcode" },
            },
            vm: {},
            pow: {},
          });
      },
      9257: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__importDefault) ||
          function (e) {
            return e && e.__esModule ? e : { default: e };
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.hardforks = void 0);
        const i = n(r(5315)),
          s = n(r(6255)),
          o = n(r(5122)),
          a = n(r(4860)),
          c = n(r(9102)),
          d = n(r(3307)),
          u = n(r(724)),
          l = n(r(76)),
          h = n(r(6585)),
          f = n(r(1744)),
          p = n(r(7551)),
          m = n(r(8378)),
          y = n(r(9089)),
          g = n(r(4444)),
          v = n(r(7360)),
          b = n(r(1291)),
          w = n(r(4304));
        t.hardforks = {
          chainstart: i.default,
          homestead: o.default,
          dao: s.default,
          tangerineWhistle: a.default,
          spuriousDragon: c.default,
          byzantium: d.default,
          constantinople: u.default,
          petersburg: l.default,
          istanbul: h.default,
          muirGlacier: f.default,
          berlin: p.default,
          london: m.default,
          shanghai: y.default,
          arrowGlacier: g.default,
          grayGlacier: v.default,
          mergeForkIdTransition: b.default,
          merge: w.default,
        };
      },
      6585: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "istanbul",
            comment:
              "HF targeted for December 2019 following the Constantinople/Petersburg HF",
            url: "https://eips.ethereum.org/EIPS/eip-1679",
            status: "Final",
            gasConfig: {},
            gasPrices: {
              blake2Round: {
                v: 1,
                d: "Gas cost per round for the Blake2 F precompile",
              },
              ecAdd: { v: 150, d: "Gas costs for curve addition precompile" },
              ecMul: {
                v: 6e3,
                d: "Gas costs for curve multiplication precompile",
              },
              ecPairing: {
                v: 45e3,
                d: "Base gas costs for curve pairing precompile",
              },
              ecPairingWord: {
                v: 34e3,
                d: "Gas costs regarding curve pairing precompile input length",
              },
              txDataNonZero: {
                v: 16,
                d: "Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions",
              },
              sstoreSentryGasEIP2200: {
                v: 2300,
                d: "Minimum gas required to be present for an SSTORE call, not consumed",
              },
              sstoreNoopGasEIP2200: {
                v: 800,
                d: "Once per SSTORE operation if the value doesn't change",
              },
              sstoreDirtyGasEIP2200: {
                v: 800,
                d: "Once per SSTORE operation if a dirty value is changed",
              },
              sstoreInitGasEIP2200: {
                v: 2e4,
                d: "Once per SSTORE operation from clean zero to non-zero",
              },
              sstoreInitRefundEIP2200: {
                v: 19200,
                d: "Once per SSTORE operation for resetting to the original zero value",
              },
              sstoreCleanGasEIP2200: {
                v: 5e3,
                d: "Once per SSTORE operation from clean non-zero to something else",
              },
              sstoreCleanRefundEIP2200: {
                v: 4200,
                d: "Once per SSTORE operation for resetting to the original non-zero value",
              },
              sstoreClearRefundEIP2200: {
                v: 15e3,
                d: "Once per SSTORE operation for clearing an originally existing storage slot",
              },
              balance: { v: 700, d: "Base fee of the BALANCE opcode" },
              extcodehash: { v: 700, d: "Base fee of the EXTCODEHASH opcode" },
              chainid: { v: 2, d: "Base fee of the CHAINID opcode" },
              selfbalance: { v: 5, d: "Base fee of the SELFBALANCE opcode" },
              sload: { v: 800, d: "Base fee of the SLOAD opcode" },
            },
            vm: {},
            pow: {},
          });
      },
      8378: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "london",
            comment: "HF targeted for July 2021 following the Berlin fork",
            url: "https://github.com/ethereum/eth1.0-specs/blob/master/network-upgrades/mainnet-upgrades/london.md",
            status: "Final",
            eips: [1559, 3198, 3529, 3541],
          });
      },
      4304: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "merge",
            comment:
              "Hardfork to upgrade the consensus mechanism to Proof-of-Stake",
            url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/merge.md",
            status: "Final",
            consensus: { type: "pos", algorithm: "casper", casper: {} },
            eips: [3675, 4399],
          });
      },
      1291: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "mergeForkIdTransition",
            comment: "Pre-merge hardfork to fork off non-upgraded clients",
            url: "https://eips.ethereum.org/EIPS/eip-3675",
            status: "Draft",
            eips: [],
          });
      },
      1744: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "muirGlacier",
            comment: "HF to delay the difficulty bomb",
            url: "https://eips.ethereum.org/EIPS/eip-2384",
            status: "Final",
            gasConfig: {},
            gasPrices: {},
            vm: {},
            pow: {
              difficultyBombDelay: {
                v: 9e6,
                d: "the amount of blocks to delay the difficulty bomb with",
              },
            },
          });
      },
      76: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "petersburg",
            comment:
              "Aka constantinopleFix, removes EIP-1283, activate together with or after constantinople",
            url: "https://eips.ethereum.org/EIPS/eip-1716",
            status: "Final",
            gasConfig: {},
            gasPrices: {
              netSstoreNoopGas: { v: null, d: "Removed along EIP-1283" },
              netSstoreInitGas: { v: null, d: "Removed along EIP-1283" },
              netSstoreCleanGas: { v: null, d: "Removed along EIP-1283" },
              netSstoreDirtyGas: { v: null, d: "Removed along EIP-1283" },
              netSstoreClearRefund: { v: null, d: "Removed along EIP-1283" },
              netSstoreResetRefund: { v: null, d: "Removed along EIP-1283" },
              netSstoreResetClearRefund: {
                v: null,
                d: "Removed along EIP-1283",
              },
            },
            vm: {},
            pow: {},
          });
      },
      9089: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "shanghai",
            comment:
              "Next feature hardfork after the merge hardfork having withdrawals, warm coinbase, push0, limit/meter initcode",
            url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/shanghai.md",
            status: "Final",
            eips: [3651, 3855, 3860, 4895],
          });
      },
      9102: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "spuriousDragon",
            comment:
              "HF with EIPs for simple replay attack protection, EXP cost increase, state trie clearing, contract code size limit",
            url: "https://eips.ethereum.org/EIPS/eip-607",
            status: "Final",
            gasConfig: {},
            gasPrices: {
              expByte: {
                v: 50,
                d: "Times ceil(log256(exponent)) for the EXP instruction",
              },
            },
            vm: {
              maxCodeSize: { v: 24576, d: "Maximum length of contract code" },
            },
            pow: {},
          });
      },
      4860: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = {
            name: "tangerineWhistle",
            comment: "Hardfork with gas cost changes for IO-heavy operations",
            url: "https://eips.ethereum.org/EIPS/eip-608",
            status: "Final",
            gasConfig: {},
            gasPrices: {
              sload: { v: 200, d: "Once per SLOAD operation" },
              call: {
                v: 700,
                d: "Once per CALL operation & message call transaction",
              },
              extcodesize: { v: 700, d: "Base fee of the EXTCODESIZE opcode" },
              extcodecopy: { v: 700, d: "Base fee of the EXTCODECOPY opcode" },
              balance: { v: 400, d: "Base fee of the BALANCE opcode" },
              delegatecall: {
                v: 700,
                d: "Base fee of the DELEGATECALL opcode",
              },
              callcode: { v: 700, d: "Base fee of the CALLCODE opcode" },
              selfdestruct: {
                v: 5e3,
                d: "Base fee of the SELFDESTRUCT opcode",
              },
            },
            vm: {},
            pow: {},
          });
      },
      7835: function (e, t, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (e, t, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(t, r);
                  (i &&
                    !("get" in i
                      ? !t.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return t[r];
                      },
                    }),
                    Object.defineProperty(e, n, i);
                }
              : function (e, t, r, n) {
                  void 0 === n && (n = r), (e[n] = t[r]);
                }),
          i =
            (this && this.__exportStar) ||
            function (e, t) {
              for (var r in e)
                "default" === r ||
                  Object.prototype.hasOwnProperty.call(t, r) ||
                  n(t, e, r);
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          i(r(9290), t),
          i(r(2007), t),
          i(r(2379), t),
          i(r(9953), t);
      },
      2379: (e, t) => {
        "use strict";
        var r;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.TypeOutput = void 0),
          ((r = t.TypeOutput || (t.TypeOutput = {}))[(r.Number = 0)] =
            "Number"),
          (r[(r.BigInt = 1)] = "BigInt"),
          (r[(r.Uint8Array = 2)] = "Uint8Array"),
          (r[(r.PrefixedHexString = 3)] = "PrefixedHexString");
      },
      9953: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.toType =
            t.ecrecover =
            t.bigIntToUnpaddedUint8Array =
            t.bigIntToHex =
            t.unpadUint8Array =
            t.stripZeros =
            t.setLengthLeft =
            t.assertIsUint8Array =
            t.zeros =
            t.bigIntToUint8Array =
            t.uint8ArrayToBigInt =
            t.toUint8Array =
            t.intToUint8Array =
            t.padToEven =
            t.parseGethGenesis =
            t.stripHexPrefix =
              void 0);
        const n = r(8840),
          i = r(9150),
          s = r(4457),
          o = r(2007),
          a = r(2379);
        t.stripHexPrefix = (e) => {
          if ("string" != typeof e)
            throw new Error(
              "[stripHexPrefix] input must be type 'string', received " +
                typeof e,
            );
          return (0, n.isHexPrefixed)(e) ? e.slice(2) : e;
        };
        const c = function (e) {
          if (!Number.isSafeInteger(e) || e < 0)
            throw new Error(`Received an invalid integer type: ${e}`);
          return `0x${e.toString(16)}`;
        };
        function d(e) {
          let t = e;
          if ("string" != typeof t)
            throw new Error(
              "[padToEven] value must be type 'string', received " + typeof t,
            );
          return t.length % 2 && (t = `0${t}`), t;
        }
        function u(e) {
          const t = (0, i.bytesToHex)(e);
          return "0x" === t ? BigInt(0) : BigInt(t);
        }
        function l(e) {
          return (0, t.toUint8Array)(`0x${e.toString(16)}`);
        }
        function h(e) {
          if (!(e instanceof Uint8Array))
            throw new Error(
              `This method only supports Uint8Array but input was: ${e}`,
            );
        }
        function f(e) {
          let t = e[0];
          for (; e.length > 0 && "0" === t.toString(); )
            t = (e = e.slice(1))[0];
          return e;
        }
        (t.parseGethGenesis = function (e, r, i) {
          try {
            if (
              ["config", "difficulty", "gasLimit", "alloc"].some(
                (t) => !(t in e),
              )
            )
              throw new Error(
                "Invalid format, expected geth genesis fields missing",
              );
            return (
              void 0 !== r && (e.name = r),
              (function (e, r = !0) {
                var i, s;
                const {
                  name: a,
                  config: d,
                  difficulty: u,
                  mixHash: l,
                  gasLimit: h,
                  coinbase: f,
                  baseFeePerGas: p,
                } = e;
                let { extraData: m, timestamp: y, nonce: g } = e;
                const v = Number(y),
                  { chainId: b } = d;
                if (
                  ("" === m && (m = "0x"),
                  (0, n.isHexPrefixed)(y) || (y = c(parseInt(y))),
                  18 !== g.length &&
                    (g = (function (e) {
                      return e && "0x0" !== e
                        ? (0, n.isHexPrefixed)(e)
                          ? `0x${(0, t.stripHexPrefix)(e).padStart(16, "0")}`
                          : `0x${e.padStart(16, "0")}`
                        : "0x0000000000000000";
                    })(g)),
                  d.eip155Block !== d.eip158Block)
                )
                  throw new Error(
                    "EIP155 block number must equal EIP 158 block number since both are part of SpuriousDragon hardfork and the client only supports activating the full hardfork",
                  );
                const w = {
                    name: a,
                    chainId: b,
                    networkId: b,
                    genesis: {
                      timestamp: y,
                      gasLimit: parseInt(h),
                      difficulty: parseInt(u),
                      nonce: g,
                      extraData: m,
                      mixHash: l,
                      coinbase: f,
                      baseFeePerGas: p,
                    },
                    hardfork: void 0,
                    hardforks: [],
                    bootstrapNodes: [],
                    consensus:
                      void 0 !== d.clique
                        ? {
                            type: "poa",
                            algorithm: "clique",
                            clique: {
                              period:
                                null !== (i = d.clique.period) && void 0 !== i
                                  ? i
                                  : d.clique.blockperiodseconds,
                              epoch:
                                null !== (s = d.clique.epoch) && void 0 !== s
                                  ? s
                                  : d.clique.epochlength,
                            },
                          }
                        : { type: "pow", algorithm: "ethash", ethash: {} },
                  },
                  E = {
                    [o.Hardfork.Homestead]: { name: "homesteadBlock" },
                    [o.Hardfork.Dao]: { name: "daoForkBlock" },
                    [o.Hardfork.TangerineWhistle]: { name: "eip150Block" },
                    [o.Hardfork.SpuriousDragon]: { name: "eip155Block" },
                    [o.Hardfork.Byzantium]: { name: "byzantiumBlock" },
                    [o.Hardfork.Constantinople]: {
                      name: "constantinopleBlock",
                    },
                    [o.Hardfork.Petersburg]: { name: "petersburgBlock" },
                    [o.Hardfork.Istanbul]: { name: "istanbulBlock" },
                    [o.Hardfork.MuirGlacier]: { name: "muirGlacierBlock" },
                    [o.Hardfork.Berlin]: { name: "berlinBlock" },
                    [o.Hardfork.London]: { name: "londonBlock" },
                    [o.Hardfork.MergeForkIdTransition]: {
                      name: "mergeForkBlock",
                      postMerge: r,
                    },
                    [o.Hardfork.Shanghai]: {
                      name: "shanghaiTime",
                      postMerge: !0,
                      isTimestamp: !0,
                    },
                    [o.Hardfork.ShardingForkDev]: {
                      name: "shardingForkTime",
                      postMerge: !0,
                      isTimestamp: !0,
                    },
                  },
                  A = Object.keys(E).reduce(
                    (e, t) => ((e[E[t].name] = t), e),
                    {},
                  ),
                  _ = Object.keys(d).filter(
                    (e) => void 0 !== A[e] && void 0 !== d[e] && null !== d[e],
                  );
                if (
                  ((w.hardforks = _.map((e) => ({
                    name: A[e],
                    block:
                      !0 === E[A[e]].isTimestamp || "number" != typeof d[e]
                        ? null
                        : d[e],
                    timestamp:
                      !0 === E[A[e]].isTimestamp && "number" == typeof d[e]
                        ? d[e]
                        : void 0,
                  })).filter(
                    (e) => null !== e.block || void 0 !== e.timestamp,
                  )),
                  w.hardforks.sort((e, t) => {
                    var r, n;
                    return (
                      (null !== (r = e.block) && void 0 !== r ? r : 1 / 0) -
                      (null !== (n = t.block) && void 0 !== n ? n : 1 / 0)
                    );
                  }),
                  w.hardforks.sort((e, t) => {
                    var r, n;
                    return (
                      (null !== (r = e.timestamp) && void 0 !== r ? r : v) -
                      (null !== (n = t.timestamp) && void 0 !== n ? n : v)
                    );
                  }),
                  void 0 !== d.terminalTotalDifficulty)
                ) {
                  const e = {
                      name: o.Hardfork.Merge,
                      ttd: d.terminalTotalDifficulty,
                      block: null,
                    },
                    t = w.hardforks.findIndex((e) => {
                      var t;
                      return (
                        !0 ===
                        (null === (t = E[e.name]) || void 0 === t
                          ? void 0
                          : t.postMerge)
                      );
                    });
                  -1 !== t ? w.hardforks.splice(t, 0, e) : w.hardforks.push(e);
                }
                const T =
                  w.hardforks.length > 0 ? w.hardforks.slice(-1)[0] : void 0;
                return (
                  (w.hardfork = null == T ? void 0 : T.name),
                  w.hardforks.unshift({
                    name: o.Hardfork.Chainstart,
                    block: 0,
                  }),
                  w
                );
              })(e, i)
            );
          } catch (e) {
            throw new Error(`Error parsing parameters file: ${e.message}`);
          }
        }),
          (t.padToEven = d),
          (t.intToUint8Array = function (e) {
            const t = c(e);
            return (0, i.hexToBytes)(`0x${d(t.slice(2))}`);
          }),
          (t.toUint8Array = function (e) {
            if (null == e) return new Uint8Array();
            if (e instanceof Uint8Array) return e;
            if (Array.isArray(e)) return Uint8Array.from(e);
            if ("string" == typeof e) {
              if (!(0, n.isHexString)(e))
                throw new Error(
                  `Cannot convert string to Uint8Array. only supports 0x-prefixed hex strings and this string was given: ${e}`,
                );
              return (0, i.hexToBytes)(d((0, t.stripHexPrefix)(e)));
            }
            if ("number" == typeof e)
              return (0, t.toUint8Array)((0, i.numberToHex)(e));
            if ("bigint" == typeof e) {
              if (e < BigInt(0))
                throw new Error(
                  `Cannot convert negative bigint to Uint8Array. Given: ${e}`,
                );
              let r = e.toString(16);
              return (
                r.length % 2 && (r = `0${r}`), (0, t.toUint8Array)(`0x${r}`)
              );
            }
            if (e.toArray) return Uint8Array.from(e.toArray());
            throw new Error("invalid type");
          }),
          (t.uint8ArrayToBigInt = u),
          (t.bigIntToUint8Array = l),
          (t.zeros = function (e) {
            return new Uint8Array(e).fill(0);
          }),
          (t.assertIsUint8Array = h),
          (t.setLengthLeft = function (e, r) {
            return (
              h(e),
              (function (e, r, n) {
                const i = (0, t.zeros)(r);
                return e.length < r
                  ? (i.set(e, r - e.length), i)
                  : e.subarray(-r);
              })(e, r)
            );
          }),
          (t.stripZeros = f),
          (t.unpadUint8Array = function (e) {
            return h(e), f(e);
          }),
          (t.bigIntToHex = (e) => `0x${e.toString(16)}`),
          (t.bigIntToUnpaddedUint8Array = function (e) {
            return (0, t.unpadUint8Array)(l(e));
          }),
          (t.ecrecover = function (e, t, r, n, i) {
            const o = (function (e, t) {
              return e === BigInt(0) || e === BigInt(1)
                ? e
                : void 0 === t
                ? e - BigInt(27)
                : e - (t * BigInt(2) + BigInt(35));
            })(t, i);
            if (
              !(function (e) {
                return e === BigInt(0) || e === BigInt(1);
              })(o)
            )
              throw new Error("Invalid signature v value");
            return new s.secp256k1.Signature(u(r), u(n))
              .addRecoveryBit(Number(o))
              .recoverPublicKey(e)
              .toRawBytes(!1)
              .slice(1);
          }),
          (t.toType = function (e, r) {
            if (null === e) return null;
            if (void 0 === e) return;
            if ("string" == typeof e && !(0, n.isHexString)(e))
              throw new Error(
                `A string must be provided with a 0x-prefix, given: ${e}`,
              );
            if ("number" == typeof e && !Number.isSafeInteger(e))
              throw new Error(
                "The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)",
              );
            const s = (0, t.toUint8Array)(e);
            switch (r) {
              case a.TypeOutput.Uint8Array:
                return s;
              case a.TypeOutput.BigInt:
                return u(s);
              case a.TypeOutput.Number: {
                const e = u(s);
                if (e > BigInt(Number.MAX_SAFE_INTEGER))
                  throw new Error(
                    "The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)",
                  );
                return Number(e);
              }
              case a.TypeOutput.PrefixedHexString:
                return (0, i.bytesToHex)(s);
              default:
                throw new Error("unknown outputType");
            }
          });
      },
      4464: function (e, t, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (e, t, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(t, r);
                  (i &&
                    !("get" in i
                      ? !t.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return t[r];
                      },
                    }),
                    Object.defineProperty(e, n, i);
                }
              : function (e, t, r, n) {
                  void 0 === n && (n = r), (e[n] = t[r]);
                }),
          i =
            (this && this.__exportStar) ||
            function (e, t) {
              for (var r in e)
                "default" === r ||
                  Object.prototype.hasOwnProperty.call(t, r) ||
                  n(t, e, r);
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          i(r(7563), t),
          i(r(2872), t),
          i(r(1004), t),
          i(r(1782), t),
          i(r(7835), t),
          i(r(2325), t);
      },
      1782: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.keyStoreSchema = void 0),
          (t.keyStoreSchema = {
            type: "object",
            required: ["crypto", "id", "version", "address"],
            properties: {
              crypto: {
                type: "object",
                required: [
                  "cipher",
                  "ciphertext",
                  "cipherparams",
                  "kdf",
                  "kdfparams",
                  "mac",
                ],
                properties: {
                  cipher: { type: "string" },
                  ciphertext: { type: "string" },
                  cipherparams: { type: "object" },
                  kdf: { type: "string" },
                  kdfparams: { type: "object" },
                  salt: { type: "string" },
                  mac: { type: "string" },
                },
              },
              id: { type: "string" },
              version: { type: "number" },
              address: { type: "string" },
            },
          });
      },
      3435: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Address = void 0);
        const n = r(2192),
          i = r(9150),
          s = r(4457),
          o = r(9953);
        class a {
          constructor(e) {
            if (20 !== e.length) throw new Error("Invalid address length");
            this.buf = e;
          }
          static zero() {
            return new a((0, o.zeros)(20));
          }
          equals(e) {
            return (0, i.uint8ArrayEquals)(this.buf, e.buf);
          }
          isZero() {
            return this.equals(a.zero());
          }
          toString() {
            return (0, i.bytesToHex)(this.buf);
          }
          toArray() {
            return this.buf;
          }
          static publicToAddress(e, t = !1) {
            let r = e;
            if (
              ((0, o.assertIsUint8Array)(r),
              t &&
                64 !== r.length &&
                (r = s.secp256k1.ProjectivePoint.fromHex(r)
                  .toRawBytes(!1)
                  .slice(1)),
              64 !== r.length)
            )
              throw new Error("Expected pubKey to be of length 64");
            return (0, n.keccak256)(r).slice(-20);
          }
        }
        t.Address = a;
      },
      8759: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.BaseTransaction = void 0);
        const n = r(9150),
          i = r(4457),
          s = r(7835),
          o = r(8589),
          a = r(3435),
          c = r(914);
        t.BaseTransaction = class {
          constructor(e, t) {
            var r, n;
            (this.cache = { hash: void 0, dataFee: void 0 }),
              (this.activeCapabilities = []),
              (this.DEFAULT_CHAIN = s.Chain.Mainnet),
              (this.DEFAULT_HARDFORK = s.Hardfork.Merge);
            const {
              nonce: i,
              gasLimit: o,
              to: d,
              value: u,
              data: l,
              v: h,
              r: f,
              s: p,
              type: m,
            } = e;
            (this._type = Number(
              (0, s.uint8ArrayToBigInt)((0, s.toUint8Array)(m)),
            )),
              (this.txOptions = t);
            const y = (0, s.toUint8Array)("" === d ? "0x" : d),
              g = (0, s.toUint8Array)("" === h ? "0x" : h),
              v = (0, s.toUint8Array)("" === f ? "0x" : f),
              b = (0, s.toUint8Array)("" === p ? "0x" : p);
            (this.nonce = (0, s.uint8ArrayToBigInt)(
              (0, s.toUint8Array)("" === i ? "0x" : i),
            )),
              (this.gasLimit = (0, s.uint8ArrayToBigInt)(
                (0, s.toUint8Array)("" === o ? "0x" : o),
              )),
              (this.to = y.length > 0 ? new a.Address(y) : void 0),
              (this.value = (0, s.uint8ArrayToBigInt)(
                (0, s.toUint8Array)("" === u ? "0x" : u),
              )),
              (this.data = (0, s.toUint8Array)("" === l ? "0x" : l)),
              (this.v = g.length > 0 ? (0, s.uint8ArrayToBigInt)(g) : void 0),
              (this.r = v.length > 0 ? (0, s.uint8ArrayToBigInt)(v) : void 0),
              (this.s = b.length > 0 ? (0, s.uint8ArrayToBigInt)(b) : void 0),
              this._validateCannotExceedMaxInteger({
                value: this.value,
                r: this.r,
                s: this.s,
              }),
              this._validateCannotExceedMaxInteger(
                { gasLimit: this.gasLimit },
                64,
              ),
              this._validateCannotExceedMaxInteger(
                { nonce: this.nonce },
                64,
                !0,
              );
            const w = void 0 === this.to || null === this.to,
              E =
                null !== (r = t.allowUnlimitedInitCodeSize) &&
                void 0 !== r &&
                r,
              A =
                null !== (n = t.common) && void 0 !== n ? n : this._getCommon();
            w &&
              A.isActivatedEIP(3860) &&
              !E &&
              (0, c.checkMaxInitCodeSize)(A, this.data.length);
          }
          get type() {
            return this._type;
          }
          supports(e) {
            return this.activeCapabilities.includes(e);
          }
          validate(e = !1) {
            const t = [];
            return (
              this.getBaseFee() > this.gasLimit &&
                t.push(
                  `gasLimit is too low. given ${
                    this.gasLimit
                  }, need at least ${this.getBaseFee()}`,
                ),
              this.isSigned() &&
                !this.verifySignature() &&
                t.push("Invalid Signature"),
              e ? t : 0 === t.length
            );
          }
          _validateYParity() {
            const { v: e } = this;
            if (void 0 !== e && e !== BigInt(0) && e !== BigInt(1)) {
              const e = this._errorMsg(
                "The y-parity of the transaction should either be 0 or 1",
              );
              throw new Error(e);
            }
          }
          _validateHighS() {
            const { s: e } = this;
            if (
              this.common.gteHardfork("homestead") &&
              void 0 !== e &&
              e > i.SECP256K1_ORDER_DIV_2
            ) {
              const e = this._errorMsg(
                "Invalid Signature: s-values greater than secp256k1n/2 are considered invalid",
              );
              throw new Error(e);
            }
          }
          getBaseFee() {
            const e = this.common.param("gasPrices", "tx");
            let t = this.getDataFee();
            if (
              (e && (t += e),
              this.common.gteHardfork("homestead") && this.toCreationAddress())
            ) {
              const e = this.common.param("gasPrices", "txCreation");
              e && (t += e);
            }
            return t;
          }
          getDataFee() {
            const e = this.common.param("gasPrices", "txDataZero"),
              t = this.common.param("gasPrices", "txDataNonZero");
            let r = BigInt(0);
            for (let n = 0; n < this.data.length; n += 1)
              0 === this.data[n] ? (r += e) : (r += t);
            if (
              (void 0 === this.to || null === this.to) &&
              this.common.isActivatedEIP(3860)
            ) {
              const e = BigInt(Math.ceil(this.data.length / 32));
              r += this.common.param("gasPrices", "initCodeWordCost") * e;
            }
            return r;
          }
          toCreationAddress() {
            return void 0 === this.to || 0 === this.to.buf.length;
          }
          isSigned() {
            const { v: e, r: t, s: r } = this;
            return void 0 !== e && void 0 !== t && void 0 !== r;
          }
          verifySignature() {
            try {
              const e = this.getSenderPublicKey();
              return 0 !== (0, s.unpadUint8Array)(e).length;
            } catch (e) {
              return !1;
            }
          }
          getSenderAddress() {
            return new a.Address(
              a.Address.publicToAddress(this.getSenderPublicKey()),
            );
          }
          sign(e) {
            if (32 !== e.length) {
              const e = this._errorMsg(
                "Private key must be 32 bytes in length.",
              );
              throw new Error(e);
            }
            let t = !1;
            0 === this.type &&
              this.common.gteHardfork("spuriousDragon") &&
              !this.supports(o.Capability.EIP155ReplayProtection) &&
              (this.activeCapabilities.push(
                o.Capability.EIP155ReplayProtection,
              ),
              (t = !0));
            const r = this.getMessageToSign(!0),
              { v: n, r: i, s } = this._ecsign(r, e),
              a = this._processSignature(n, i, s);
            if (t) {
              const e = this.activeCapabilities.indexOf(
                o.Capability.EIP155ReplayProtection,
              );
              e > -1 && this.activeCapabilities.splice(e, 1);
            }
            return a;
          }
          _getCommon(e, t) {
            var r;
            if (void 0 !== t) {
              const r = (0, s.uint8ArrayToBigInt)((0, s.toUint8Array)(t));
              if (e) {
                if (e.chainId() !== r) {
                  const e = this._errorMsg(
                    "The chain ID does not match the chain ID of Common",
                  );
                  throw new Error(e);
                }
                return e.copy();
              }
              return s.Common.isSupportedChainId(r)
                ? new s.Common({ chain: r, hardfork: this.DEFAULT_HARDFORK })
                : s.Common.custom(
                    { name: "custom-chain", networkId: r, chainId: r },
                    {
                      baseChain: this.DEFAULT_CHAIN,
                      hardfork: this.DEFAULT_HARDFORK,
                    },
                  );
            }
            return null !== (r = null == e ? void 0 : e.copy()) && void 0 !== r
              ? r
              : new s.Common({
                  chain: this.DEFAULT_CHAIN,
                  hardfork: this.DEFAULT_HARDFORK,
                });
          }
          _validateCannotExceedMaxInteger(e, t = 256, r = !1) {
            for (const [n, s] of Object.entries(e))
              switch (t) {
                case 64:
                  if (r) {
                    if (void 0 !== s && s >= i.MAX_UINT64) {
                      const e = this._errorMsg(
                        `${n} cannot equal or exceed MAX_UINT64 (2^64-1), given ${s}`,
                      );
                      throw new Error(e);
                    }
                  } else if (void 0 !== s && s > i.MAX_UINT64) {
                    const e = this._errorMsg(
                      `${n} cannot exceed MAX_UINT64 (2^64-1), given ${s}`,
                    );
                    throw new Error(e);
                  }
                  break;
                case 256:
                  if (r) {
                    if (void 0 !== s && s >= i.MAX_INTEGER) {
                      const e = this._errorMsg(
                        `${n} cannot equal or exceed MAX_INTEGER (2^256-1), given ${s}`,
                      );
                      throw new Error(e);
                    }
                  } else if (void 0 !== s && s > i.MAX_INTEGER) {
                    const e = this._errorMsg(
                      `${n} cannot exceed MAX_INTEGER (2^256-1), given ${s}`,
                    );
                    throw new Error(e);
                  }
                  break;
                default: {
                  const e = this._errorMsg("unimplemented bits value");
                  throw new Error(e);
                }
              }
          }
          static _validateNotArray(e) {
            const t = [
              "nonce",
              "gasPrice",
              "gasLimit",
              "to",
              "value",
              "data",
              "v",
              "r",
              "s",
              "type",
              "baseFee",
              "maxFeePerGas",
              "chainId",
            ];
            for (const [r, n] of Object.entries(e))
              if (t.includes(r) && Array.isArray(n))
                throw new Error(`${r} cannot be an array`);
          }
          _getSharedErrorPostfix() {
            let e = "";
            try {
              e = this.isSigned()
                ? (0, n.bytesToHex)(this.hash())
                : "not available (unsigned)";
            } catch (t) {
              e = "error";
            }
            let t = "";
            try {
              t = this.isSigned().toString();
            } catch (t) {
              e = "error";
            }
            let r = "";
            try {
              r = this.common.hardfork();
            } catch (e) {
              r = "error";
            }
            let i = `tx type=${this.type} hash=${e} nonce=${this.nonce} value=${this.value} `;
            return (i += `signed=${t} hf=${r}`), i;
          }
          _ecsign(e, t, r) {
            const n = i.secp256k1.sign(e, t),
              s = n.toCompactRawBytes();
            return {
              r: s.subarray(0, 32),
              s: s.subarray(32, 64),
              v:
                void 0 === r
                  ? BigInt(n.recovery + 27)
                  : BigInt(n.recovery + 35) + BigInt(r) * BigInt(2),
            };
          }
        };
      },
      4457: function (e, t, r) {
        "use strict";
        var n,
          i =
            (this && this.__createBinding) ||
            (Object.create
              ? function (e, t, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(t, r);
                  (i &&
                    !("get" in i
                      ? !t.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return t[r];
                      },
                    }),
                    Object.defineProperty(e, n, i);
                }
              : function (e, t, r, n) {
                  void 0 === n && (n = r), (e[n] = t[r]);
                }),
          s =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (e, t) {
                  Object.defineProperty(e, "default", {
                    enumerable: !0,
                    value: t,
                  });
                }
              : function (e, t) {
                  e.default = t;
                }),
          o =
            (this && this.__importStar) ||
            function (e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(e, r) &&
                    i(t, e, r);
              return s(t, e), t;
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SECP256K1_ORDER_DIV_2 =
            t.SECP256K1_ORDER =
            t.MAX_INTEGER =
            t.MAX_UINT64 =
            t.secp256k1 =
              void 0);
        const a = o(r(5053));
        (t.secp256k1 = null !== (n = a.secp256k1) && void 0 !== n ? n : a),
          (t.MAX_UINT64 = BigInt("0xffffffffffffffff")),
          (t.MAX_INTEGER = BigInt(
            "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
          )),
          (t.SECP256K1_ORDER = t.secp256k1.CURVE.n),
          (t.SECP256K1_ORDER_DIV_2 = t.SECP256K1_ORDER / BigInt(2));
      },
      8887: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.FeeMarketEIP1559Transaction = void 0);
        const n = r(2192),
          i = r(8840),
          s = r(5507),
          o = r(9150),
          a = r(4457),
          c = r(8759),
          d = r(914),
          u = r(9953),
          l = (0, o.hexToBytes)((2).toString(16).padStart(2, "0"));
        class h extends c.BaseTransaction {
          constructor(e, t = {}) {
            var r;
            super(Object.assign(Object.assign({}, e), { type: 2 }), t),
              (this.DEFAULT_HARDFORK = "london");
            const {
              chainId: n,
              accessList: i,
              maxFeePerGas: s,
              maxPriorityFeePerGas: o,
            } = e;
            if (
              ((this.common = this._getCommon(t.common, n)),
              (this.chainId = this.common.chainId()),
              !this.common.isActivatedEIP(1559))
            )
              throw new Error("EIP-1559 not enabled on Common");
            this.activeCapabilities = this.activeCapabilities.concat([
              1559, 2718, 2930,
            ]);
            const l = (0, d.getAccessListData)(null != i ? i : []);
            if (
              ((this.accessList = l.accessList),
              (this.AccessListJSON = l.AccessListJSON),
              (0, d.verifyAccessList)(this.accessList),
              (this.maxFeePerGas = (0, u.uint8ArrayToBigInt)(
                (0, u.toUint8Array)("" === s ? "0x" : s),
              )),
              (this.maxPriorityFeePerGas = (0, u.uint8ArrayToBigInt)(
                (0, u.toUint8Array)("" === o ? "0x" : o),
              )),
              this._validateCannotExceedMaxInteger({
                maxFeePerGas: this.maxFeePerGas,
                maxPriorityFeePerGas: this.maxPriorityFeePerGas,
              }),
              c.BaseTransaction._validateNotArray(e),
              this.gasLimit * this.maxFeePerGas > a.MAX_INTEGER)
            ) {
              const e = this._errorMsg(
                "gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)",
              );
              throw new Error(e);
            }
            if (this.maxFeePerGas < this.maxPriorityFeePerGas) {
              const e = this._errorMsg(
                "maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)",
              );
              throw new Error(e);
            }
            this._validateYParity(),
              this._validateHighS(),
              (null === (r = null == t ? void 0 : t.freeze) ||
                void 0 === r ||
                r) &&
                Object.freeze(this);
          }
          static fromTxData(e, t = {}) {
            return new h(e, t);
          }
          static fromSerializedTx(e, t = {}) {
            if (!(0, o.uint8ArrayEquals)(e.subarray(0, 1), l))
              throw new Error(
                `Invalid serialized tx input: not an EIP-1559 transaction (wrong tx type, expected: 2, received: ${(0,
                o.bytesToHex)(e.subarray(0, 1))}`,
              );
            const r = s.RLP.decode(e.subarray(1));
            if (!Array.isArray(r))
              throw new Error("Invalid serialized tx input: must be array");
            return h.fromValuesArray(r, t);
          }
          static fromValuesArray(e, t = {}) {
            if (9 !== e.length && 12 !== e.length)
              throw new Error(
                "Invalid EIP-1559 transaction. Only expecting 9 values (for unsigned tx) or 12 values (for signed tx).",
              );
            const [r, n, s, o, a, c, d, l, f, p, m, y] = e;
            return (
              this._validateNotArray({ chainId: r, v: p }),
              (0, i.validateNoLeadingZeroes)({
                nonce: n,
                maxPriorityFeePerGas: s,
                maxFeePerGas: o,
                gasLimit: a,
                value: d,
                v: p,
                r: m,
                s: y,
              }),
              new h(
                {
                  chainId: (0, u.uint8ArrayToBigInt)(r),
                  nonce: n,
                  maxPriorityFeePerGas: s,
                  maxFeePerGas: o,
                  gasLimit: a,
                  to: c,
                  value: d,
                  data: l,
                  accessList: null != f ? f : [],
                  v: void 0 !== p ? (0, u.uint8ArrayToBigInt)(p) : void 0,
                  r: m,
                  s: y,
                },
                t,
              )
            );
          }
          getDataFee() {
            if (
              this.cache.dataFee &&
              this.cache.dataFee.hardfork === this.common.hardfork()
            )
              return this.cache.dataFee.value;
            let e = super.getDataFee();
            return (
              (e += BigInt(
                (0, d.getDataFeeEIP2930)(this.accessList, this.common),
              )),
              Object.isFrozen(this) &&
                (this.cache.dataFee = {
                  value: e,
                  hardfork: this.common.hardfork(),
                }),
              e
            );
          }
          getUpfrontCost(e = BigInt(0)) {
            const t = this.maxPriorityFeePerGas,
              r = this.maxFeePerGas - e,
              n = (t < r ? t : r) + e;
            return this.gasLimit * n + this.value;
          }
          raw() {
            return [
              (0, u.bigIntToUnpaddedUint8Array)(this.chainId),
              (0, u.bigIntToUnpaddedUint8Array)(this.nonce),
              (0, u.bigIntToUnpaddedUint8Array)(this.maxPriorityFeePerGas),
              (0, u.bigIntToUnpaddedUint8Array)(this.maxFeePerGas),
              (0, u.bigIntToUnpaddedUint8Array)(this.gasLimit),
              void 0 !== this.to ? this.to.buf : Uint8Array.from([]),
              (0, u.bigIntToUnpaddedUint8Array)(this.value),
              this.data,
              this.accessList,
              void 0 !== this.v
                ? (0, u.bigIntToUnpaddedUint8Array)(this.v)
                : Uint8Array.from([]),
              void 0 !== this.r
                ? (0, u.bigIntToUnpaddedUint8Array)(this.r)
                : Uint8Array.from([]),
              void 0 !== this.s
                ? (0, u.bigIntToUnpaddedUint8Array)(this.s)
                : Uint8Array.from([]),
            ];
          }
          serialize() {
            const e = this.raw();
            return (0, o.uint8ArrayConcat)(l, s.RLP.encode(e));
          }
          getMessageToSign(e = !0) {
            const t = this.raw().slice(0, 9),
              r = (0, o.uint8ArrayConcat)(l, s.RLP.encode(t));
            return e ? (0, n.keccak256)(r) : r;
          }
          hash() {
            if (!this.isSigned()) {
              const e = this._errorMsg(
                "Cannot call hash method if transaction is not signed",
              );
              throw new Error(e);
            }
            return Object.isFrozen(this)
              ? (this.cache.hash ||
                  (this.cache.hash = (0, n.keccak256)(this.serialize())),
                this.cache.hash)
              : (0, n.keccak256)(this.serialize());
          }
          getMessageToVerifySignature() {
            return this.getMessageToSign();
          }
          getSenderPublicKey() {
            if (!this.isSigned()) {
              const e = this._errorMsg(
                "Cannot call this method if transaction is not signed",
              );
              throw new Error(e);
            }
            const e = this.getMessageToVerifySignature(),
              { v: t, r, s: n } = this;
            this._validateHighS();
            try {
              return (0, u.ecrecover)(
                e,
                t + BigInt(27),
                (0, u.bigIntToUnpaddedUint8Array)(r),
                (0, u.bigIntToUnpaddedUint8Array)(n),
              );
            } catch (e) {
              const t = this._errorMsg("Invalid Signature");
              throw new Error(t);
            }
          }
          _processSignature(e, t, r) {
            const n = Object.assign(Object.assign({}, this.txOptions), {
              common: this.common,
            });
            return h.fromTxData(
              {
                chainId: this.chainId,
                nonce: this.nonce,
                maxPriorityFeePerGas: this.maxPriorityFeePerGas,
                maxFeePerGas: this.maxFeePerGas,
                gasLimit: this.gasLimit,
                to: this.to,
                value: this.value,
                data: this.data,
                accessList: this.accessList,
                v: e - BigInt(27),
                r: (0, u.uint8ArrayToBigInt)(t),
                s: (0, u.uint8ArrayToBigInt)(r),
              },
              n,
            );
          }
          toJSON() {
            const e = (0, d.getAccessListJSON)(this.accessList);
            return {
              chainId: (0, u.bigIntToHex)(this.chainId),
              nonce: (0, u.bigIntToHex)(this.nonce),
              maxPriorityFeePerGas: (0, u.bigIntToHex)(
                this.maxPriorityFeePerGas,
              ),
              maxFeePerGas: (0, u.bigIntToHex)(this.maxFeePerGas),
              gasLimit: (0, u.bigIntToHex)(this.gasLimit),
              to: void 0 !== this.to ? this.to.toString() : void 0,
              value: (0, u.bigIntToHex)(this.value),
              data: (0, o.bytesToHex)(this.data),
              accessList: e,
              v: void 0 !== this.v ? (0, u.bigIntToHex)(this.v) : void 0,
              r: void 0 !== this.r ? (0, u.bigIntToHex)(this.r) : void 0,
              s: void 0 !== this.s ? (0, u.bigIntToHex)(this.s) : void 0,
            };
          }
          errorStr() {
            let e = this._getSharedErrorPostfix();
            return (
              (e += ` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`),
              e
            );
          }
          _errorMsg(e) {
            return `${e} (${this.errorStr()})`;
          }
        }
        t.FeeMarketEIP1559Transaction = h;
      },
      7283: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.AccessListEIP2930Transaction = void 0);
        const n = r(2192),
          i = r(8840),
          s = r(5507),
          o = r(9150),
          a = r(4457),
          c = r(914),
          d = r(9953),
          u = r(8759),
          l = (0, o.hexToBytes)((1).toString(16).padStart(2, "0"));
        class h extends u.BaseTransaction {
          constructor(e, t = {}) {
            var r;
            super(Object.assign(Object.assign({}, e), { type: 1 }), t),
              (this.DEFAULT_HARDFORK = "berlin");
            const { chainId: n, accessList: i, gasPrice: s } = e;
            if (
              ((this.common = this._getCommon(t.common, n)),
              (this.chainId = this.common.chainId()),
              !this.common.isActivatedEIP(2930))
            )
              throw new Error("EIP-2930 not enabled on Common");
            this.activeCapabilities = this.activeCapabilities.concat([
              2718, 2930,
            ]);
            const o = (0, c.getAccessListData)(null != i ? i : []);
            if (
              ((this.accessList = o.accessList),
              (this.AccessListJSON = o.AccessListJSON),
              (0, c.verifyAccessList)(this.accessList),
              (this.gasPrice = (0, d.uint8ArrayToBigInt)(
                (0, d.toUint8Array)("" === s ? "0x" : s),
              )),
              this._validateCannotExceedMaxInteger({ gasPrice: this.gasPrice }),
              u.BaseTransaction._validateNotArray(e),
              this.gasPrice * this.gasLimit > a.MAX_INTEGER)
            ) {
              const e = this._errorMsg(
                "gasLimit * gasPrice cannot exceed MAX_INTEGER",
              );
              throw new Error(e);
            }
            this._validateYParity(),
              this._validateHighS(),
              (null === (r = null == t ? void 0 : t.freeze) ||
                void 0 === r ||
                r) &&
                Object.freeze(this);
          }
          static fromTxData(e, t = {}) {
            return new h(e, t);
          }
          static fromSerializedTx(e, t = {}) {
            if (!(0, o.uint8ArrayEquals)(e.subarray(0, 1), l))
              throw new Error(
                `Invalid serialized tx input: not an EIP-2930 transaction (wrong tx type, expected: 1, received: ${(0,
                o.bytesToHex)(e.subarray(0, 1))}`,
              );
            const r = s.RLP.decode(Uint8Array.from(e.subarray(1)));
            if (!Array.isArray(r))
              throw new Error("Invalid serialized tx input: must be array");
            return h.fromValuesArray(r, t);
          }
          static fromValuesArray(e, t = {}) {
            if (8 !== e.length && 11 !== e.length)
              throw new Error(
                "Invalid EIP-2930 transaction. Only expecting 8 values (for unsigned tx) or 11 values (for signed tx).",
              );
            const [r, n, s, o, a, c, u, l, f, p, m] = e;
            return (
              this._validateNotArray({ chainId: r, v: f }),
              (0, i.validateNoLeadingZeroes)({
                nonce: n,
                gasPrice: s,
                gasLimit: o,
                value: c,
                v: f,
                r: p,
                s: m,
              }),
              new h(
                {
                  chainId: (0, d.uint8ArrayToBigInt)(r),
                  nonce: n,
                  gasPrice: s,
                  gasLimit: o,
                  to: a,
                  value: c,
                  data: u,
                  accessList: null != l ? l : [],
                  v: void 0 !== f ? (0, d.uint8ArrayToBigInt)(f) : void 0,
                  r: p,
                  s: m,
                },
                t,
              )
            );
          }
          getDataFee() {
            if (
              this.cache.dataFee &&
              this.cache.dataFee.hardfork === this.common.hardfork()
            )
              return this.cache.dataFee.value;
            let e = super.getDataFee();
            return (
              (e += BigInt(
                (0, c.getDataFeeEIP2930)(this.accessList, this.common),
              )),
              Object.isFrozen(this) &&
                (this.cache.dataFee = {
                  value: e,
                  hardfork: this.common.hardfork(),
                }),
              e
            );
          }
          getUpfrontCost() {
            return this.gasLimit * this.gasPrice + this.value;
          }
          raw() {
            return [
              (0, d.bigIntToUnpaddedUint8Array)(this.chainId),
              (0, d.bigIntToUnpaddedUint8Array)(this.nonce),
              (0, d.bigIntToUnpaddedUint8Array)(this.gasPrice),
              (0, d.bigIntToUnpaddedUint8Array)(this.gasLimit),
              void 0 !== this.to ? this.to.buf : Uint8Array.from([]),
              (0, d.bigIntToUnpaddedUint8Array)(this.value),
              this.data,
              this.accessList,
              void 0 !== this.v
                ? (0, d.bigIntToUnpaddedUint8Array)(this.v)
                : Uint8Array.from([]),
              void 0 !== this.r
                ? (0, d.bigIntToUnpaddedUint8Array)(this.r)
                : Uint8Array.from([]),
              void 0 !== this.s
                ? (0, d.bigIntToUnpaddedUint8Array)(this.s)
                : Uint8Array.from([]),
            ];
          }
          serialize() {
            const e = this.raw();
            return (0, o.uint8ArrayConcat)(l, s.RLP.encode(e));
          }
          getMessageToSign(e = !0) {
            const t = this.raw().slice(0, 8),
              r = (0, o.uint8ArrayConcat)(l, s.RLP.encode(t));
            return e ? (0, n.keccak256)(r) : r;
          }
          hash() {
            if (!this.isSigned()) {
              const e = this._errorMsg(
                "Cannot call hash method if transaction is not signed",
              );
              throw new Error(e);
            }
            return Object.isFrozen(this)
              ? (this.cache.hash ||
                  (this.cache.hash = (0, n.keccak256)(this.serialize())),
                this.cache.hash)
              : (0, n.keccak256)(this.serialize());
          }
          getMessageToVerifySignature() {
            return this.getMessageToSign();
          }
          getSenderPublicKey() {
            if (!this.isSigned()) {
              const e = this._errorMsg(
                "Cannot call this method if transaction is not signed",
              );
              throw new Error(e);
            }
            const e = this.getMessageToVerifySignature(),
              { v: t, r, s: n } = this;
            this._validateHighS();
            try {
              return (0, d.ecrecover)(
                e,
                t + BigInt(27),
                (0, d.bigIntToUnpaddedUint8Array)(r),
                (0, d.bigIntToUnpaddedUint8Array)(n),
              );
            } catch (e) {
              const t = this._errorMsg("Invalid Signature");
              throw new Error(t);
            }
          }
          _processSignature(e, t, r) {
            const n = Object.assign(Object.assign({}, this.txOptions), {
              common: this.common,
            });
            return h.fromTxData(
              {
                chainId: this.chainId,
                nonce: this.nonce,
                gasPrice: this.gasPrice,
                gasLimit: this.gasLimit,
                to: this.to,
                value: this.value,
                data: this.data,
                accessList: this.accessList,
                v: e - BigInt(27),
                r: (0, d.uint8ArrayToBigInt)(t),
                s: (0, d.uint8ArrayToBigInt)(r),
              },
              n,
            );
          }
          toJSON() {
            const e = (0, c.getAccessListJSON)(this.accessList);
            return {
              chainId: (0, d.bigIntToHex)(this.chainId),
              nonce: (0, d.bigIntToHex)(this.nonce),
              gasPrice: (0, d.bigIntToHex)(this.gasPrice),
              gasLimit: (0, d.bigIntToHex)(this.gasLimit),
              to: void 0 !== this.to ? this.to.toString() : void 0,
              value: (0, d.bigIntToHex)(this.value),
              data: (0, o.bytesToHex)(this.data),
              accessList: e,
              v: void 0 !== this.v ? (0, d.bigIntToHex)(this.v) : void 0,
              r: void 0 !== this.r ? (0, d.bigIntToHex)(this.r) : void 0,
              s: void 0 !== this.s ? (0, d.bigIntToHex)(this.s) : void 0,
            };
          }
          errorStr() {
            var e, t;
            let r = this._getSharedErrorPostfix();
            return (
              (r += ` gasPrice=${this.gasPrice} accessListCount=${
                null !==
                  (t =
                    null === (e = this.accessList) || void 0 === e
                      ? void 0
                      : e.length) && void 0 !== t
                  ? t
                  : 0
              }`),
              r
            );
          }
          _errorMsg(e) {
            return `${e} (${this.errorStr()})`;
          }
        }
        t.AccessListEIP2930Transaction = h;
      },
      2325: function (e, t, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (e, t, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(t, r);
                  (i &&
                    !("get" in i
                      ? !t.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return t[r];
                      },
                    }),
                    Object.defineProperty(e, n, i);
                }
              : function (e, t, r, n) {
                  void 0 === n && (n = r), (e[n] = t[r]);
                }),
          i =
            (this && this.__exportStar) ||
            function (e, t) {
              for (var r in e)
                "default" === r ||
                  Object.prototype.hasOwnProperty.call(t, r) ||
                  n(t, e, r);
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.TransactionFactory =
            t.Transaction =
            t.AccessListEIP2930Transaction =
            t.FeeMarketEIP1559Transaction =
              void 0);
        var s = r(8887);
        Object.defineProperty(t, "FeeMarketEIP1559Transaction", {
          enumerable: !0,
          get: function () {
            return s.FeeMarketEIP1559Transaction;
          },
        });
        var o = r(7283);
        Object.defineProperty(t, "AccessListEIP2930Transaction", {
          enumerable: !0,
          get: function () {
            return o.AccessListEIP2930Transaction;
          },
        });
        var a = r(258);
        Object.defineProperty(t, "Transaction", {
          enumerable: !0,
          get: function () {
            return a.Transaction;
          },
        });
        var c = r(3494);
        Object.defineProperty(t, "TransactionFactory", {
          enumerable: !0,
          get: function () {
            return c.TransactionFactory;
          },
        }),
          i(r(8589), t);
      },
      258: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Transaction = void 0);
        const n = r(5507),
          i = r(2192),
          s = r(9150),
          o = r(8840),
          a = r(9953),
          c = r(4457),
          d = r(8759),
          u = r(8589);
        function l(e, t) {
          const r = Number(e),
            n = 2 * Number(t);
          return r === n + 35 || r === n + 36;
        }
        class h extends d.BaseTransaction {
          constructor(e, t = {}) {
            var r;
            if (
              (super(Object.assign(Object.assign({}, e), { type: 0 }), t),
              (this.common = this._validateTxV(this.v, t.common)),
              (this.gasPrice = (0, a.uint8ArrayToBigInt)(
                (0, a.toUint8Array)("" === e.gasPrice ? "0x" : e.gasPrice),
              )),
              this.gasPrice * this.gasLimit > c.MAX_INTEGER)
            ) {
              const e = this._errorMsg(
                "gas limit * gasPrice cannot exceed MAX_INTEGER (2^256-1)",
              );
              throw new Error(e);
            }
            this._validateCannotExceedMaxInteger({ gasPrice: this.gasPrice }),
              d.BaseTransaction._validateNotArray(e),
              this.common.gteHardfork("spuriousDragon") &&
                (this.isSigned()
                  ? l(this.v, this.common.chainId()) &&
                    this.activeCapabilities.push(
                      u.Capability.EIP155ReplayProtection,
                    )
                  : this.activeCapabilities.push(
                      u.Capability.EIP155ReplayProtection,
                    )),
              (null === (r = null == t ? void 0 : t.freeze) ||
                void 0 === r ||
                r) &&
                Object.freeze(this);
          }
          static fromTxData(e, t = {}) {
            return new h(e, t);
          }
          static fromSerializedTx(e, t = {}) {
            const r = n.RLP.decode(e);
            if (!Array.isArray(r))
              throw new Error("Invalid serialized tx input. Must be array");
            return this.fromValuesArray(r, t);
          }
          static fromValuesArray(e, t = {}) {
            if (6 !== e.length && 9 !== e.length)
              throw new Error(
                "Invalid transaction. Only expecting 6 values (for unsigned tx) or 9 values (for signed tx).",
              );
            const [r, n, i, s, a, c, d, u, l] = e;
            return (
              (0, o.validateNoLeadingZeroes)({
                nonce: r,
                gasPrice: n,
                gasLimit: i,
                value: a,
                v: d,
                r: u,
                s: l,
              }),
              new h(
                {
                  nonce: r,
                  gasPrice: n,
                  gasLimit: i,
                  to: s,
                  value: a,
                  data: c,
                  v: d,
                  r: u,
                  s: l,
                },
                t,
              )
            );
          }
          raw() {
            return [
              (0, a.bigIntToUnpaddedUint8Array)(this.nonce),
              (0, a.bigIntToUnpaddedUint8Array)(this.gasPrice),
              (0, a.bigIntToUnpaddedUint8Array)(this.gasLimit),
              void 0 !== this.to ? this.to.buf : Uint8Array.from([]),
              (0, a.bigIntToUnpaddedUint8Array)(this.value),
              this.data,
              void 0 !== this.v
                ? (0, a.bigIntToUnpaddedUint8Array)(this.v)
                : Uint8Array.from([]),
              void 0 !== this.r
                ? (0, a.bigIntToUnpaddedUint8Array)(this.r)
                : Uint8Array.from([]),
              void 0 !== this.s
                ? (0, a.bigIntToUnpaddedUint8Array)(this.s)
                : Uint8Array.from([]),
            ];
          }
          serialize() {
            return n.RLP.encode(this.raw());
          }
          _getMessageToSign() {
            const e = [
              (0, a.bigIntToUnpaddedUint8Array)(this.nonce),
              (0, a.bigIntToUnpaddedUint8Array)(this.gasPrice),
              (0, a.bigIntToUnpaddedUint8Array)(this.gasLimit),
              void 0 !== this.to ? this.to.buf : Uint8Array.from([]),
              (0, a.bigIntToUnpaddedUint8Array)(this.value),
              this.data,
            ];
            return (
              this.supports(u.Capability.EIP155ReplayProtection) &&
                (e.push((0, a.toUint8Array)(this.common.chainId())),
                e.push((0, a.unpadUint8Array)((0, a.toUint8Array)(0))),
                e.push((0, a.unpadUint8Array)((0, a.toUint8Array)(0)))),
              e
            );
          }
          getMessageToSign(e = !0) {
            const t = this._getMessageToSign();
            return e ? (0, i.keccak256)(n.RLP.encode(t)) : t;
          }
          getDataFee() {
            return this.cache.dataFee &&
              this.cache.dataFee.hardfork === this.common.hardfork()
              ? this.cache.dataFee.value
              : (Object.isFrozen(this) &&
                  (this.cache.dataFee = {
                    value: super.getDataFee(),
                    hardfork: this.common.hardfork(),
                  }),
                super.getDataFee());
          }
          getUpfrontCost() {
            return this.gasLimit * this.gasPrice + this.value;
          }
          hash() {
            if (!this.isSigned()) {
              const e = this._errorMsg(
                "Cannot call hash method if transaction is not signed",
              );
              throw new Error(e);
            }
            return Object.isFrozen(this)
              ? (this.cache.hash ||
                  (this.cache.hash = (0, i.keccak256)(
                    n.RLP.encode(this.raw()),
                  )),
                this.cache.hash)
              : (0, i.keccak256)(n.RLP.encode(this.raw()));
          }
          getMessageToVerifySignature() {
            if (!this.isSigned()) {
              const e = this._errorMsg("This transaction is not signed");
              throw new Error(e);
            }
            const e = this._getMessageToSign();
            return (0, i.keccak256)(n.RLP.encode(e));
          }
          getSenderPublicKey() {
            const e = this.getMessageToVerifySignature(),
              { v: t, r, s: n } = this;
            this._validateHighS();
            try {
              return (0, a.ecrecover)(
                e,
                t,
                (0, a.bigIntToUnpaddedUint8Array)(r),
                (0, a.bigIntToUnpaddedUint8Array)(n),
                this.supports(u.Capability.EIP155ReplayProtection)
                  ? this.common.chainId()
                  : void 0,
              );
            } catch (e) {
              const t = this._errorMsg("Invalid Signature");
              throw new Error(t);
            }
          }
          _processSignature(e, t, r) {
            let n = e;
            this.supports(u.Capability.EIP155ReplayProtection) &&
              (n += this.common.chainId() * BigInt(2) + BigInt(8));
            const i = Object.assign(Object.assign({}, this.txOptions), {
              common: this.common,
            });
            return h.fromTxData(
              {
                nonce: this.nonce,
                gasPrice: this.gasPrice,
                gasLimit: this.gasLimit,
                to: this.to,
                value: this.value,
                data: this.data,
                v: n,
                r: (0, a.uint8ArrayToBigInt)(t),
                s: (0, a.uint8ArrayToBigInt)(r),
              },
              i,
            );
          }
          toJSON() {
            return {
              nonce: (0, a.bigIntToHex)(this.nonce),
              gasPrice: (0, a.bigIntToHex)(this.gasPrice),
              gasLimit: (0, a.bigIntToHex)(this.gasLimit),
              to: void 0 !== this.to ? this.to.toString() : void 0,
              value: (0, a.bigIntToHex)(this.value),
              data: (0, s.bytesToHex)(this.data),
              v: void 0 !== this.v ? (0, a.bigIntToHex)(this.v) : void 0,
              r: void 0 !== this.r ? (0, a.bigIntToHex)(this.r) : void 0,
              s: void 0 !== this.s ? (0, a.bigIntToHex)(this.s) : void 0,
            };
          }
          _validateTxV(e, t) {
            let r;
            const n = void 0 !== e ? Number(e) : void 0;
            if (void 0 !== n && n < 37 && 27 !== n && 28 !== n)
              throw new Error(
                `Legacy txs need either v = 27/28 or v >= 37 (EIP-155 replay protection), got v = ${n}`,
              );
            if (
              void 0 !== n &&
              0 !== n &&
              (!t || t.gteHardfork("spuriousDragon")) &&
              27 !== n &&
              28 !== n
            )
              if (t) {
                if (!l(BigInt(n), t.chainId()))
                  throw new Error(
                    `Incompatible EIP155-based V ${n} and chain id ${t.chainId()}. See the Common parameter of the Transaction constructor to set the chain id.`,
                  );
              } else {
                let e;
                (e = (n - 35) % 2 == 0 ? 35 : 36),
                  (r = BigInt(n - e) / BigInt(2));
              }
            return this._getCommon(t, r);
          }
          errorStr() {
            let e = this._getSharedErrorPostfix();
            return (e += ` gasPrice=${this.gasPrice}`), e;
          }
          _errorMsg(e) {
            return `${e} (${this.errorStr()})`;
          }
        }
        t.Transaction = h;
      },
      3494: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.TransactionFactory = void 0);
        const n = r(9953),
          i = r(8887),
          s = r(7283),
          o = r(258);
        t.TransactionFactory = class {
          constructor() {}
          static fromTxData(e, t = {}) {
            if (!("type" in e) || void 0 === e.type)
              return o.Transaction.fromTxData(e, t);
            const r = Number(
              (0, n.uint8ArrayToBigInt)((0, n.toUint8Array)(e.type)),
            );
            if (0 === r) return o.Transaction.fromTxData(e, t);
            if (1 === r) return s.AccessListEIP2930Transaction.fromTxData(e, t);
            if (2 === r) return i.FeeMarketEIP1559Transaction.fromTxData(e, t);
            throw new Error(`Tx instantiation with type ${r} not supported`);
          }
          static fromSerializedData(e, t = {}) {
            if (!(e[0] <= 127)) return o.Transaction.fromSerializedTx(e, t);
            switch (e[0]) {
              case 1:
                return s.AccessListEIP2930Transaction.fromSerializedTx(e, t);
              case 2:
                return i.FeeMarketEIP1559Transaction.fromSerializedTx(e, t);
              default:
                throw new Error(`TypedTransaction with ID ${e[0]} unknown`);
            }
          }
          static fromBlockBodyData(e, t = {}) {
            if (e instanceof Uint8Array) return this.fromSerializedData(e, t);
            if (Array.isArray(e)) return o.Transaction.fromValuesArray(e, t);
            throw new Error("Cannot decode transaction: unknown type input");
          }
        };
      },
      8589: (e, t) => {
        "use strict";
        function r(e) {
          if (0 === e.length) return !0;
          const t = e[0];
          return !!Array.isArray(t);
        }
        var n;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.isAccessList = t.isAccessListUint8Array = t.Capability = void 0),
          ((n = t.Capability || (t.Capability = {}))[
            (n.EIP155ReplayProtection = 155)
          ] = "EIP155ReplayProtection"),
          (n[(n.EIP1559FeeMarket = 1559)] = "EIP1559FeeMarket"),
          (n[(n.EIP2718TypedTransaction = 2718)] = "EIP2718TypedTransaction"),
          (n[(n.EIP2930AccessLists = 2930)] = "EIP2930AccessLists"),
          (t.isAccessListUint8Array = r),
          (t.isAccessList = function (e) {
            return !r(e);
          });
      },
      914: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getDataFeeEIP2930 =
            t.getAccessListJSON =
            t.verifyAccessList =
            t.getAccessListData =
            t.checkMaxInitCodeSize =
              void 0);
        const n = r(9150),
          i = r(9953),
          s = r(8589);
        (t.checkMaxInitCodeSize = (e, t) => {
          const r = e.param("vm", "maxInitCodeSize");
          if (r && BigInt(t) > r)
            throw new Error(
              `the initcode size of this transaction is too large: it is ${t} while the max is ${e.param(
                "vm",
                "maxInitCodeSize",
              )}`,
            );
        }),
          (t.getAccessListData = (e) => {
            let t, r;
            if ((0, s.isAccessList)(e)) {
              t = e;
              const n = [];
              for (let t = 0; t < e.length; t += 1) {
                const r = e[t],
                  s = (0, i.toUint8Array)(r.address),
                  o = [];
                for (let e = 0; e < r.storageKeys.length; e += 1)
                  o.push((0, i.toUint8Array)(r.storageKeys[e]));
                n.push([s, o]);
              }
              r = n;
            } else {
              r = null != e ? e : [];
              const i = [];
              for (let e = 0; e < r.length; e += 1) {
                const t = r[e],
                  s = (0, n.bytesToHex)(t[0]),
                  o = [];
                for (let e = 0; e < t[1].length; e += 1)
                  o.push((0, n.bytesToHex)(t[1][e]));
                const a = { address: s, storageKeys: o };
                i.push(a);
              }
              t = i;
            }
            return { AccessListJSON: t, accessList: r };
          }),
          (t.verifyAccessList = (e) => {
            for (let t = 0; t < e.length; t += 1) {
              const r = e[t],
                n = r[0],
                i = r[1];
              if (void 0 !== r[2])
                throw new Error(
                  "Access list item cannot have 3 elements. It can only have an address, and an array of storage slots.",
                );
              if (20 !== n.length)
                throw new Error(
                  "Invalid EIP-2930 transaction: address length should be 20 bytes",
                );
              for (let e = 0; e < i.length; e += 1)
                if (32 !== i[e].length)
                  throw new Error(
                    "Invalid EIP-2930 transaction: storage slot length should be 32 bytes",
                  );
            }
          }),
          (t.getAccessListJSON = (e) => {
            const t = [];
            for (let r = 0; r < e.length; r += 1) {
              const s = e[r],
                o = {
                  address: (0, n.bytesToHex)((0, i.setLengthLeft)(s[0], 20)),
                  storageKeys: [],
                },
                a = s && s[1];
              for (let e = 0; e < a.length; e += 1) {
                const t = a[e];
                o.storageKeys.push(
                  (0, n.bytesToHex)((0, i.setLengthLeft)(t, 32)),
                );
              }
              t.push(o);
            }
            return t;
          }),
          (t.getDataFeeEIP2930 = (e, t) => {
            const r = t.param("gasPrices", "accessListStorageKeyCost"),
              n = t.param("gasPrices", "accessListAddressCost");
            let i = 0;
            for (let t = 0; t < e.length; t += 1) i += e[t][1].length;
            return e.length * Number(n) + i * Number(r);
          });
      },
      1004: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
      },
      7563: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__awaiter) ||
          function (e, t, r, n) {
            return new (r || (r = Promise))(function (i, s) {
              function o(e) {
                try {
                  c(n.next(e));
                } catch (e) {
                  s(e);
                }
              }
              function a(e) {
                try {
                  c(n.throw(e));
                } catch (e) {
                  s(e);
                }
              }
              function c(e) {
                var t;
                e.done
                  ? i(e.value)
                  : ((t = e.value),
                    t instanceof r
                      ? t
                      : new r(function (e) {
                          e(t);
                        })).then(o, a);
              }
              c((n = n.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Wallet = void 0);
        const i = r(2823),
          s = r(8840);
        class o extends i.Web3BaseWallet {
          constructor() {
            super(...arguments),
              (this._addressMap = new Map()),
              (this._defaultKeyName = "web3js_wallet");
          }
          static getStorage() {
            let e;
            try {
              e = window.localStorage;
              const t = "__storage_test__";
              return e.setItem(t, t), e.removeItem(t), e;
            } catch (t) {
              return !t ||
                (22 !== t.code &&
                  1014 !== t.code &&
                  "QuotaExceededError" !== t.name &&
                  "NS_ERROR_DOM_QUOTA_REACHED" !== t.name) ||
                (0, s.isNullish)(e) ||
                0 === e.length
                ? void 0
                : e;
            }
          }
          create(e) {
            for (let t = 0; t < e; t += 1)
              this.add(this._accountProvider.create());
            return this;
          }
          add(e) {
            var t;
            if ("string" == typeof e)
              return this.add(this._accountProvider.privateKeyToAccount(e));
            let r = this.length;
            return (
              this.get(e.address) &&
                (console.warn(
                  `Account ${e.address.toLowerCase()} already exists.`,
                ),
                (r =
                  null !==
                    (t = this._addressMap.get(e.address.toLowerCase())) &&
                  void 0 !== t
                    ? t
                    : r)),
              this._addressMap.set(e.address.toLowerCase(), r),
              (this[r] = e),
              this
            );
          }
          get(e) {
            if ("string" == typeof e) {
              const t = this._addressMap.get(e.toLowerCase());
              return (0, s.isNullish)(t) ? void 0 : this[t];
            }
            return this[e];
          }
          remove(e) {
            if ("string" == typeof e) {
              const t = this._addressMap.get(e.toLowerCase());
              return (
                !(0, s.isNullish)(t) &&
                (this._addressMap.delete(e.toLowerCase()),
                this.splice(t, 1),
                !0)
              );
            }
            return !!this[e] && (this.splice(e, 1), !0);
          }
          clear() {
            return this._addressMap.clear(), (this.length = 0), this;
          }
          encrypt(e, t) {
            return n(this, void 0, void 0, function* () {
              return Promise.all(
                this.map((r) =>
                  n(this, void 0, void 0, function* () {
                    return r.encrypt(e, t);
                  }),
                ),
              );
            });
          }
          decrypt(e, t, r) {
            return n(this, void 0, void 0, function* () {
              const i = yield Promise.all(
                e.map((e) =>
                  n(this, void 0, void 0, function* () {
                    return this._accountProvider.decrypt(e, t, r);
                  }),
                ),
              );
              for (const e of i) this.add(e);
              return this;
            });
          }
          save(e, t) {
            return n(this, void 0, void 0, function* () {
              const r = o.getStorage();
              if (!r) throw new Error("Local storage not available.");
              return (
                r.setItem(
                  null != t ? t : this._defaultKeyName,
                  JSON.stringify(yield this.encrypt(e)),
                ),
                !0
              );
            });
          }
          load(e, t) {
            return n(this, void 0, void 0, function* () {
              const r = o.getStorage();
              if (!r) throw new Error("Local storage not available.");
              const n = r.getItem(null != t ? t : this._defaultKeyName);
              return n && (yield this.decrypt(JSON.parse(n) || [], e)), this;
            });
          }
        }
        t.Wallet = o;
      },
      2609: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ALL_EVENTS_ABI = t.ALL_EVENTS = void 0),
          (t.ALL_EVENTS = "ALLEVENTS"),
          (t.ALL_EVENTS_ABI = {
            name: t.ALL_EVENTS,
            signature: "",
            type: "event",
            inputs: [],
          });
      },
      4035: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__awaiter) ||
          function (e, t, r, n) {
            return new (r || (r = Promise))(function (i, s) {
              function o(e) {
                try {
                  c(n.next(e));
                } catch (e) {
                  s(e);
                }
              }
              function a(e) {
                try {
                  c(n.throw(e));
                } catch (e) {
                  s(e);
                }
              }
              function c(e) {
                var t;
                e.done
                  ? i(e.value)
                  : ((t = e.value),
                    t instanceof r
                      ? t
                      : new r(function (e) {
                          e(t);
                        })).then(o, a);
              }
              c((n = n.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Contract = void 0);
        const i = r(8557),
          s = r(3087),
          o = r(6653),
          a = r(3050),
          c = r(2823),
          d = r(9150),
          u = r(8840),
          l = r(2609),
          h = r(2305),
          f = r(6532),
          p = r(2056),
          m = {
            logs: f.LogsSubscription,
            newHeads: o.NewHeadsSubscription,
            newBlockHeaders: o.NewHeadsSubscription,
          };
        class y extends i.Web3Context {
          constructor(e, t, r, n, o) {
            var a, l, h;
            const f = (0, p.isContractInitOptions)(t)
              ? t
              : (0, p.isContractInitOptions)(r)
              ? r
              : void 0;
            if (
              !(0, u.isNullish)(f) &&
              !(0, u.isNullish)(f.data) &&
              !(0, u.isNullish)(f.input)
            )
              throw new s.ContractTransactionDataAndInputError({
                data: f.data,
                input: f.input,
              });
            let g, v;
            (g = (0, p.isWeb3ContractContext)(t)
              ? t
              : (0, p.isWeb3ContractContext)(r)
              ? r
              : n),
              (v =
                "object" == typeof t && "provider" in t
                  ? t.provider
                  : "object" == typeof r && "provider" in r
                  ? r.provider
                  : "object" == typeof n && "provider" in n
                  ? n.provider
                  : y.givenProvider),
              super(
                Object.assign(Object.assign({}, g), {
                  provider: v,
                  registeredSubscriptions: m,
                }),
              ),
              (this.syncWithContext = !1),
              (this._functions = {}),
              (this._overloadedMethodAbis = new Map());
            const b = (0, d.isDataFormat)(n)
                ? n
                : (0, d.isDataFormat)(r)
                ? r
                : null != o
                ? o
                : c.DEFAULT_RETURN_FORMAT,
              w = "string" == typeof t ? t : void 0;
            this._parseAndSetJsonInterface(e, b),
              (0, u.isNullish)(w) || this._parseAndSetAddress(w, b),
              (this.options = {
                address: w,
                jsonInterface: this._jsonInterface,
                gas:
                  null !== (a = null == f ? void 0 : f.gas) && void 0 !== a
                    ? a
                    : null == f
                    ? void 0
                    : f.gasLimit,
                gasPrice: null == f ? void 0 : f.gasPrice,
                from: null == f ? void 0 : f.from,
                input:
                  null !== (l = null == f ? void 0 : f.input) && void 0 !== l
                    ? l
                    : null == f
                    ? void 0
                    : f.data,
              }),
              (this.syncWithContext =
                null !== (h = null == f ? void 0 : f.syncWithContext) &&
                void 0 !== h &&
                h),
              g instanceof i.Web3Context && this.subscribeToContextEvents(g),
              Object.defineProperty(this.options, "address", {
                set: (e) => this._parseAndSetAddress(e, b),
                get: () => this._address,
              }),
              Object.defineProperty(this.options, "jsonInterface", {
                set: (e) => this._parseAndSetJsonInterface(e, b),
                get: () => this._jsonInterface,
              });
          }
          get events() {
            return this._events;
          }
          get methods() {
            return this._methods;
          }
          clone() {
            let e;
            return (
              (e = this.options.address
                ? new y(
                    [...this._jsonInterface, ...this._errorsInterface],
                    this.options.address,
                    {
                      gas: this.options.gas,
                      gasPrice: this.options.gasPrice,
                      from: this.options.from,
                      input: this.options.input,
                      provider: this.currentProvider,
                      syncWithContext: this.syncWithContext,
                    },
                    this.getContextObject(),
                  )
                : new y(
                    [...this._jsonInterface, ...this._errorsInterface],
                    {
                      gas: this.options.gas,
                      gasPrice: this.options.gasPrice,
                      from: this.options.from,
                      input: this.options.input,
                      provider: this.currentProvider,
                      syncWithContext: this.syncWithContext,
                    },
                    this.getContextObject(),
                  )),
              this.context && e.subscribeToContextEvents(this.context),
              e
            );
          }
          deploy(e) {
            var t, r, i;
            let o = this._jsonInterface.find((e) => "constructor" === e.type);
            o || (o = { type: "constructor", inputs: [], stateMutability: "" });
            const a = (0, d.format)(
              { format: "bytes" },
              null !==
                (r =
                  null !== (t = null == e ? void 0 : e.input) && void 0 !== t
                    ? t
                    : null == e
                    ? void 0
                    : e.data) && void 0 !== r
                ? r
                : this.options.input,
              c.DEFAULT_RETURN_FORMAT,
            );
            if (!a || "0x" === a.trim())
              throw new s.Web3ContractError(
                "contract creation without any data provided.",
              );
            const u =
                null !== (i = null == e ? void 0 : e.arguments) && void 0 !== i
                  ? i
                  : [],
              l = Object.assign(Object.assign({}, this.options), { input: a });
            return {
              arguments: u,
              send: (e) => {
                const t = Object.assign({}, e);
                return this._contractMethodDeploySend(o, u, t, l);
              },
              estimateGas: (e, t = c.DEFAULT_RETURN_FORMAT) =>
                n(this, void 0, void 0, function* () {
                  const r = Object.assign({}, e);
                  return this._contractMethodEstimateGas({
                    abi: o,
                    params: u,
                    returnFormat: t,
                    options: r,
                    contractOptions: l,
                  });
                }),
              encodeABI: () =>
                (0, h.encodeMethodABI)(
                  o,
                  u,
                  (0, d.format)(
                    { format: "bytes" },
                    a,
                    c.DEFAULT_RETURN_FORMAT,
                  ),
                ),
            };
          }
          getPastEvents(e, t, r) {
            var i;
            return n(this, void 0, void 0, function* () {
              const n = "string" == typeof e ? e : "allEvents",
                a =
                  "string" == typeof e || (0, d.isDataFormat)(e)
                    ? (0, d.isDataFormat)(t)
                      ? {}
                      : t
                    : e,
                u = (0, d.isDataFormat)(e)
                  ? e
                  : (0, d.isDataFormat)(t)
                  ? t
                  : null != r
                  ? r
                  : c.DEFAULT_RETURN_FORMAT,
                f =
                  "allEvents" === n
                    ? l.ALL_EVENTS_ABI
                    : this._jsonInterface.find(
                        (e) => "name" in e && e.name === n,
                      );
              if (!f) throw new s.Web3ContractError(`Event ${n} not found.`);
              const {
                  fromBlock: p,
                  toBlock: m,
                  topics: y,
                  address: g,
                } = (0, h.encodeEventABI)(this.options, f, null != a ? a : {}),
                v = (yield (0, o.getLogs)(
                  this,
                  { fromBlock: p, toBlock: m, topics: y, address: g },
                  u,
                )).map((e) =>
                  "string" == typeof e
                    ? e
                    : (0, h.decodeEventABI)(f, e, this._jsonInterface, u),
                ),
                b =
                  null !== (i = null == a ? void 0 : a.filter) && void 0 !== i
                    ? i
                    : {},
                w = Object.keys(b);
              return w.length > 0
                ? v.filter(
                    (e) =>
                      "string" == typeof e ||
                      w.every((t) => {
                        var r;
                        if (Array.isArray(b[t]))
                          return b[t].some(
                            (r) =>
                              String(e.returnValues[t]).toUpperCase() ===
                              String(r).toUpperCase(),
                          );
                        const n =
                          null === (r = f.inputs) || void 0 === r
                            ? void 0
                            : r.filter((e) => e.name === t)[0];
                        return (
                          !(
                            !(null == n ? void 0 : n.indexed) ||
                            "string" !== n.type ||
                            (0, d.keccak256)(b[t]) !== String(e.returnValues[t])
                          ) ||
                          String(e.returnValues[t]).toUpperCase() ===
                            String(b[t]).toUpperCase()
                        );
                      }),
                  )
                : v;
            });
          }
          _parseAndSetAddress(e, t = c.DEFAULT_RETURN_FORMAT) {
            this._address = e
              ? (0, d.toChecksumAddress)(
                  (0, d.format)({ format: "address" }, e, t),
                )
              : e;
          }
          _parseAndSetJsonInterface(e, t = c.DEFAULT_RETURN_FORMAT) {
            var r, n, i, s, o;
            (this._functions = {}), (this._methods = {}), (this._events = {});
            let d = [];
            const u = e.filter((e) => "error" !== e.type),
              h = e.filter((e) => (0, a.isAbiErrorFragment)(e));
            for (const e of u) {
              const c = Object.assign(Object.assign({}, e), { signature: "" });
              if ((0, a.isAbiFunctionFragment)(c)) {
                const e = (0, a.jsonInterfaceMethodToString)(c),
                  t = (0, a.encodeFunctionSignature)(e);
                (c.signature = t),
                  (c.constant =
                    null !==
                      (n =
                        null !== (r = "view" === c.stateMutability) &&
                        void 0 !== r
                          ? r
                          : "pure" === c.stateMutability) && void 0 !== n
                      ? n
                      : c.constant),
                  (c.payable =
                    null !== (i = "payable" === c.stateMutability) &&
                    void 0 !== i
                      ? i
                      : c.payable),
                  this._overloadedMethodAbis.set(c.name, [
                    ...(null !== (s = this._overloadedMethodAbis.get(c.name)) &&
                    void 0 !== s
                      ? s
                      : []),
                    c,
                  ]);
                const d =
                    null !== (o = this._overloadedMethodAbis.get(c.name)) &&
                    void 0 !== o
                      ? o
                      : [],
                  u = this._createContractMethod(d, h);
                (this._functions[e] = { signature: t, method: u }),
                  (this._methods[c.name] = this._functions[e].method),
                  (this._methods[e] = this._functions[e].method),
                  (this._methods[t] = this._functions[e].method);
              } else if ((0, a.isAbiEventFragment)(c)) {
                const e = (0, a.jsonInterfaceMethodToString)(c),
                  r = (0, a.encodeEventSignature)(e),
                  n = this._createContractEvent(c, t);
                (c.signature = r),
                  (e in this._events && "bound" !== c.name) ||
                    (this._events[e] = n),
                  (this._events[c.name] = n),
                  (this._events[r] = n);
              }
              (this._events.allEvents = this._createContractEvent(
                l.ALL_EVENTS_ABI,
                t,
              )),
                (d = [...d, c]);
            }
            (this._jsonInterface = [...d]), (this._errorsInterface = h);
          }
          _getAbiParams(e, t) {
            var r;
            try {
              return u.utils.transformJsonDataToAbiFormat(
                null !== (r = e.inputs) && void 0 !== r ? r : [],
                t,
              );
            } catch (t) {
              throw new s.Web3ContractError(
                `Invalid parameters for method ${e.name}: ${t.message}`,
              );
            }
          }
          _createContractMethod(e, t) {
            const r = e[e.length - 1];
            return (...e) => {
              var i, s;
              let o;
              const a =
                null !== (i = this._overloadedMethodAbis.get(r.name)) &&
                void 0 !== i
                  ? i
                  : [];
              let d = a[0];
              const l = t,
                f = a.filter((t) => {
                  var r;
                  return (
                    (null !== (r = t.inputs) && void 0 !== r ? r : [])
                      .length === e.length
                  );
                });
              if (1 === a.length || 0 === f.length)
                (o = this._getAbiParams(d, e)),
                  u.validator.validate(
                    null !== (s = r.inputs) && void 0 !== s ? s : [],
                    o,
                  );
              else {
                const t = [];
                for (const r of f)
                  try {
                    (o = this._getAbiParams(r, e)),
                      u.validator.validate(r.inputs, o),
                      (d = r);
                    break;
                  } catch (e) {
                    t.push(e);
                  }
                if (t.length === f.length) throw new u.Web3ValidatorError(t);
              }
              const p = {
                arguments: o,
                call: (e, t) =>
                  n(this, void 0, void 0, function* () {
                    return this._contractMethodCall(d, o, l, e, t);
                  }),
                send: (e) => this._contractMethodSend(d, o, l, e),
                estimateGas: (e, t = c.DEFAULT_RETURN_FORMAT) =>
                  n(this, void 0, void 0, function* () {
                    return this._contractMethodEstimateGas({
                      abi: d,
                      params: o,
                      returnFormat: t,
                      options: e,
                    });
                  }),
                encodeABI: () => (0, h.encodeMethodABI)(d, o),
                createAccessList: (e, t) =>
                  n(this, void 0, void 0, function* () {
                    return this._contractMethodCreateAccessList(d, o, l, e, t);
                  }),
              };
              return d.stateMutability, p;
            };
          }
          _contractMethodCall(e, t, r, i, d) {
            var u;
            return n(this, void 0, void 0, function* () {
              const n = (0, p.getEthTxCallParams)({
                abi: e,
                params: t,
                options: i,
                contractOptions: Object.assign(
                  Object.assign({}, this.options),
                  {
                    from:
                      null !== (u = this.options.from) && void 0 !== u
                        ? u
                        : this.config.defaultAccount,
                  },
                ),
              });
              try {
                const t = yield (0, o.call)(
                  this,
                  n,
                  d,
                  c.DEFAULT_RETURN_FORMAT,
                );
                return (0, h.decodeMethodReturn)(e, t);
              } catch (e) {
                throw (
                  (e instanceof s.ContractExecutionError &&
                    (0, a.decodeContractErrorData)(r, e.innerError),
                  e)
                );
              }
            });
          }
          _contractMethodCreateAccessList(e, t, r, i, d) {
            var u;
            return n(this, void 0, void 0, function* () {
              const n = (0, p.getCreateAccessListParams)({
                abi: e,
                params: t,
                options: i,
                contractOptions: Object.assign(
                  Object.assign({}, this.options),
                  {
                    from:
                      null !== (u = this.options.from) && void 0 !== u
                        ? u
                        : this.config.defaultAccount,
                  },
                ),
              });
              try {
                return (0, o.createAccessList)(
                  this,
                  n,
                  d,
                  c.DEFAULT_RETURN_FORMAT,
                );
              } catch (e) {
                throw (
                  (e instanceof s.ContractExecutionError &&
                    (0, a.decodeContractErrorData)(r, e.innerError),
                  e)
                );
              }
            });
          }
          _contractMethodSend(e, t, r, n, i) {
            var d, u;
            let l = null != i ? i : this.options;
            l = Object.assign(Object.assign({}, l), {
              input: void 0,
              from:
                null !==
                  (u =
                    null !== (d = l.from) && void 0 !== d
                      ? d
                      : this.defaultAccount) && void 0 !== u
                  ? u
                  : void 0,
            });
            const h = (0, p.getSendTxParams)({
                abi: e,
                params: t,
                options: n,
                contractOptions: l,
              }),
              f = (0, o.sendTransaction)(this, h, c.DEFAULT_RETURN_FORMAT, {
                checkRevertBeforeSending: !1,
              });
            return (
              f.on("error", (e) => {
                e instanceof s.ContractExecutionError &&
                  (0, a.decodeContractErrorData)(r, e.innerError);
              }),
              f
            );
          }
          _contractMethodDeploySend(e, t, r, n) {
            var i, a;
            let d = null != n ? n : this.options;
            d = Object.assign(Object.assign({}, d), {
              from:
                null !==
                  (a =
                    null !== (i = d.from) && void 0 !== i
                      ? i
                      : this.defaultAccount) && void 0 !== a
                  ? a
                  : void 0,
            });
            const u = (0, p.getSendTxParams)({
              abi: e,
              params: t,
              options: r,
              contractOptions: d,
            });
            return (0, o.sendTransaction)(this, u, c.DEFAULT_RETURN_FORMAT, {
              transactionResolver: (e) => {
                if (e.status === BigInt(0))
                  throw new s.Web3ContractError("code couldn't be stored", e);
                const t = this.clone();
                return (t.options.address = e.contractAddress), t;
              },
              checkRevertBeforeSending: !1,
            });
          }
          _contractMethodEstimateGas({
            abi: e,
            params: t,
            returnFormat: r,
            options: i,
            contractOptions: s,
          }) {
            return n(this, void 0, void 0, function* () {
              const n = (0, p.getEstimateGasParams)({
                abi: e,
                params: t,
                options: i,
                contractOptions: null != s ? s : this.options,
              });
              return (0, o.estimateGas)(this, n, c.BlockTags.LATEST, r);
            });
          }
          _createContractEvent(e, t = c.DEFAULT_RETURN_FORMAT) {
            return (...r) => {
              var n;
              const { topics: i, fromBlock: o } = (0, h.encodeEventABI)(
                  this.options,
                  e,
                  r[0],
                ),
                a = new f.LogsSubscription(
                  {
                    address: this.options.address,
                    topics: i,
                    abi: e,
                    jsonInterface: this._jsonInterface,
                  },
                  {
                    subscriptionManager: this.subscriptionManager,
                    returnFormat: t,
                  },
                );
              return (
                (0, u.isNullish)(o) ||
                  this.getPastEvents(e.name, { fromBlock: o, topics: i }, t)
                    .then((e) => {
                      e.forEach((e) => a.emit("data", e));
                    })
                    .catch(() => {
                      a.emit(
                        "error",
                        new s.SubscriptionError("Failed to get past events."),
                      );
                    }),
                null === (n = this.subscriptionManager) ||
                  void 0 === n ||
                  n.addSubscription(a).catch(() => {
                    a.emit(
                      "error",
                      new s.SubscriptionError("Failed to subscribe."),
                    );
                  }),
                a
              );
            };
          }
          subscribeToContextEvents(e) {
            const t = this;
            (this.context = e),
              t.syncWithContext &&
                e.on(i.Web3ConfigEvent.CONFIG_CHANGE, (e) => {
                  t.setConfig({ [e.name]: e.newValue });
                });
          }
        }
        t.Contract = y;
      },
      2305: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.decodeMethodReturn =
            t.encodeMethodABI =
            t.decodeEventABI =
            t.encodeEventABI =
              void 0);
        const n = r(9150),
          i = r(2823),
          s = r(3050),
          o = r(6653),
          a = r(3087);
        (t.encodeEventABI = ({ address: e }, t, r) => {
          var a, c;
          const d = null == r ? void 0 : r.topics,
            u =
              null !== (a = null == r ? void 0 : r.filter) && void 0 !== a
                ? a
                : {},
            l = {};
          if (
            ((0, n.isNullish)(null == r ? void 0 : r.fromBlock) ||
              (l.fromBlock = (0, n.format)(
                o.blockSchema.properties.number,
                null == r ? void 0 : r.fromBlock,
                { number: i.FMT_NUMBER.HEX, bytes: i.FMT_BYTES.HEX },
              )),
            (0, n.isNullish)(null == r ? void 0 : r.toBlock) ||
              (l.toBlock = (0, n.format)(
                o.blockSchema.properties.number,
                null == r ? void 0 : r.toBlock,
                { number: i.FMT_NUMBER.HEX, bytes: i.FMT_BYTES.HEX },
              )),
            d && Array.isArray(d))
          )
            l.topics = [...d];
          else if (
            ((l.topics = []),
            t &&
              !t.anonymous &&
              "ALLEVENTS" !== t.name &&
              l.topics.push(
                null !== (c = t.signature) && void 0 !== c
                  ? c
                  : (0, s.encodeEventSignature)(
                      (0, s.jsonInterfaceMethodToString)(t),
                    ),
              ),
            "ALLEVENTS" !== t.name && t.inputs)
          )
            for (const e of t.inputs) {
              if (!e.indexed) continue;
              const t = u[e.name];
              t
                ? Array.isArray(t)
                  ? l.topics.push(
                      t.map((t) => (0, s.encodeParameter)(e.type, t)),
                    )
                  : "string" === e.type
                  ? l.topics.push((0, n.keccak256)(t))
                  : l.topics.push((0, s.encodeParameter)(e.type, t))
                : l.topics.push(null);
            }
          return (
            l.topics.length || delete l.topics,
            e && (l.address = e.toLowerCase()),
            l
          );
        }),
          (t.decodeEventABI = (e, t, r, a = i.DEFAULT_RETURN_FORMAT) => {
            var c, d, u, l, h;
            let f = Object.assign({}, e);
            const p = (0, n.format)(o.logSchema, t, a);
            if ("ALLEVENTS" === f.name) {
              f = r.find((e) => e.signature === t.topics[0]) || {
                anonymous: !0,
              };
            }
            if (
              ((f.inputs =
                null !==
                  (d =
                    null !== (c = f.inputs) && void 0 !== c ? c : e.inputs) &&
                void 0 !== d
                  ? d
                  : []),
              !f.anonymous)
            ) {
              let e = 0;
              (null !== (u = f.inputs) && void 0 !== u ? u : []).forEach(
                (t) => {
                  t.indexed && (e += 1);
                },
              ),
                e > 0 &&
                  (null == t ? void 0 : t.topics) &&
                  (null == t ? void 0 : t.topics.length) !== e + 1 &&
                  (f = Object.assign(Object.assign({}, f), {
                    anonymous: !0,
                    inputs: [],
                  }));
            }
            const m = f.anonymous
              ? t.topics
              : (null !== (l = t.topics) && void 0 !== l ? l : []).slice(1);
            return Object.assign(Object.assign({}, p), {
              returnValues: (0, s.decodeLog)(
                [...(null !== (h = f.inputs) && void 0 !== h ? h : [])],
                t.data,
                m,
              ),
              event: f.name,
              signature:
                !f.anonymous && t.topics && 0 !== t.topics.length && t.topics[0]
                  ? t.topics[0]
                  : void 0,
              raw: { data: t.data, topics: t.topics },
            });
          }),
          (t.encodeMethodABI = (e, t, r) => {
            const n = Array.isArray(e.inputs) ? e.inputs.length : 0;
            if (n !== t.length)
              throw new a.Web3ContractError(
                `The number of arguments is not matching the methods required number. You need to pass ${n} arguments.`,
              );
            const i = (0, s.encodeParameters)(
              Array.isArray(e.inputs) ? e.inputs : [],
              t,
            ).replace("0x", "");
            if ((0, s.isAbiConstructorFragment)(e)) {
              if (!r)
                throw new a.Web3ContractError(
                  "The contract has no contract data option set. This is necessary to append the constructor parameters.",
                );
              return r.startsWith("0x") ? `${r}${i}` : `0x${r}${i}`;
            }
            return `${(0, s.encodeFunctionSignature)(e)}${i}`;
          }),
          (t.decodeMethodReturn = (e, t) => {
            if ("constructor" === e.type) return t;
            if (!t) return null;
            const r = t.length >= 2 ? t.slice(2) : t;
            if (!e.outputs) return null;
            const n = (0, s.decodeParameters)([...e.outputs], r);
            return 1 === n.__length__ ? n[0] : n;
          });
      },
      2290: function (e, t, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (e, t, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(t, r);
                  (i &&
                    !("get" in i
                      ? !t.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return t[r];
                      },
                    }),
                    Object.defineProperty(e, n, i);
                }
              : function (e, t, r, n) {
                  void 0 === n && (n = r), (e[n] = t[r]);
                }),
          i =
            (this && this.__exportStar) ||
            function (e, t) {
              for (var r in e)
                "default" === r ||
                  Object.prototype.hasOwnProperty.call(t, r) ||
                  n(t, e, r);
            };
        Object.defineProperty(t, "__esModule", { value: !0 });
        const s = r(4035);
        i(r(2305), t),
          i(r(4035), t),
          i(r(6532), t),
          i(r(9360), t),
          (t.default = s.Contract);
      },
      6532: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.LogsSubscription = void 0);
        const n = r(8557),
          i = r(2305);
        class s extends n.Web3Subscription {
          constructor(e, t) {
            super(e, t),
              (this.address = e.address),
              (this.topics = e.topics),
              (this.abi = e.abi),
              (this.jsonInterface = e.jsonInterface);
          }
          _buildSubscriptionParams() {
            return ["logs", { address: this.address, topics: this.topics }];
          }
          formatSubscriptionResult(e) {
            return (0, i.decodeEventABI)(
              this.abi,
              e,
              this.jsonInterface,
              super.returnFormat,
            );
          }
        }
        t.LogsSubscription = s;
      },
      9360: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
      },
      2056: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getCreateAccessListParams =
            t.isWeb3ContractContext =
            t.isContractInitOptions =
            t.getEstimateGasParams =
            t.getEthTxCallParams =
            t.getSendTxParams =
              void 0);
        const n = r(3087),
          i = r(9150),
          s = r(2305);
        (t.getSendTxParams = ({
          abi: e,
          params: t,
          options: r,
          contractOptions: o,
        }) => {
          var a, c;
          if (
            !(null !==
              (c =
                null !== (a = null == r ? void 0 : r.input) && void 0 !== a
                  ? a
                  : null == r
                  ? void 0
                  : r.data) && void 0 !== c
              ? c
              : o.input) &&
            !(null == r ? void 0 : r.to) &&
            !o.address
          )
            throw new n.Web3ContractError("Contract address not specified");
          if (!(null == r ? void 0 : r.from) && !o.from)
            throw new n.Web3ContractError(
              'Contract "from" address not specified',
            );
          let d = (0, i.mergeDeep)(
            {
              to: o.address,
              gas: o.gas,
              gasPrice: o.gasPrice,
              from: o.from,
              input: o.input,
              maxPriorityFeePerGas: o.maxPriorityFeePerGas,
              maxFeePerGas: o.maxFeePerGas,
            },
            r,
          );
          return (
            (d.input && "constructor" !== e.type) ||
              (d = Object.assign(Object.assign({}, d), {
                input: (0, s.encodeMethodABI)(e, t, d.input),
              })),
            d
          );
        }),
          (t.getEthTxCallParams = ({
            abi: e,
            params: t,
            options: r,
            contractOptions: o,
          }) => {
            if (!(null == r ? void 0 : r.to) && !o.address)
              throw new n.Web3ContractError("Contract address not specified");
            let a = (0, i.mergeDeep)(
              {
                to: o.address,
                gas: o.gas,
                gasPrice: o.gasPrice,
                from: o.from,
                input: o.input,
                maxPriorityFeePerGas: o.maxPriorityFeePerGas,
                maxFeePerGas: o.maxFeePerGas,
              },
              r,
            );
            return (
              (a = Object.assign(Object.assign({}, a), {
                input: (0, s.encodeMethodABI)(
                  e,
                  t,
                  a.input ? (0, i.toHex)(a.input) : void 0,
                ),
              })),
              a
            );
          }),
          (t.getEstimateGasParams = ({
            abi: e,
            params: t,
            options: r,
            contractOptions: n,
          }) => {
            let o = (0, i.mergeDeep)(
              {
                to: n.address,
                gas: n.gas,
                gasPrice: n.gasPrice,
                from: n.from,
                input: n.input,
              },
              r,
            );
            return (
              (o = Object.assign(Object.assign({}, o), {
                input: (0, s.encodeMethodABI)(
                  e,
                  t,
                  o.input ? (0, i.toHex)(o.input) : void 0,
                ),
              })),
              o
            );
          }),
          (t.isContractInitOptions = (e) =>
            "object" == typeof e &&
            !(0, i.isNullish)(e) &&
            [
              "input",
              "data",
              "from",
              "gas",
              "gasPrice",
              "gasLimit",
              "address",
              "jsonInterface",
              "syncWithContext",
            ].some((t) => t in e)),
          (t.isWeb3ContractContext = (e) =>
            "object" == typeof e &&
            !(0, i.isNullish)(e) &&
            !(0, t.isContractInitOptions)(e)),
          (t.getCreateAccessListParams = ({
            abi: e,
            params: t,
            options: r,
            contractOptions: o,
          }) => {
            if (!(null == r ? void 0 : r.to) && !o.address)
              throw new n.Web3ContractError("Contract address not specified");
            if (!(null == r ? void 0 : r.from) && !o.from)
              throw new n.Web3ContractError(
                'Contract "from" address not specified',
              );
            let a = (0, i.mergeDeep)(
              {
                to: o.address,
                gas: o.gas,
                gasPrice: o.gasPrice,
                from: o.from,
                input: o.input,
                maxPriorityFeePerGas: o.maxPriorityFeePerGas,
                maxFeePerGas: o.maxFeePerGas,
              },
              r,
            );
            return (
              (a.input && "constructor" !== e.type) ||
                (a = Object.assign(Object.assign({}, a), {
                  input: (0, s.encodeMethodABI)(e, t, a.input),
                })),
              a
            );
          });
      },
      1816: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ENSRegistryAbi = void 0),
          (t.ENSRegistryAbi = [
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !0,
                  internalType: "bytes32",
                  name: "node",
                  type: "bytes32",
                },
                {
                  indexed: !0,
                  internalType: "bytes32",
                  name: "label",
                  type: "bytes32",
                },
                {
                  indexed: !1,
                  internalType: "address",
                  name: "owner",
                  type: "address",
                },
              ],
              name: "NewOwner",
              type: "event",
            },
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !0,
                  internalType: "bytes32",
                  name: "node",
                  type: "bytes32",
                },
                {
                  indexed: !1,
                  internalType: "address",
                  name: "resolver",
                  type: "address",
                },
              ],
              name: "NewResolver",
              type: "event",
            },
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !0,
                  internalType: "bytes32",
                  name: "node",
                  type: "bytes32",
                },
                {
                  indexed: !1,
                  internalType: "address",
                  name: "owner",
                  type: "address",
                },
              ],
              name: "Transfer",
              type: "event",
            },
            {
              inputs: [
                { internalType: "address", name: "owner", type: "address" },
                { internalType: "address", name: "operator", type: "address" },
              ],
              name: "isApprovedForAll",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [
                { internalType: "bytes32", name: "node", type: "bytes32" },
              ],
              name: "owner",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [
                { internalType: "bytes32", name: "node", type: "bytes32" },
              ],
              name: "recordExists",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [
                { internalType: "bytes32", name: "node", type: "bytes32" },
              ],
              name: "resolver",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [
                { internalType: "bytes32", name: "node", type: "bytes32" },
              ],
              name: "ttl",
              outputs: [{ internalType: "uint64", name: "", type: "uint64" }],
              stateMutability: "view",
              type: "function",
            },
          ]);
      },
      2802: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PublicResolverAbi = void 0),
          (t.PublicResolverAbi = [
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !0,
                  internalType: "bytes32",
                  name: "node",
                  type: "bytes32",
                },
                {
                  indexed: !1,
                  internalType: "address",
                  name: "a",
                  type: "address",
                },
              ],
              name: "AddrChanged",
              type: "event",
            },
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !0,
                  internalType: "bytes32",
                  name: "node",
                  type: "bytes32",
                },
                {
                  indexed: !1,
                  internalType: "uint256",
                  name: "coinType",
                  type: "uint256",
                },
                {
                  indexed: !1,
                  internalType: "bytes",
                  name: "newAddress",
                  type: "bytes",
                },
              ],
              name: "AddressChanged",
              type: "event",
            },
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !0,
                  internalType: "address",
                  name: "owner",
                  type: "address",
                },
                {
                  indexed: !0,
                  internalType: "address",
                  name: "operator",
                  type: "address",
                },
                {
                  indexed: !1,
                  internalType: "bool",
                  name: "approved",
                  type: "bool",
                },
              ],
              name: "ApprovalForAll",
              type: "event",
            },
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !0,
                  internalType: "bytes32",
                  name: "node",
                  type: "bytes32",
                },
                {
                  indexed: !1,
                  internalType: "bytes",
                  name: "hash",
                  type: "bytes",
                },
              ],
              name: "ContenthashChanged",
              type: "event",
            },
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !0,
                  internalType: "bytes32",
                  name: "node",
                  type: "bytes32",
                },
                {
                  indexed: !1,
                  internalType: "bytes",
                  name: "name",
                  type: "bytes",
                },
                {
                  indexed: !1,
                  internalType: "uint16",
                  name: "resource",
                  type: "uint16",
                },
                {
                  indexed: !1,
                  internalType: "bytes",
                  name: "record",
                  type: "bytes",
                },
              ],
              name: "DNSRecordChanged",
              type: "event",
            },
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !0,
                  internalType: "bytes32",
                  name: "node",
                  type: "bytes32",
                },
                {
                  indexed: !1,
                  internalType: "bytes",
                  name: "name",
                  type: "bytes",
                },
                {
                  indexed: !1,
                  internalType: "uint16",
                  name: "resource",
                  type: "uint16",
                },
              ],
              name: "DNSRecordDeleted",
              type: "event",
            },
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !0,
                  internalType: "bytes32",
                  name: "node",
                  type: "bytes32",
                },
              ],
              name: "DNSZoneCleared",
              type: "event",
            },
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !0,
                  internalType: "bytes32",
                  name: "node",
                  type: "bytes32",
                },
                {
                  indexed: !1,
                  internalType: "bytes",
                  name: "lastzonehash",
                  type: "bytes",
                },
                {
                  indexed: !1,
                  internalType: "bytes",
                  name: "zonehash",
                  type: "bytes",
                },
              ],
              name: "DNSZonehashChanged",
              type: "event",
            },
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !0,
                  internalType: "bytes32",
                  name: "node",
                  type: "bytes32",
                },
                {
                  indexed: !0,
                  internalType: "bytes4",
                  name: "interfaceID",
                  type: "bytes4",
                },
                {
                  indexed: !1,
                  internalType: "address",
                  name: "implementer",
                  type: "address",
                },
              ],
              name: "InterfaceChanged",
              type: "event",
            },
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !0,
                  internalType: "bytes32",
                  name: "node",
                  type: "bytes32",
                },
                {
                  indexed: !1,
                  internalType: "string",
                  name: "name",
                  type: "string",
                },
              ],
              name: "NameChanged",
              type: "event",
            },
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !0,
                  internalType: "bytes32",
                  name: "node",
                  type: "bytes32",
                },
                {
                  indexed: !1,
                  internalType: "bytes32",
                  name: "x",
                  type: "bytes32",
                },
                {
                  indexed: !1,
                  internalType: "bytes32",
                  name: "y",
                  type: "bytes32",
                },
              ],
              name: "PubkeyChanged",
              type: "event",
            },
            {
              anonymous: !1,
              inputs: [
                {
                  indexed: !0,
                  internalType: "bytes32",
                  name: "node",
                  type: "bytes32",
                },
                {
                  indexed: !0,
                  internalType: "string",
                  name: "indexedKey",
                  type: "string",
                },
                {
                  indexed: !1,
                  internalType: "string",
                  name: "key",
                  type: "string",
                },
              ],
              name: "TextChanged",
              type: "event",
            },
            {
              inputs: [
                { internalType: "bytes32", name: "node", type: "bytes32" },
                {
                  internalType: "uint256",
                  name: "contentTypes",
                  type: "uint256",
                },
              ],
              name: "ABI",
              outputs: [
                { internalType: "uint256", name: "", type: "uint256" },
                { internalType: "bytes", name: "", type: "bytes" },
              ],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [
                { internalType: "bytes32", name: "node", type: "bytes32" },
              ],
              name: "addr",
              outputs: [
                { internalType: "address payable", name: "", type: "address" },
              ],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [
                { internalType: "bytes32", name: "node", type: "bytes32" },
                { internalType: "uint256", name: "coinType", type: "uint256" },
              ],
              name: "addr",
              outputs: [{ internalType: "bytes", name: "", type: "bytes" }],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [
                { internalType: "bytes32", name: "node", type: "bytes32" },
              ],
              name: "contenthash",
              outputs: [{ internalType: "bytes", name: "", type: "bytes" }],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [
                { internalType: "bytes32", name: "node", type: "bytes32" },
                { internalType: "bytes32", name: "name", type: "bytes32" },
                { internalType: "uint16", name: "resource", type: "uint16" },
              ],
              name: "dnsRecord",
              outputs: [{ internalType: "bytes", name: "", type: "bytes" }],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [
                { internalType: "bytes32", name: "node", type: "bytes32" },
                { internalType: "bytes32", name: "name", type: "bytes32" },
              ],
              name: "hasDNSRecords",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [
                { internalType: "bytes32", name: "node", type: "bytes32" },
                { internalType: "bytes4", name: "interfaceID", type: "bytes4" },
              ],
              name: "interfaceImplementer",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [
                { internalType: "address", name: "account", type: "address" },
                { internalType: "address", name: "operator", type: "address" },
              ],
              name: "isApprovedForAll",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [
                { internalType: "bytes32", name: "node", type: "bytes32" },
              ],
              name: "name",
              outputs: [{ internalType: "string", name: "", type: "string" }],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [
                { internalType: "bytes32", name: "node", type: "bytes32" },
              ],
              name: "pubkey",
              outputs: [
                { internalType: "bytes32", name: "x", type: "bytes32" },
                { internalType: "bytes32", name: "y", type: "bytes32" },
              ],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [
                { internalType: "bytes4", name: "interfaceID", type: "bytes4" },
              ],
              name: "supportsInterface",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [
                { internalType: "bytes32", name: "node", type: "bytes32" },
                { internalType: "string", name: "key", type: "string" },
              ],
              name: "text",
              outputs: [{ internalType: "string", name: "", type: "string" }],
              stateMutability: "view",
              type: "function",
            },
            {
              inputs: [
                { internalType: "bytes32", name: "node", type: "bytes32" },
              ],
              name: "zonehash",
              outputs: [{ internalType: "bytes", name: "", type: "bytes" }],
              stateMutability: "view",
              type: "function",
            },
          ]);
      },
      4324: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.networkIds =
            t.registryAddresses =
            t.methodsInInterface =
            t.interfaceIds =
              void 0),
          (t.interfaceIds = {
            addr: "0x3b3b57de",
            name: "0x691f3431",
            abi: "0x2203ab56",
            pubkey: "0xc8690233",
            text: "0x59d1d43c",
            contenthash: "0xbc1c58d1",
          }),
          (t.methodsInInterface = {
            setAddr: "addr",
            addr: "addr",
            setPubkey: "pubkey",
            pubkey: "pubkey",
            setContenthash: "contenthash",
            contenthash: "contenthash",
          }),
          (t.registryAddresses = {
            main: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
            goerli: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
          }),
          (t.networkIds = { "0x1": "main", "0x5": "goerli" });
      },
      767: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__awaiter) ||
          function (e, t, r, n) {
            return new (r || (r = Promise))(function (i, s) {
              function o(e) {
                try {
                  c(n.next(e));
                } catch (e) {
                  s(e);
                }
              }
              function a(e) {
                try {
                  c(n.throw(e));
                } catch (e) {
                  s(e);
                }
              }
              function c(e) {
                var t;
                e.done
                  ? i(e.value)
                  : ((t = e.value),
                    t instanceof r
                      ? t
                      : new r(function (e) {
                          e(t);
                        })).then(o, a);
              }
              c((n = n.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }), (t.ENS = void 0);
        const i = r(8557),
          s = r(3087),
          o = r(6653),
          a = r(6714),
          c = r(2823),
          d = r(4324),
          u = r(2882),
          l = r(5208);
        class h extends i.Web3Context {
          constructor(e, t) {
            super(null != t ? t : ""),
              (this.registryAddress = null != e ? e : d.registryAddresses.main),
              (this._registry = new u.Registry(this.getContextObject(), e)),
              (this._resolver = new l.Resolver(this._registry));
          }
          getResolver(e) {
            return n(this, void 0, void 0, function* () {
              return this._registry.getResolver(e);
            });
          }
          recordExists(e) {
            return n(this, void 0, void 0, function* () {
              return this._registry.recordExists(e);
            });
          }
          getTTL(e) {
            return n(this, void 0, void 0, function* () {
              return this._registry.getTTL(e);
            });
          }
          getOwner(e) {
            return n(this, void 0, void 0, function* () {
              return this._registry.getOwner(e);
            });
          }
          getAddress(e, t = 60) {
            return n(this, void 0, void 0, function* () {
              return this._resolver.getAddress(e, t);
            });
          }
          getPubkey(e) {
            return n(this, void 0, void 0, function* () {
              return this._resolver.getPubkey(e);
            });
          }
          getContenthash(e) {
            return n(this, void 0, void 0, function* () {
              return this._resolver.getContenthash(e);
            });
          }
          checkNetwork() {
            return n(this, void 0, void 0, function* () {
              const e = Date.now() / 1e3;
              if (!this._lastSyncCheck || e - this._lastSyncCheck > 3600) {
                const t = yield (0, o.isSyncing)(this);
                if ("boolean" != typeof t || t)
                  throw new s.ENSNetworkNotSyncedError();
                this._lastSyncCheck = e;
              }
              if (this._detectedAddress) return this._detectedAddress;
              const t = yield (0, a.getId)(
                  this,
                  Object.assign(Object.assign({}, c.DEFAULT_RETURN_FORMAT), {
                    number: c.FMT_NUMBER.HEX,
                  }),
                ),
                r = d.registryAddresses[d.networkIds[t]];
              if (void 0 === r) throw new s.ENSUnsupportedNetworkError(t);
              return (this._detectedAddress = r), this._detectedAddress;
            });
          }
          supportsInterface(e, t) {
            return n(this, void 0, void 0, function* () {
              return this._resolver.supportsInterface(e, t);
            });
          }
          get events() {
            return this._registry.events;
          }
        }
        t.ENS = h;
      },
      5722: function (e, t, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (e, t, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(t, r);
                  (i &&
                    !("get" in i
                      ? !t.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return t[r];
                      },
                    }),
                    Object.defineProperty(e, n, i);
                }
              : function (e, t, r, n) {
                  void 0 === n && (n = r), (e[n] = t[r]);
                }),
          i =
            (this && this.__exportStar) ||
            function (e, t) {
              for (var r in e)
                "default" === r ||
                  Object.prototype.hasOwnProperty.call(t, r) ||
                  n(t, e, r);
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.registryAddresses = void 0);
        const s = r(4324);
        Object.defineProperty(t, "registryAddresses", {
          enumerable: !0,
          get: function () {
            return s.registryAddresses;
          },
        }),
          i(r(767), t);
      },
      2882: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__awaiter) ||
          function (e, t, r, n) {
            return new (r || (r = Promise))(function (i, s) {
              function o(e) {
                try {
                  c(n.next(e));
                } catch (e) {
                  s(e);
                }
              }
              function a(e) {
                try {
                  c(n.throw(e));
                } catch (e) {
                  s(e);
                }
              }
              function c(e) {
                var t;
                e.done
                  ? i(e.value)
                  : ((t = e.value),
                    t instanceof r
                      ? t
                      : new r(function (e) {
                          e(t);
                        })).then(o, a);
              }
              c((n = n.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Registry = void 0);
        const i = r(2290),
          s = r(1816),
          o = r(2802),
          a = r(4324),
          c = r(5064);
        t.Registry = class {
          constructor(e, t) {
            (this.contract = new i.Contract(
              s.ENSRegistryAbi,
              null != t ? t : a.registryAddresses.main,
              e,
            )),
              (this.context = e);
          }
          getOwner(e) {
            return n(this, void 0, void 0, function* () {
              try {
                return this.contract.methods.owner((0, c.namehash)(e)).call();
              } catch (e) {
                throw new Error();
              }
            });
          }
          getTTL(e) {
            return n(this, void 0, void 0, function* () {
              try {
                return this.contract.methods.ttl((0, c.namehash)(e)).call();
              } catch (e) {
                throw new Error();
              }
            });
          }
          recordExists(e) {
            return n(this, void 0, void 0, function* () {
              try {
                return this.contract.methods
                  .recordExists((0, c.namehash)(e))
                  .call();
              } catch (e) {
                throw new Error();
              }
            });
          }
          getResolver(e) {
            return n(this, void 0, void 0, function* () {
              try {
                return this.contract.methods
                  .resolver((0, c.namehash)(e))
                  .call()
                  .then((e) => {
                    if ("string" == typeof e)
                      return new i.Contract(
                        o.PublicResolverAbi,
                        e,
                        this.context,
                      );
                    throw new Error();
                  });
              } catch (e) {
                throw new Error();
              }
            });
          }
          get events() {
            return this.contract.events;
          }
        };
      },
      5208: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__awaiter) ||
          function (e, t, r, n) {
            return new (r || (r = Promise))(function (i, s) {
              function o(e) {
                try {
                  c(n.next(e));
                } catch (e) {
                  s(e);
                }
              }
              function a(e) {
                try {
                  c(n.throw(e));
                } catch (e) {
                  s(e);
                }
              }
              function c(e) {
                var t;
                e.done
                  ? i(e.value)
                  : ((t = e.value),
                    t instanceof r
                      ? t
                      : new r(function (e) {
                          e(t);
                        })).then(o, a);
              }
              c((n = n.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Resolver = void 0);
        const i = r(3087),
          s = r(9150),
          o = r(8840),
          a = r(4324),
          c = r(5064);
        t.Resolver = class {
          constructor(e) {
            this.registry = e;
          }
          getResolverContractAdapter(e) {
            return n(this, void 0, void 0, function* () {
              return this.registry.getResolver(e);
            });
          }
          checkInterfaceSupport(e, t) {
            var r, o;
            return n(this, void 0, void 0, function* () {
              if ((0, s.isNullish)(a.interfaceIds[t]))
                throw new i.ResolverMethodMissingError(
                  null !== (r = e.options.address) && void 0 !== r ? r : "",
                  t,
                );
              if (
                !(yield e.methods.supportsInterface(a.interfaceIds[t]).call())
              )
                throw new i.ResolverMethodMissingError(
                  null !== (o = e.options.address) && void 0 !== o ? o : "",
                  t,
                );
            });
          }
          supportsInterface(e, t) {
            var r;
            return n(this, void 0, void 0, function* () {
              const n = yield this.getResolverContractAdapter(e);
              let i = t;
              if (!(0, o.isHexStrict)(i)) {
                if (
                  ((i = null !== (r = (0, s.sha3)(t)) && void 0 !== r ? r : ""),
                  "" === t)
                )
                  throw new Error("Invalid interface Id");
                i = i.slice(0, 10);
              }
              return n.methods.supportsInterface(i).call();
            });
          }
          getAddress(e, t = 60) {
            return n(this, void 0, void 0, function* () {
              const r = yield this.getResolverContractAdapter(e);
              return (
                yield this.checkInterfaceSupport(r, a.methodsInInterface.addr),
                r.methods.addr((0, c.namehash)(e), t).call()
              );
            });
          }
          getPubkey(e) {
            return n(this, void 0, void 0, function* () {
              const t = yield this.getResolverContractAdapter(e);
              return (
                yield this.checkInterfaceSupport(
                  t,
                  a.methodsInInterface.pubkey,
                ),
                t.methods.pubkey((0, c.namehash)(e)).call()
              );
            });
          }
          getContenthash(e) {
            return n(this, void 0, void 0, function* () {
              const t = yield this.getResolverContractAdapter(e);
              return (
                yield this.checkInterfaceSupport(
                  t,
                  a.methodsInInterface.contenthash,
                ),
                t.methods.contenthash((0, c.namehash)(e)).call()
              );
            });
          }
        };
      },
      5064: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.namehash = t.normalize = void 0);
        const n = r(9150),
          i = r(30);
        (t.normalize = (e) => (0, i.ens_normalize)(e)),
          (t.namehash = (e) => {
            let r = "";
            for (let e = 0; e < 32; e += 1) r += "00";
            if (e) {
              const i = (0, t.normalize)(e).split(".");
              for (let e = i.length - 1; e >= 0; e -= 1) {
                const t = (0, n.sha3Raw)(i[e]).slice(2);
                r = (0, n.sha3Raw)(`0x${r}${t}`).slice(2);
              }
            }
            return `0x${r}`;
          });
      },
      2196: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Iban = void 0);
        const n = r(9150),
          i = r(8840),
          s = r(3087);
        class o {
          constructor(e) {
            if (
              ((this.toAddress = () => {
                if (this.isDirect()) {
                  const e = this._iban.slice(4),
                    t = o._parseInt(e, 36),
                    r = (0, n.leftPad)(t, 40);
                  return (0, n.toChecksumAddress)(r);
                }
                throw new Error(
                  "Iban is indirect and cannot be converted. Must be length of 34 or 35",
                );
              }),
              !o.isIndirect(e) && !o.isDirect(e))
            )
              throw new Error("Invalid IBAN was provided");
            this._iban = e;
          }
          static isDirect(e) {
            return 34 === e.length || 35 === e.length;
          }
          isDirect() {
            return o.isDirect(this._iban);
          }
          static isIndirect(e) {
            return 20 === e.length;
          }
          isIndirect() {
            return o.isIndirect(this._iban);
          }
          static isValid(e) {
            return (
              /^XE[0-9]{2}(ETH[0-9A-Z]{13}|[0-9A-Z]{30,31})$/.test(e) &&
              1 === o._mod9710(o._iso13616Prepare(e))
            );
          }
          isValid() {
            return o.isValid(this._iban);
          }
          static fromBban(e) {
            const t = `0${(
              98 - this._mod9710(this._iso13616Prepare(`XE00${e}`))
            ).toString()}`.slice(-2);
            return new o(`XE${t}${e}`);
          }
          static createIndirect(e) {
            return o.fromBban(`ETH${e.institution}${e.identifier}`);
          }
          static fromAddress(e) {
            if (!(0, i.isAddress)(e)) throw new s.InvalidAddressError(e);
            const t = BigInt((0, n.hexToNumber)(e)).toString(36),
              r = (0, n.leftPad)(t, 15);
            return o.fromBban(r.toUpperCase());
          }
          static toIban(e) {
            return o.fromAddress(e).toString();
          }
          client() {
            return this.isIndirect() ? this._iban.slice(11) : "";
          }
          checksum() {
            return this._iban.slice(2, 4);
          }
          institution() {
            return this.isIndirect() ? this._iban.slice(7, 11) : "";
          }
          toString() {
            return this._iban;
          }
        }
        (t.Iban = o),
          (o._iso13616Prepare = (e) => {
            const t = "A".charCodeAt(0),
              r = "Z".charCodeAt(0),
              n = e.toUpperCase();
            return `${n.slice(4)}${n.slice(0, 4)}`
              .split("")
              .map((e) => {
                const n = e.charCodeAt(0);
                return n >= t && n <= r ? n - t + 10 : e;
              })
              .join("");
          }),
          (o._parseInt = (e, t) =>
            [...e].reduce(
              (e, r) => BigInt(parseInt(r, t)) + BigInt(t) * e,
              BigInt(0),
            )),
          (o._mod9710 = (e) => {
            let t,
              r = e;
            for (; r.length > 2; )
              (t = r.slice(0, 9)),
                (r = `${(parseInt(t, 10) % 97).toString()}${r.slice(
                  t.length,
                )}`);
            return parseInt(r, 10) % 97;
          }),
          (o.toAddress = (e) => new o(e).toAddress());
      },
      2235: function (e, t, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (e, t, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(t, r);
                  (i &&
                    !("get" in i
                      ? !t.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return t[r];
                      },
                    }),
                    Object.defineProperty(e, n, i);
                }
              : function (e, t, r, n) {
                  void 0 === n && (n = r), (e[n] = t[r]);
                }),
          i =
            (this && this.__exportStar) ||
            function (e, t) {
              for (var r in e)
                "default" === r ||
                  Object.prototype.hasOwnProperty.call(t, r) ||
                  n(t, e, r);
            };
        Object.defineProperty(t, "__esModule", { value: !0 });
        const s = r(2196);
        i(r(2196), t), i(r(7133), t), (t.default = s.Iban);
      },
      7133: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
      },
      8898: function (e, t, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (e, t, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(t, r);
                  (i &&
                    !("get" in i
                      ? !t.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return t[r];
                      },
                    }),
                    Object.defineProperty(e, n, i);
                }
              : function (e, t, r, n) {
                  void 0 === n && (n = r), (e[n] = t[r]);
                }),
          i =
            (this && this.__exportStar) ||
            function (e, t) {
              for (var r in e)
                "default" === r ||
                  Object.prototype.hasOwnProperty.call(t, r) ||
                  n(t, e, r);
            };
        Object.defineProperty(t, "__esModule", { value: !0 });
        const s = r(2504);
        i(r(2504), t), (t.default = s.Personal);
      },
      2504: function (e, t, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (e, t, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(t, r);
                  (i &&
                    !("get" in i
                      ? !t.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return t[r];
                      },
                    }),
                    Object.defineProperty(e, n, i);
                }
              : function (e, t, r, n) {
                  void 0 === n && (n = r), (e[n] = t[r]);
                }),
          i =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (e, t) {
                  Object.defineProperty(e, "default", {
                    enumerable: !0,
                    value: t,
                  });
                }
              : function (e, t) {
                  e.default = t;
                }),
          s =
            (this && this.__importStar) ||
            function (e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(e, r) &&
                    n(t, e, r);
              return i(t, e), t;
            },
          o =
            (this && this.__awaiter) ||
            function (e, t, r, n) {
              return new (r || (r = Promise))(function (i, s) {
                function o(e) {
                  try {
                    c(n.next(e));
                  } catch (e) {
                    s(e);
                  }
                }
                function a(e) {
                  try {
                    c(n.throw(e));
                  } catch (e) {
                    s(e);
                  }
                }
                function c(e) {
                  var t;
                  e.done
                    ? i(e.value)
                    : ((t = e.value),
                      t instanceof r
                        ? t
                        : new r(function (e) {
                            e(t);
                          })).then(o, a);
                }
                c((n = n.apply(e, t || [])).next());
              });
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Personal = void 0);
        const a = r(8557),
          c = s(r(2858));
        class d extends a.Web3Context {
          getAccounts() {
            return o(this, void 0, void 0, function* () {
              return c.getAccounts(this.requestManager);
            });
          }
          newAccount(e) {
            return o(this, void 0, void 0, function* () {
              return c.newAccount(this.requestManager, e);
            });
          }
          unlockAccount(e, t, r) {
            return o(this, void 0, void 0, function* () {
              return c.unlockAccount(this.requestManager, e, t, r);
            });
          }
          lockAccount(e) {
            return o(this, void 0, void 0, function* () {
              return c.lockAccount(this.requestManager, e);
            });
          }
          importRawKey(e, t) {
            return o(this, void 0, void 0, function* () {
              return c.importRawKey(this.requestManager, e, t);
            });
          }
          sendTransaction(e, t) {
            return o(this, void 0, void 0, function* () {
              return c.sendTransaction(this.requestManager, e, t);
            });
          }
          signTransaction(e, t) {
            return o(this, void 0, void 0, function* () {
              return c.signTransaction(this.requestManager, e, t);
            });
          }
          sign(e, t, r) {
            return o(this, void 0, void 0, function* () {
              return c.sign(this.requestManager, e, t, r);
            });
          }
          ecRecover(e, t) {
            return o(this, void 0, void 0, function* () {
              return c.ecRecover(this.requestManager, e, t);
            });
          }
        }
        t.Personal = d;
      },
      2858: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__awaiter) ||
          function (e, t, r, n) {
            return new (r || (r = Promise))(function (i, s) {
              function o(e) {
                try {
                  c(n.next(e));
                } catch (e) {
                  s(e);
                }
              }
              function a(e) {
                try {
                  c(n.throw(e));
                } catch (e) {
                  s(e);
                }
              }
              function c(e) {
                var t;
                e.done
                  ? i(e.value)
                  : ((t = e.value),
                    t instanceof r
                      ? t
                      : new r(function (e) {
                          e(t);
                        })).then(o, a);
              }
              c((n = n.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ecRecover =
            t.sign =
            t.signTransaction =
            t.sendTransaction =
            t.importRawKey =
            t.lockAccount =
            t.unlockAccount =
            t.newAccount =
            t.getAccounts =
              void 0);
        const i = r(9150),
          s = r(6653),
          o = r(2823),
          a = r(8840),
          c = r(100);
        (t.getAccounts = (e) =>
          n(void 0, void 0, void 0, function* () {
            return (yield c.personalRpcMethods.getAccounts(e)).map(
              i.toChecksumAddress,
            );
          })),
          (t.newAccount = (e, t) =>
            n(void 0, void 0, void 0, function* () {
              a.validator.validate(["string"], [t]);
              const r = yield c.personalRpcMethods.newAccount(e, t);
              return (0, i.toChecksumAddress)(r);
            })),
          (t.unlockAccount = (e, t, r, i) =>
            n(void 0, void 0, void 0, function* () {
              return (
                a.validator.validate(["address", "string", "uint"], [t, r, i]),
                c.personalRpcMethods.unlockAccount(e, t, r, i)
              );
            })),
          (t.lockAccount = (e, t) =>
            n(void 0, void 0, void 0, function* () {
              return (
                a.validator.validate(["address"], [t]),
                c.personalRpcMethods.lockAccount(e, t)
              );
            })),
          (t.importRawKey = (e, t, r) =>
            n(void 0, void 0, void 0, function* () {
              return (
                a.validator.validate(["string", "string"], [t, r]),
                c.personalRpcMethods.importRawKey(e, t, r)
              );
            })),
          (t.sendTransaction = (e, t, r) =>
            n(void 0, void 0, void 0, function* () {
              const n = (0, s.formatTransaction)(t, o.ETH_DATA_FORMAT);
              return c.personalRpcMethods.sendTransaction(e, n, r);
            })),
          (t.signTransaction = (e, t, r) =>
            n(void 0, void 0, void 0, function* () {
              const n = (0, s.formatTransaction)(t, o.ETH_DATA_FORMAT);
              return c.personalRpcMethods.signTransaction(e, n, r);
            })),
          (t.sign = (e, t, r, s) =>
            n(void 0, void 0, void 0, function* () {
              a.validator.validate(["string", "address", "string"], [t, r, s]);
              const n = (0, a.isHexStrict)(t) ? t : (0, i.utf8ToHex)(t);
              return c.personalRpcMethods.sign(e, n, r, s);
            })),
          (t.ecRecover = (e, t, r) =>
            n(void 0, void 0, void 0, function* () {
              a.validator.validate(["string", "string"], [t, r]);
              const n = (0, a.isHexStrict)(t) ? t : (0, i.utf8ToHex)(t);
              return c.personalRpcMethods.ecRecover(e, n, r);
            }));
      },
      1929: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.NUMBER_DATA_FORMAT = void 0);
        const n = r(2823);
        t.NUMBER_DATA_FORMAT = {
          bytes: n.FMT_BYTES.HEX,
          number: n.FMT_NUMBER.NUMBER,
        };
      },
      6653: function (e, t, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (e, t, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(t, r);
                  (i &&
                    !("get" in i
                      ? !t.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return t[r];
                      },
                    }),
                    Object.defineProperty(e, n, i);
                }
              : function (e, t, r, n) {
                  void 0 === n && (n = r), (e[n] = t[r]);
                }),
          i =
            (this && this.__exportStar) ||
            function (e, t) {
              for (var r in e)
                "default" === r ||
                  Object.prototype.hasOwnProperty.call(t, r) ||
                  n(t, e, r);
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.transactionBuilder = t.detectTransactionType = void 0),
          r(4889);
        const s = r(6160);
        i(r(6160), t),
          i(r(5127), t),
          i(r(3321), t),
          i(r(4027), t),
          i(r(8829), t),
          i(r(7588), t),
          i(r(6522), t),
          i(r(4156), t);
        var o = r(6484);
        Object.defineProperty(t, "detectTransactionType", {
          enumerable: !0,
          get: function () {
            return o.detectTransactionType;
          },
        });
        var a = r(5228);
        Object.defineProperty(t, "transactionBuilder", {
          enumerable: !0,
          get: function () {
            return a.transactionBuilder;
          },
        }),
          (t.default = s.Web3Eth);
      },
      8829: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__awaiter) ||
          function (e, t, r, n) {
            return new (r || (r = Promise))(function (i, s) {
              function o(e) {
                try {
                  c(n.next(e));
                } catch (e) {
                  s(e);
                }
              }
              function a(e) {
                try {
                  c(n.throw(e));
                } catch (e) {
                  s(e);
                }
              }
              function c(e) {
                var t;
                e.done
                  ? i(e.value)
                  : ((t = e.value),
                    t instanceof r
                      ? t
                      : new r(function (e) {
                          e(t);
                        })).then(o, a);
              }
              c((n = n.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.signTypedData =
            t.createAccessList =
            t.getFeeHistory =
            t.getProof =
            t.getChainId =
            t.getLogs =
            t.estimateGas =
            t.call =
            t.signTransaction =
            t.sign =
            t.sendSignedTransaction =
            t.sendTransaction =
            t.getTransactionCount =
            t.getTransactionReceipt =
            t.getTransactionFromBlock =
            t.getPendingTransactions =
            t.getTransaction =
            t.getUncle =
            t.getBlockUncleCount =
            t.getBlockTransactionCount =
            t.getBlock =
            t.getCode =
            t.getStorageAt =
            t.getBalance =
            t.getBlockNumber =
            t.getGasPrice =
            t.getHashRate =
            t.isMining =
            t.getCoinbase =
            t.isSyncing =
            t.getProtocolVersion =
              void 0);
        const i = r(2823),
          s = r(8557),
          o = r(9150),
          a = r(4464),
          c = r(8840),
          d = r(3087),
          u = r(100),
          l = r(1278),
          h = r(5127),
          f = r(5228),
          p = r(7588),
          m = r(4022),
          y = r(3540),
          g = r(3907),
          v = r(98),
          b = r(1929),
          w = r(6005),
          E = r(4230);
        (t.getProtocolVersion = (e) =>
          n(void 0, void 0, void 0, function* () {
            return u.ethRpcMethods.getProtocolVersion(e.requestManager);
          })),
          (t.isSyncing = (e) =>
            n(void 0, void 0, void 0, function* () {
              return u.ethRpcMethods.getSyncing(e.requestManager);
            })),
          (t.getCoinbase = (e) =>
            n(void 0, void 0, void 0, function* () {
              return u.ethRpcMethods.getCoinbase(e.requestManager);
            })),
          (t.isMining = (e) =>
            n(void 0, void 0, void 0, function* () {
              return u.ethRpcMethods.getMining(e.requestManager);
            })),
          (t.getHashRate = function (e, t) {
            return n(this, void 0, void 0, function* () {
              const r = yield u.ethRpcMethods.getHashRate(e.requestManager);
              return (0, o.format)({ format: "uint" }, r, t);
            });
          }),
          (t.getGasPrice = function (e, t) {
            return n(this, void 0, void 0, function* () {
              const r = yield u.ethRpcMethods.getGasPrice(e.requestManager);
              return (0, o.format)({ format: "uint" }, r, t);
            });
          }),
          (t.getBlockNumber = function (e, t) {
            return n(this, void 0, void 0, function* () {
              const r = yield u.ethRpcMethods.getBlockNumber(e.requestManager);
              return (0, o.format)({ format: "uint" }, r, t);
            });
          }),
          (t.getBalance = function (e, t, r = e.defaultBlock, s) {
            return n(this, void 0, void 0, function* () {
              const n = (0, c.isBlockTag)(r)
                  ? r
                  : (0, o.format)({ format: "uint" }, r, i.ETH_DATA_FORMAT),
                a = yield u.ethRpcMethods.getBalance(e.requestManager, t, n);
              return (0, o.format)({ format: "uint" }, a, s);
            });
          }),
          (t.getStorageAt = function (e, t, r, s = e.defaultBlock, a) {
            return n(this, void 0, void 0, function* () {
              const n = (0, o.format)({ format: "uint" }, r, i.ETH_DATA_FORMAT),
                d = (0, c.isBlockTag)(s)
                  ? s
                  : (0, o.format)({ format: "uint" }, s, i.ETH_DATA_FORMAT),
                l = yield u.ethRpcMethods.getStorageAt(
                  e.requestManager,
                  t,
                  n,
                  d,
                );
              return (0, o.format)({ format: "bytes" }, l, a);
            });
          }),
          (t.getCode = function (e, t, r = e.defaultBlock, s) {
            return n(this, void 0, void 0, function* () {
              const n = (0, c.isBlockTag)(r)
                  ? r
                  : (0, o.format)({ format: "uint" }, r, i.ETH_DATA_FORMAT),
                a = yield u.ethRpcMethods.getCode(e.requestManager, t, n);
              return (0, o.format)({ format: "bytes" }, a, s);
            });
          }),
          (t.getBlock = function (e, t = e.defaultBlock, r = !1, s) {
            return n(this, void 0, void 0, function* () {
              let n;
              if ((0, c.isBytes)(t)) {
                const s = (0, o.format)(
                  { format: "bytes32" },
                  t,
                  i.ETH_DATA_FORMAT,
                );
                n = yield u.ethRpcMethods.getBlockByHash(
                  e.requestManager,
                  s,
                  r,
                );
              } else {
                const s = (0, c.isBlockTag)(t)
                  ? t
                  : (0, o.format)({ format: "uint" }, t, i.ETH_DATA_FORMAT);
                n = yield u.ethRpcMethods.getBlockByNumber(
                  e.requestManager,
                  s,
                  r,
                );
              }
              return (0, o.format)(h.blockSchema, n, s);
            });
          }),
          (t.getBlockTransactionCount = function (e, t = e.defaultBlock, r) {
            return n(this, void 0, void 0, function* () {
              let n;
              if ((0, c.isBytes)(t)) {
                const r = (0, o.format)(
                  { format: "bytes32" },
                  t,
                  i.ETH_DATA_FORMAT,
                );
                n = yield u.ethRpcMethods.getBlockTransactionCountByHash(
                  e.requestManager,
                  r,
                );
              } else {
                const r = (0, c.isBlockTag)(t)
                  ? t
                  : (0, o.format)({ format: "uint" }, t, i.ETH_DATA_FORMAT);
                n = yield u.ethRpcMethods.getBlockTransactionCountByNumber(
                  e.requestManager,
                  r,
                );
              }
              return (0, o.format)({ format: "uint" }, n, r);
            });
          }),
          (t.getBlockUncleCount = function (e, t = e.defaultBlock, r) {
            return n(this, void 0, void 0, function* () {
              let n;
              if ((0, c.isBytes)(t)) {
                const r = (0, o.format)(
                  { format: "bytes32" },
                  t,
                  i.ETH_DATA_FORMAT,
                );
                n = yield u.ethRpcMethods.getUncleCountByBlockHash(
                  e.requestManager,
                  r,
                );
              } else {
                const r = (0, c.isBlockTag)(t)
                  ? t
                  : (0, o.format)({ format: "uint" }, t, i.ETH_DATA_FORMAT);
                n = yield u.ethRpcMethods.getUncleCountByBlockNumber(
                  e.requestManager,
                  r,
                );
              }
              return (0, o.format)({ format: "uint" }, n, r);
            });
          }),
          (t.getUncle = function (e, t = e.defaultBlock, r, s) {
            return n(this, void 0, void 0, function* () {
              const n = (0, o.format)({ format: "uint" }, r, i.ETH_DATA_FORMAT);
              let a;
              if ((0, c.isBytes)(t)) {
                const r = (0, o.format)(
                  { format: "bytes32" },
                  t,
                  i.ETH_DATA_FORMAT,
                );
                a = yield u.ethRpcMethods.getUncleByBlockHashAndIndex(
                  e.requestManager,
                  r,
                  n,
                );
              } else {
                const r = (0, c.isBlockTag)(t)
                  ? t
                  : (0, o.format)({ format: "uint" }, t, i.ETH_DATA_FORMAT);
                a = yield u.ethRpcMethods.getUncleByBlockNumberAndIndex(
                  e.requestManager,
                  r,
                  n,
                );
              }
              return (0, o.format)(h.blockSchema, a, s);
            });
          }),
          (t.getTransaction = function (e, t, r) {
            return n(this, void 0, void 0, function* () {
              const n = (0, o.format)(
                  { format: "bytes32" },
                  t,
                  i.DEFAULT_RETURN_FORMAT,
                ),
                s = yield u.ethRpcMethods.getTransactionByHash(
                  e.requestManager,
                  n,
                );
              return (0, c.isNullish)(s)
                ? s
                : (0, p.formatTransaction)(s, r, { fillInputAndData: !0 });
            });
          }),
          (t.getPendingTransactions = function (e, t) {
            return n(this, void 0, void 0, function* () {
              return (yield u.ethRpcMethods.getPendingTransactions(
                e.requestManager,
              )).map((e) =>
                (0, p.formatTransaction)(e, t, { fillInputAndData: !0 }),
              );
            });
          }),
          (t.getTransactionFromBlock = function (e, t = e.defaultBlock, r, s) {
            return n(this, void 0, void 0, function* () {
              const n = (0, o.format)({ format: "uint" }, r, i.ETH_DATA_FORMAT);
              let a;
              if ((0, c.isBytes)(t)) {
                const r = (0, o.format)(
                  { format: "bytes32" },
                  t,
                  i.ETH_DATA_FORMAT,
                );
                a = yield u.ethRpcMethods.getTransactionByBlockHashAndIndex(
                  e.requestManager,
                  r,
                  n,
                );
              } else {
                const r = (0, c.isBlockTag)(t)
                  ? t
                  : (0, o.format)({ format: "uint" }, t, i.ETH_DATA_FORMAT);
                a = yield u.ethRpcMethods.getTransactionByBlockNumberAndIndex(
                  e.requestManager,
                  r,
                  n,
                );
              }
              return (0, c.isNullish)(a)
                ? a
                : (0, p.formatTransaction)(a, s, { fillInputAndData: !0 });
            });
          }),
          (t.getTransactionReceipt = function (e, t, r) {
            return n(this, void 0, void 0, function* () {
              const n = (0, o.format)(
                  { format: "bytes32" },
                  t,
                  i.DEFAULT_RETURN_FORMAT,
                ),
                s = yield u.ethRpcMethods.getTransactionReceipt(
                  e.requestManager,
                  n,
                );
              return (0, c.isNullish)(s)
                ? s
                : (0, o.format)(h.transactionReceiptSchema, s, r);
            });
          }),
          (t.getTransactionCount = function (e, t, r = e.defaultBlock, s) {
            return n(this, void 0, void 0, function* () {
              const n = (0, c.isBlockTag)(r)
                  ? r
                  : (0, o.format)({ format: "uint" }, r, i.ETH_DATA_FORMAT),
                a = yield u.ethRpcMethods.getTransactionCount(
                  e.requestManager,
                  t,
                  n,
                );
              return (0, o.format)({ format: "uint" }, a, s);
            });
          }),
          (t.sendTransaction = function (
            e,
            t,
            r,
            a = { checkRevertBeforeSending: !0 },
          ) {
            const l = new s.Web3PromiEvent((s, b) => {
              setImmediate(() => {
                (() => {
                  n(this, void 0, void 0, function* () {
                    let A = (0, p.formatTransaction)(
                      Object.assign(Object.assign({}, t), {
                        from: (0, f.getTransactionFromOrToAttr)("from", e, t),
                        to: (0, f.getTransactionFromOrToAttr)("to", e, t),
                      }),
                      i.ETH_DATA_FORMAT,
                    );
                    !(null == a ? void 0 : a.ignoreGasPricing) &&
                      (0, c.isNullish)(A.gasPrice) &&
                      ((0, c.isNullish)(t.maxPriorityFeePerGas) ||
                        (0, c.isNullish)(t.maxFeePerGas)) &&
                      (A = Object.assign(
                        Object.assign({}, A),
                        yield (0, m.getTransactionGasPricing)(
                          A,
                          e,
                          i.ETH_DATA_FORMAT,
                        ),
                      ));
                    try {
                      if (!1 !== a.checkRevertBeforeSending) {
                        const t = yield (0, E.getRevertReason)(
                          e,
                          A,
                          a.contractAbi,
                        );
                        if (void 0 !== t) {
                          const r = yield (0, w.getTransactionError)(
                            e,
                            A,
                            void 0,
                            void 0,
                            a.contractAbi,
                            t,
                          );
                          return (
                            l.listenerCount("error") > 0 && l.emit("error", r),
                            void b(r)
                          );
                        }
                      }
                      let t, i;
                      if (
                        (l.listenerCount("sending") > 0 && l.emit("sending", A),
                        e.wallet &&
                          !(0, c.isNullish)(A.from) &&
                          (i = e.wallet.get(A.from)),
                        i)
                      ) {
                        const r = yield i.signTransaction(A);
                        t = yield (0, y.trySendTransaction)(
                          e,
                          () =>
                            n(this, void 0, void 0, function* () {
                              return u.ethRpcMethods.sendRawTransaction(
                                e.requestManager,
                                r.rawTransaction,
                              );
                            }),
                          r.transactionHash,
                        );
                      } else
                        t = yield (0, y.trySendTransaction)(e, () =>
                          n(this, void 0, void 0, function* () {
                            return u.ethRpcMethods.sendTransaction(
                              e.requestManager,
                              A,
                            );
                          }),
                        );
                      const d = (0, o.format)({ format: "bytes32" }, t, r);
                      l.listenerCount("sent") > 0 && l.emit("sent", A),
                        l.listenerCount("transactionHash") > 0 &&
                          l.emit("transactionHash", d);
                      const f = yield (0, g.waitForTransactionReceipt)(e, t, r),
                        p = (0, o.format)(h.transactionReceiptSchema, f, r);
                      if (
                        (l.listenerCount("receipt") > 0 && l.emit("receipt", p),
                        null == a ? void 0 : a.transactionResolver)
                      )
                        s(null == a ? void 0 : a.transactionResolver(p));
                      else if (f.status === BigInt(0)) {
                        const t = yield (0, w.getTransactionError)(
                          e,
                          A,
                          p,
                          void 0,
                          null == a ? void 0 : a.contractAbi,
                        );
                        l.listenerCount("error") > 0 && l.emit("error", t),
                          b(t);
                      } else s(p);
                      l.listenerCount("confirmation") > 0 &&
                        (0, v.watchTransactionForConfirmations)(e, l, p, t, r);
                    } catch (t) {
                      let r = t;
                      r instanceof d.ContractExecutionError &&
                        e.handleRevert &&
                        (r = yield (0, w.getTransactionError)(
                          e,
                          A,
                          void 0,
                          void 0,
                          null == a ? void 0 : a.contractAbi,
                        )),
                        (r instanceof d.InvalidResponseError ||
                          r instanceof d.ContractExecutionError ||
                          r instanceof d.TransactionRevertWithCustomError ||
                          r instanceof
                            d.TransactionRevertedWithoutReasonError ||
                          r instanceof d.TransactionRevertInstructionError) &&
                          l.listenerCount("error") > 0 &&
                          l.emit("error", r),
                        b(r);
                    }
                  });
                })();
              });
            });
            return l;
          }),
          (t.sendSignedTransaction = function (
            e,
            t,
            r,
            c = { checkRevertBeforeSending: !0 },
          ) {
            const l = new s.Web3PromiEvent((s, f) => {
              setImmediate(() => {
                (() => {
                  n(this, void 0, void 0, function* () {
                    const p = (0, o.format)(
                        { format: "bytes" },
                        t,
                        i.ETH_DATA_FORMAT,
                      ),
                      m = a.TransactionFactory.fromSerializedData(
                        (0, o.bytesToUint8Array)((0, o.hexToBytes)(p)),
                      ),
                      b = Object.assign(Object.assign({}, m.toJSON()), {
                        from: m.getSenderAddress().toString(),
                      });
                    try {
                      if (!1 !== c.checkRevertBeforeSending) {
                        const t = yield (0, E.getRevertReason)(
                          e,
                          b,
                          c.contractAbi,
                        );
                        if (void 0 !== t) {
                          const r = yield (0, w.getTransactionError)(
                            e,
                            b,
                            void 0,
                            void 0,
                            c.contractAbi,
                            t,
                          );
                          return (
                            l.listenerCount("error") > 0 && l.emit("error", r),
                            void f(r)
                          );
                        }
                      }
                      l.listenerCount("sending") > 0 && l.emit("sending", p);
                      const t = yield (0, y.trySendTransaction)(e, () =>
                        n(this, void 0, void 0, function* () {
                          return u.ethRpcMethods.sendRawTransaction(
                            e.requestManager,
                            p,
                          );
                        }),
                      );
                      l.listenerCount("sent") > 0 && l.emit("sent", p);
                      const i = (0, o.format)({ format: "bytes32" }, t, r);
                      l.listenerCount("transactionHash") > 0 &&
                        l.emit("transactionHash", i);
                      const a = yield (0, g.waitForTransactionReceipt)(e, t, r),
                        d = (0, o.format)(h.transactionReceiptSchema, a, r);
                      if (
                        (l.listenerCount("receipt") > 0 && l.emit("receipt", d),
                        null == c ? void 0 : c.transactionResolver)
                      )
                        s(null == c ? void 0 : c.transactionResolver(d));
                      else if (a.status === BigInt(0)) {
                        const t = yield (0, w.getTransactionError)(
                          e,
                          b,
                          d,
                          void 0,
                          null == c ? void 0 : c.contractAbi,
                        );
                        l.listenerCount("error") > 0 && l.emit("error", t),
                          f(t);
                      } else s(d);
                      l.listenerCount("confirmation") > 0 &&
                        (0, v.watchTransactionForConfirmations)(e, l, d, t, r);
                    } catch (t) {
                      let r = t;
                      r instanceof d.ContractExecutionError &&
                        e.handleRevert &&
                        (r = yield (0, w.getTransactionError)(
                          e,
                          b,
                          void 0,
                          void 0,
                          null == c ? void 0 : c.contractAbi,
                        )),
                        (r instanceof d.InvalidResponseError ||
                          r instanceof d.ContractExecutionError ||
                          r instanceof d.TransactionRevertWithCustomError ||
                          r instanceof
                            d.TransactionRevertedWithoutReasonError ||
                          r instanceof d.TransactionRevertInstructionError) &&
                          l.listenerCount("error") > 0 &&
                          l.emit("error", r),
                        f(r);
                    }
                  });
                })();
              });
            });
            return l;
          }),
          (t.sign = function (e, t, r, s) {
            var a;
            return n(this, void 0, void 0, function* () {
              const n = (0, o.format)(
                { format: "bytes" },
                t,
                i.DEFAULT_RETURN_FORMAT,
              );
              if (null === (a = e.wallet) || void 0 === a ? void 0 : a.get(r)) {
                const t = e.wallet.get(r).sign(n);
                return (0, o.format)(h.SignatureObjectSchema, t, s);
              }
              if ("number" == typeof r)
                throw new d.SignatureError(
                  t,
                  'RPC method "eth_sign" does not support index signatures',
                );
              const c = yield u.ethRpcMethods.sign(e.requestManager, r, n);
              return (0, o.format)({ format: "bytes" }, c, s);
            });
          }),
          (t.signTransaction = function (e, t, r) {
            return n(this, void 0, void 0, function* () {
              const n = yield u.ethRpcMethods.signTransaction(
                e.requestManager,
                (0, p.formatTransaction)(t, i.ETH_DATA_FORMAT),
              );
              return (0, c.isString)(n)
                ? (0, l.decodeSignedTransaction)(n, r, { fillInputAndData: !0 })
                : {
                    raw: (0, o.format)({ format: "bytes" }, n.raw, r),
                    tx: (0, p.formatTransaction)(n.tx, r, {
                      fillInputAndData: !0,
                    }),
                  };
            });
          }),
          (t.call = function (e, t, r = e.defaultBlock, s) {
            return n(this, void 0, void 0, function* () {
              const n = (0, c.isBlockTag)(r)
                  ? r
                  : (0, o.format)({ format: "uint" }, r, i.ETH_DATA_FORMAT),
                a = yield u.ethRpcMethods.call(
                  e.requestManager,
                  (0, p.formatTransaction)(t, i.ETH_DATA_FORMAT),
                  n,
                );
              return (0, o.format)({ format: "bytes" }, a, s);
            });
          }),
          (t.estimateGas = function (e, t, r = e.defaultBlock, s) {
            return n(this, void 0, void 0, function* () {
              const n = (0, p.formatTransaction)(t, i.ETH_DATA_FORMAT),
                a = (0, c.isBlockTag)(r)
                  ? r
                  : (0, o.format)({ format: "uint" }, r, i.ETH_DATA_FORMAT),
                d = yield u.ethRpcMethods.estimateGas(e.requestManager, n, a);
              return (0, o.format)({ format: "uint" }, d, s);
            });
          }),
          (t.getLogs = function (e, t, r) {
            return n(this, void 0, void 0, function* () {
              let { toBlock: n, fromBlock: i } = t;
              (0, c.isNullish)(n) ||
                ("number" != typeof n && "bigint" != typeof n) ||
                (n = (0, o.numberToHex)(n)),
                (0, c.isNullish)(i) ||
                  ("number" != typeof i && "bigint" != typeof i) ||
                  (i = (0, o.numberToHex)(i));
              const s = Object.assign(Object.assign({}, t), {
                fromBlock: i,
                toBlock: n,
              });
              return (yield u.ethRpcMethods.getLogs(e.requestManager, s)).map(
                (e) =>
                  "string" == typeof e ? e : (0, o.format)(h.logSchema, e, r),
              );
            });
          }),
          (t.getChainId = function (e, t) {
            return n(this, void 0, void 0, function* () {
              const r = yield u.ethRpcMethods.getChainId(e.requestManager);
              return (0, o.format)({ format: "uint" }, r, t);
            });
          }),
          (t.getProof = function (e, t, r, s = e.defaultBlock, a) {
            return n(this, void 0, void 0, function* () {
              const n = r.map((e) =>
                  (0, o.format)({ format: "bytes" }, e, i.ETH_DATA_FORMAT),
                ),
                d = (0, c.isBlockTag)(s)
                  ? s
                  : (0, o.format)({ format: "uint" }, s, i.ETH_DATA_FORMAT),
                l = yield u.ethRpcMethods.getProof(e.requestManager, t, n, d);
              return (0, o.format)(h.accountSchema, l, a);
            });
          }),
          (t.getFeeHistory = function (e, t, r = e.defaultBlock, s, a) {
            return n(this, void 0, void 0, function* () {
              const n = (0, o.format)({ format: "uint" }, t, i.ETH_DATA_FORMAT),
                d = (0, c.isBlockTag)(r)
                  ? r
                  : (0, o.format)({ format: "uint" }, r, i.ETH_DATA_FORMAT),
                l = (0, o.format)(
                  { type: "array", items: { format: "uint" } },
                  s,
                  b.NUMBER_DATA_FORMAT,
                ),
                f = yield u.ethRpcMethods.getFeeHistory(
                  e.requestManager,
                  n,
                  d,
                  l,
                );
              return (0, o.format)(h.feeHistorySchema, f, a);
            });
          }),
          (t.createAccessList = function (e, t, r = e.defaultBlock, s) {
            return n(this, void 0, void 0, function* () {
              const n = (0, c.isBlockTag)(r)
                  ? r
                  : (0, o.format)({ format: "uint" }, r, i.ETH_DATA_FORMAT),
                a = yield u.ethRpcMethods.createAccessList(
                  e.requestManager,
                  (0, p.formatTransaction)(t, i.ETH_DATA_FORMAT),
                  n,
                );
              return (0, o.format)(h.accessListResultSchema, a, s);
            });
          }),
          (t.signTypedData = function (e, t, r, i, s) {
            return n(this, void 0, void 0, function* () {
              const n = yield u.ethRpcMethods.signTypedData(
                e.requestManager,
                t,
                r,
                i,
              );
              return (0, o.format)({ format: "bytes" }, n, s);
            });
          });
      },
      5127: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.accountSchema =
            t.storageProofSchema =
            t.feeHistorySchema =
            t.SignatureObjectSchema =
            t.transactionReceiptSchema =
            t.syncSchema =
            t.logSchema =
            t.blockHeaderSchema =
            t.withdrawalsSchema =
            t.blockSchema =
            t.transactionInfoSchema =
            t.transactionSchema =
            t.customChainSchema =
            t.hardforkSchema =
            t.chainSchema =
            t.accessListResultSchema =
            t.accessListSchema =
            t.accessListItemSchema =
              void 0),
          (t.accessListItemSchema = {
            type: "object",
            properties: {
              address: { format: "address" },
              storageKeys: { type: "array", items: { format: "bytes32" } },
            },
          }),
          (t.accessListSchema = {
            type: "array",
            items: Object.assign({}, t.accessListItemSchema),
          }),
          (t.accessListResultSchema = {
            type: "object",
            properties: {
              accessList: Object.assign({}, t.accessListSchema),
              gasUsed: { type: "string" },
            },
          }),
          (t.chainSchema = {
            type: "string",
            enum: [
              "goerli",
              "kovan",
              "mainnet",
              "rinkeby",
              "ropsten",
              "sepolia",
            ],
          }),
          (t.hardforkSchema = {
            type: "string",
            enum: [
              "arrowGlacier",
              "berlin",
              "byzantium",
              "chainstart",
              "constantinople",
              "dao",
              "homestead",
              "istanbul",
              "london",
              "merge",
              "muirGlacier",
              "petersburg",
              "shanghai",
              "spuriousDragon",
              "tangerineWhistle",
            ],
          }),
          (t.customChainSchema = {
            type: "object",
            properties: {
              name: { format: "string" },
              networkId: { format: "uint" },
              chainId: { format: "uint" },
            },
          }),
          (t.transactionSchema = {
            type: "object",
            properties: {
              from: { format: "address" },
              to: { oneOf: [{ format: "address" }, { type: "null" }] },
              value: { format: "uint" },
              gas: { format: "uint" },
              gasPrice: { format: "uint" },
              effectiveGasPrice: { format: "uint" },
              type: { format: "uint" },
              maxFeePerGas: { format: "uint" },
              maxPriorityFeePerGas: { format: "uint" },
              accessList: Object.assign({}, t.accessListSchema),
              data: { format: "bytes" },
              input: { format: "bytes" },
              nonce: { format: "uint" },
              chain: Object.assign({}, t.chainSchema),
              hardfork: Object.assign({}, t.hardforkSchema),
              chainId: { format: "uint" },
              networkId: { format: "uint" },
              common: {
                type: "object",
                properties: {
                  customChain: Object.assign({}, t.customChainSchema),
                  baseChain: Object.assign({}, t.chainSchema),
                  hardfork: Object.assign({}, t.hardforkSchema),
                },
              },
              gasLimit: { format: "uint" },
              v: { format: "uint" },
              r: { format: "bytes32" },
              s: { format: "bytes32" },
            },
          }),
          (t.transactionInfoSchema = {
            type: "object",
            properties: Object.assign(
              Object.assign({}, t.transactionSchema.properties),
              {
                blockHash: { format: "bytes32" },
                blockNumber: { format: "uint" },
                hash: { format: "bytes32" },
                transactionIndex: { format: "uint" },
                from: { format: "address" },
                to: { oneOf: [{ format: "address" }, { type: "null" }] },
                value: { format: "uint" },
                gas: { format: "uint" },
                gasPrice: { format: "uint" },
                effectiveGasPrice: { format: "uint" },
                type: { format: "uint" },
                maxFeePerGas: { format: "uint" },
                maxPriorityFeePerGas: { format: "uint" },
                accessList: Object.assign({}, t.accessListSchema),
                data: { format: "bytes" },
                input: { format: "bytes" },
                nonce: { format: "uint" },
                gasLimit: { format: "uint" },
                v: { format: "uint" },
                r: { format: "bytes32" },
                s: { format: "bytes32" },
              },
            ),
          }),
          (t.blockSchema = {
            type: "object",
            properties: {
              parentHash: { format: "bytes32" },
              sha3Uncles: { format: "bytes32" },
              miner: { format: "bytes" },
              stateRoot: { format: "bytes32" },
              transactionsRoot: { format: "bytes32" },
              receiptsRoot: { format: "bytes32" },
              logsBloom: { format: "bytes256" },
              difficulty: { format: "uint" },
              number: { format: "uint" },
              gasLimit: { format: "uint" },
              gasUsed: { format: "uint" },
              timestamp: { format: "uint" },
              extraData: { format: "bytes" },
              mixHash: { format: "bytes32" },
              nonce: { format: "uint" },
              totalDifficulty: { format: "uint" },
              baseFeePerGas: { format: "uint" },
              size: { format: "uint" },
              transactions: {
                oneOf: [
                  {
                    type: "array",
                    items: Object.assign({}, t.transactionInfoSchema),
                  },
                  { type: "array", items: { format: "bytes32" } },
                ],
              },
              uncles: { type: "array", items: { format: "bytes32" } },
              hash: { format: "bytes32" },
            },
          }),
          (t.withdrawalsSchema = {
            type: "object",
            properties: {
              index: { format: "uint" },
              validatorIndex: { format: "uint" },
              address: { format: "bytes32" },
              amount: { format: "uint" },
            },
          }),
          (t.blockHeaderSchema = {
            type: "object",
            properties: {
              author: { format: "bytes32" },
              hash: { format: "bytes32" },
              parentHash: { format: "bytes32" },
              receiptsRoot: { format: "bytes32" },
              miner: { format: "bytes" },
              stateRoot: { format: "bytes32" },
              transactionsRoot: { format: "bytes32" },
              withdrawalsRoot: { format: "bytes32" },
              logsBloom: { format: "bytes256" },
              difficulty: { format: "uint" },
              totalDifficulty: { format: "uint" },
              number: { format: "uint" },
              gasLimit: { format: "uint" },
              gasUsed: { format: "uint" },
              timestamp: { format: "uint" },
              extraData: { format: "bytes" },
              nonce: { format: "uint" },
              sha3Uncles: { format: "bytes32" },
              size: { format: "uint" },
              baseFeePerGas: { format: "uint" },
              excessDataGas: { format: "uint" },
              mixHash: { format: "bytes32" },
              transactions: { type: "array", items: { format: "bytes32" } },
              uncles: { type: "array", items: { format: "bytes32" } },
              withdrawals: {
                type: "array",
                items: Object.assign({}, t.withdrawalsSchema),
              },
            },
          }),
          (t.logSchema = {
            type: "object",
            properties: {
              removed: { format: "bool" },
              logIndex: { format: "uint" },
              transactionIndex: { format: "uint" },
              transactionHash: { format: "bytes32" },
              blockHash: { format: "bytes32" },
              blockNumber: { format: "uint" },
              address: { format: "address" },
              data: { format: "bytes" },
              topics: { type: "array", items: { format: "bytes32" } },
            },
          }),
          (t.syncSchema = {
            type: "object",
            properties: {
              startingBlock: { format: "string" },
              currentBlock: { format: "string" },
              highestBlock: { format: "string" },
              knownStates: { format: "string" },
              pulledStates: { format: "string" },
            },
          }),
          (t.transactionReceiptSchema = {
            type: "object",
            properties: {
              transactionHash: { format: "bytes32" },
              transactionIndex: { format: "uint" },
              blockHash: { format: "bytes32" },
              blockNumber: { format: "uint" },
              from: { format: "address" },
              to: { format: "address" },
              cumulativeGasUsed: { format: "uint" },
              gasUsed: { format: "uint" },
              effectiveGasPrice: { format: "uint" },
              contractAddress: { format: "address" },
              logs: { type: "array", items: Object.assign({}, t.logSchema) },
              logsBloom: { format: "bytes" },
              root: { format: "bytes" },
              status: { format: "uint" },
              type: { format: "uint" },
            },
          }),
          (t.SignatureObjectSchema = {
            type: "object",
            properties: {
              messageHash: { format: "bytes" },
              r: { format: "bytes32" },
              s: { format: "bytes32" },
              v: { format: "bytes" },
              message: { format: "bytes" },
              signature: { format: "bytes" },
            },
          }),
          (t.feeHistorySchema = {
            type: "object",
            properties: {
              oldestBlock: { format: "uint" },
              baseFeePerGas: { type: "array", items: { format: "uint" } },
              reward: {
                type: "array",
                items: { type: "array", items: { format: "uint" } },
              },
              gasUsedRatio: { type: "array", items: { type: "number" } },
            },
          }),
          (t.storageProofSchema = {
            type: "object",
            properties: {
              key: { format: "bytes32" },
              value: { format: "uint" },
              proof: { type: "array", items: { format: "bytes32" } },
            },
          }),
          (t.accountSchema = {
            type: "object",
            properties: {
              balance: { format: "uint" },
              codeHash: { format: "bytes32" },
              nonce: { format: "uint" },
              storageHash: { format: "bytes32" },
              accountProof: { type: "array", items: { format: "bytes32" } },
              storageProof: {
                type: "array",
                items: Object.assign({}, t.storageProofSchema),
              },
            },
          });
      },
      3321: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
      },
      1278: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.decodeSignedTransaction = void 0);
        const n = r(9150),
          i = r(4464),
          s = r(6484),
          o = r(7588);
        t.decodeSignedTransaction = function (
          e,
          t,
          r = { fillInputAndData: !1 },
        ) {
          return {
            raw: (0, n.format)({ format: "bytes" }, e, t),
            tx: (0, o.formatTransaction)(
              Object.assign(
                Object.assign(
                  {},
                  i.TransactionFactory.fromSerializedData(
                    (0, n.hexToBytes)(e),
                  ).toJSON(),
                ),
                {
                  hash: (0, n.bytesToHex)(
                    (0, n.keccak256)((0, n.hexToBytes)(e)),
                  ),
                  type: (0, s.detectRawTransactionType)((0, n.hexToBytes)(e)),
                },
              ),
              t,
              { fillInputAndData: r.fillInputAndData },
            ),
          };
        };
      },
      6484: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.detectRawTransactionType =
            t.detectTransactionType =
            t.defaultTransactionTypeParser =
              void 0);
        const n = r(9150),
          i = r(2823),
          s = r(8840),
          o = r(3087),
          a = {
            type: "object",
            properties: {
              accessList: { type: "null" },
              maxFeePerGas: { type: "null" },
              maxPriorityFeePerGas: { type: "null" },
            },
          },
          c = {
            type: "object",
            properties: {
              maxFeePerGas: { type: "null" },
              maxPriorityFeePerGas: { type: "null" },
            },
          },
          d = { type: "object", properties: { gasPrice: { type: "null" } } },
          u = (e, t, r) => {
            try {
              s.validator.validateJSONSchema(e, t);
            } catch (e) {
              if (e instanceof s.Web3ValidatorError)
                throw new o.InvalidPropertiesForTransactionTypeError(
                  e.errors,
                  r,
                );
              throw e;
            }
          };
        (t.defaultTransactionTypeParser = (e) => {
          var t, r;
          const o = e;
          if (!(0, s.isNullish)(o.type)) {
            let e;
            switch (o.type) {
              case "0x0":
                e = a;
                break;
              case "0x1":
                e = c;
                break;
              case "0x2":
                e = d;
                break;
              default:
                return (0, n.format)(
                  { format: "uint" },
                  o.type,
                  i.ETH_DATA_FORMAT,
                );
            }
            return (
              u(e, o, o.type),
              (0, n.format)({ format: "uint" }, o.type, i.ETH_DATA_FORMAT)
            );
          }
          if (
            !(0, s.isNullish)(o.maxFeePerGas) ||
            !(0, s.isNullish)(o.maxPriorityFeePerGas)
          )
            return u(d, o, "0x2"), "0x2";
          if (!(0, s.isNullish)(o.accessList)) return u(c, o, "0x1"), "0x1";
          (0, s.isNullish)(o.gasPrice) || u(a, o, "0x0");
          const l =
            null !== (t = o.hardfork) && void 0 !== t
              ? t
              : null === (r = o.common) || void 0 === r
              ? void 0
              : r.hardfork;
          if (void 0 === l) return;
          const h = Object.keys(i.HardforksOrdered).indexOf(l);
          return void 0 !== h
            ? h >= Object.keys(i.HardforksOrdered).indexOf("london")
              ? (0, s.isNullish)(o.gasPrice)
                ? "0x2"
                : "0x0"
              : h === Object.keys(i.HardforksOrdered).indexOf("berlin")
              ? "0x0"
              : void 0
            : void 0;
        }),
          (t.detectTransactionType = (e, r) => {
            var n;
            return (
              null !== (n = null == r ? void 0 : r.transactionTypeParser) &&
                void 0 !== n
                ? n
                : t.defaultTransactionTypeParser
            )(e);
          }),
          (t.detectRawTransactionType = (e) =>
            e[0] > 127 ? "0x0" : (0, n.toHex)(e[0]));
      },
      7588: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.formatTransaction = void 0);
        const n = r(2823),
          i = r(8840),
          s = r(9150),
          o = r(3087),
          a = r(5127);
        t.formatTransaction = function (
          e,
          t = n.DEFAULT_RETURN_FORMAT,
          r = {
            transactionSchema: a.transactionInfoSchema,
            fillInputAndData: !1,
          },
        ) {
          var c, d;
          let u = (0, s.mergeDeep)({}, e);
          if (
            ((0, i.isNullish)(null == e ? void 0 : e.common) ||
              ((u.common = Object.assign({}, e.common)),
              (0, i.isNullish)(
                null === (c = e.common) || void 0 === c
                  ? void 0
                  : c.customChain,
              ) ||
                (u.common.customChain = Object.assign(
                  {},
                  e.common.customChain,
                ))),
            (u = (0, s.format)(
              null !== (d = r.transactionSchema) && void 0 !== d
                ? d
                : a.transactionInfoSchema,
              u,
              t,
            )),
            !(0, i.isNullish)(u.data) &&
              !(0, i.isNullish)(u.input) &&
              (0, s.toHex)(u.data) !== (0, s.toHex)(u.input))
          )
            throw new o.TransactionDataAndInputError({
              data: (0, s.bytesToHex)(u.data),
              input: (0, s.bytesToHex)(u.input),
            });
          return (
            r.fillInputAndData &&
              ((0, i.isNullish)(u.data)
                ? (0, i.isNullish)(u.input) || (u.data = u.input)
                : (u.input = u.data)),
            (0, i.isNullish)(u.gasLimit) ||
              ((u.gas = u.gasLimit), delete u.gasLimit),
            u
          );
        };
      },
      4230: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__awaiter) ||
          function (e, t, r, n) {
            return new (r || (r = Promise))(function (i, s) {
              function o(e) {
                try {
                  c(n.next(e));
                } catch (e) {
                  s(e);
                }
              }
              function a(e) {
                try {
                  c(n.throw(e));
                } catch (e) {
                  s(e);
                }
              }
              function c(e) {
                var t;
                e.done
                  ? i(e.value)
                  : ((t = e.value),
                    t instanceof r
                      ? t
                      : new r(function (e) {
                          e(t);
                        })).then(o, a);
              }
              c((n = n.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getRevertReason = t.parseTransactionError = void 0);
        const i = r(3087),
          s = r(3050),
          o = r(2823),
          a = r(8829);
        (t.parseTransactionError = (e, t) => {
          var r, n, o, a;
          if (
            e instanceof i.ContractExecutionError &&
            e.innerError instanceof i.Eip838ExecutionError
          ) {
            if (void 0 !== t) {
              const i = t.filter((e) => (0, s.isAbiErrorFragment)(e));
              return (
                (0, s.decodeContractErrorData)(i, e.innerError),
                {
                  reason: e.innerError.message,
                  signature:
                    null === (r = e.innerError.data) || void 0 === r
                      ? void 0
                      : r.slice(0, 10),
                  data:
                    null === (n = e.innerError.data) || void 0 === n
                      ? void 0
                      : n.substring(10),
                  customErrorName: e.innerError.errorName,
                  customErrorDecodedSignature: e.innerError.errorSignature,
                  customErrorArguments: e.innerError.errorArgs,
                }
              );
            }
            return {
              reason: e.innerError.message,
              signature:
                null === (o = e.innerError.data) || void 0 === o
                  ? void 0
                  : o.slice(0, 10),
              data:
                null === (a = e.innerError.data) || void 0 === a
                  ? void 0
                  : a.substring(10),
            };
          }
          if (
            e instanceof i.InvalidResponseError &&
            !Array.isArray(e.innerError) &&
            void 0 !== e.innerError
          )
            return e.innerError.message;
          throw e;
        }),
          (t.getRevertReason = function (e, r, i, s = o.DEFAULT_RETURN_FORMAT) {
            return n(this, void 0, void 0, function* () {
              try {
                return void (yield (0, a.call)(e, r, e.defaultBlock, s));
              } catch (e) {
                return (0, t.parseTransactionError)(e, i);
              }
            });
          });
      },
      6005: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__awaiter) ||
          function (e, t, r, n) {
            return new (r || (r = Promise))(function (i, s) {
              function o(e) {
                try {
                  c(n.next(e));
                } catch (e) {
                  s(e);
                }
              }
              function a(e) {
                try {
                  c(n.throw(e));
                } catch (e) {
                  s(e);
                }
              }
              function c(e) {
                var t;
                e.done
                  ? i(e.value)
                  : ((t = e.value),
                    t instanceof r
                      ? t
                      : new r(function (e) {
                          e(t);
                        })).then(o, a);
              }
              c((n = n.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getTransactionError = void 0);
        const i = r(3087),
          s = r(4230);
        t.getTransactionError = function (e, t, r, o, a, c) {
          return n(this, void 0, void 0, function* () {
            let n,
              d = c;
            if (
              (void 0 === d &&
                (void 0 !== o
                  ? (d = (0, s.parseTransactionError)(o))
                  : e.handleRevert &&
                    void 0 !== t &&
                    (d = yield (0, s.getRevertReason)(e, t, a))),
              void 0 === d)
            )
              n = new i.TransactionRevertedWithoutReasonError(r);
            else if ("string" == typeof d)
              n = new i.TransactionRevertInstructionError(d, void 0, r);
            else if (
              void 0 !== d.customErrorName &&
              void 0 !== d.customErrorDecodedSignature &&
              void 0 !== d.customErrorArguments
            ) {
              const e = d;
              n = new i.TransactionRevertWithCustomError(
                e.reason,
                e.customErrorName,
                e.customErrorDecodedSignature,
                e.customErrorArguments,
                e.signature,
                r,
                e.data,
              );
            } else
              n = new i.TransactionRevertInstructionError(
                d.reason,
                d.signature,
                r,
                d.data,
              );
            return n;
          });
        };
      },
      4022: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__awaiter) ||
          function (e, t, r, n) {
            return new (r || (r = Promise))(function (i, s) {
              function o(e) {
                try {
                  c(n.next(e));
                } catch (e) {
                  s(e);
                }
              }
              function a(e) {
                try {
                  c(n.throw(e));
                } catch (e) {
                  s(e);
                }
              }
              function c(e) {
                var t;
                e.done
                  ? i(e.value)
                  : ((t = e.value),
                    t instanceof r
                      ? t
                      : new r(function (e) {
                          e(t);
                        })).then(o, a);
              }
              c((n = n.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getTransactionGasPricing = void 0);
        const i = r(8840),
          s = r(3087),
          o = r(9150),
          a = r(8829),
          c = r(5228);
        t.getTransactionGasPricing = function (e, t, r) {
          return n(this, void 0, void 0, function* () {
            const d = (0, c.getTransactionType)(e, t);
            if (!(0, i.isNullish)(d)) {
              if (d.startsWith("-"))
                throw new s.UnsupportedTransactionTypeError(d);
              if (d < "0x0" || d > "0x7f")
                throw new s.UnsupportedTransactionTypeError(d);
              if ((0, i.isNullish)(e.gasPrice) && ("0x0" === d || "0x1" === d))
                return {
                  gasPrice: yield (0, a.getGasPrice)(t, r),
                  maxPriorityFeePerGas: void 0,
                  maxFeePerGas: void 0,
                };
              if ("0x2" === d)
                return Object.assign(
                  { gasPrice: void 0 },
                  yield (function (e, t, r) {
                    var c, d, u;
                    return n(this, void 0, void 0, function* () {
                      const n = yield (0, a.getBlock)(t, t.defaultBlock, !1, r);
                      if ((0, i.isNullish)(n.baseFeePerGas))
                        throw new s.Eip1559NotSupportedError();
                      if (!(0, i.isNullish)(e.gasPrice)) {
                        const t = (0, o.format)(
                          { format: "uint" },
                          e.gasPrice,
                          r,
                        );
                        return { maxPriorityFeePerGas: t, maxFeePerGas: t };
                      }
                      return {
                        maxPriorityFeePerGas: (0, o.format)(
                          { format: "uint" },
                          null !== (c = e.maxPriorityFeePerGas) && void 0 !== c
                            ? c
                            : t.defaultMaxPriorityFeePerGas,
                          r,
                        ),
                        maxFeePerGas: (0, o.format)(
                          { format: "uint" },
                          null !== (d = e.maxFeePerGas) && void 0 !== d
                            ? d
                            : BigInt(n.baseFeePerGas) * BigInt(2) +
                                BigInt(
                                  null !== (u = e.maxPriorityFeePerGas) &&
                                    void 0 !== u
                                    ? u
                                    : t.defaultMaxPriorityFeePerGas,
                                ),
                          r,
                        ),
                      };
                    });
                  })(e, t, r),
                );
            }
          });
        };
      },
      6522: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__awaiter) ||
          function (e, t, r, n) {
            return new (r || (r = Promise))(function (i, s) {
              function o(e) {
                try {
                  c(n.next(e));
                } catch (e) {
                  s(e);
                }
              }
              function a(e) {
                try {
                  c(n.throw(e));
                } catch (e) {
                  s(e);
                }
              }
              function c(e) {
                var t;
                e.done
                  ? i(e.value)
                  : ((t = e.value),
                    t instanceof r
                      ? t
                      : new r(function (e) {
                          e(t);
                        })).then(o, a);
              }
              c((n = n.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.prepareTransactionForSigning = void 0);
        const i = r(2823),
          s = r(9150),
          o = r(4464),
          a = r(8840),
          c = r(4027),
          d = r(7588),
          u = r(5228);
        t.prepareTransactionForSigning = (e, t, r, l = !1, h = !0) =>
          n(void 0, void 0, void 0, function* () {
            const n = yield (0, u.transactionBuilder)({
                transaction: e,
                web3Context: t,
                privateKey: r,
                fillGasPrice: l,
                fillGasLimit: h,
              }),
              f = (0, d.formatTransaction)(n, i.ETH_DATA_FORMAT);
            return (
              (0, c.validateTransactionForSigning)(f),
              o.TransactionFactory.fromTxData(
                ((e) => {
                  var t, r;
                  return {
                    nonce: e.nonce,
                    gasPrice: e.gasPrice,
                    gasLimit:
                      null !== (t = e.gasLimit) && void 0 !== t ? t : e.gas,
                    to: e.to,
                    value: e.value,
                    data: null !== (r = e.data) && void 0 !== r ? r : e.input,
                    type: e.type,
                    chainId: e.chainId,
                    accessList: e.accessList,
                    maxPriorityFeePerGas: e.maxPriorityFeePerGas,
                    maxFeePerGas: e.maxFeePerGas,
                  };
                })(f),
                ((e, t) => {
                  var r, n, i, c, d, u, l, h, f, p, m, y, g, v, b, w, E, A;
                  let _;
                  if (
                    ((0, a.isNullish)(e.chain) ||
                      (0, a.isNullish)(e.hardfork)) &&
                    (0, a.isNullish)(e.common)
                  )
                    t.defaultCommon
                      ? ((_ = t.defaultCommon),
                        (0, a.isNullish)(_.hardfork) &&
                          (_.hardfork =
                            null !== (r = e.hardfork) && void 0 !== r
                              ? r
                              : t.defaultHardfork),
                        (0, a.isNullish)(_.baseChain) &&
                          (_.baseChain = t.defaultChain))
                      : (_ = o.Common.custom(
                          {
                            name: "custom-network",
                            chainId: (0, s.toNumber)(e.chainId),
                            networkId: (0, a.isNullish)(e.networkId)
                              ? void 0
                              : (0, s.toNumber)(e.networkId),
                            defaultHardfork:
                              null !== (n = e.hardfork) && void 0 !== n
                                ? n
                                : t.defaultHardfork,
                          },
                          { baseChain: t.defaultChain },
                        ));
                  else {
                    const r =
                        null !==
                          (u =
                            null !==
                              (d =
                                null ===
                                  (c =
                                    null ===
                                      (i = null == e ? void 0 : e.common) ||
                                    void 0 === i
                                      ? void 0
                                      : i.customChain) || void 0 === c
                                  ? void 0
                                  : c.name) && void 0 !== d
                              ? d
                              : e.chain) && void 0 !== u
                          ? u
                          : "custom-network",
                      n = (0, s.toNumber)(
                        null !==
                          (f =
                            null ===
                              (h =
                                null === (l = null == e ? void 0 : e.common) ||
                                void 0 === l
                                  ? void 0
                                  : l.customChain) || void 0 === h
                              ? void 0
                              : h.chainId) && void 0 !== f
                          ? f
                          : null == e
                          ? void 0
                          : e.chainId,
                      ),
                      a = (0, s.toNumber)(
                        null !==
                          (y =
                            null ===
                              (m =
                                null === (p = null == e ? void 0 : e.common) ||
                                void 0 === p
                                  ? void 0
                                  : p.customChain) || void 0 === m
                              ? void 0
                              : m.networkId) && void 0 !== y
                          ? y
                          : null == e
                          ? void 0
                          : e.networkId,
                      ),
                      T =
                        null !==
                          (b =
                            null !==
                              (v =
                                null === (g = null == e ? void 0 : e.common) ||
                                void 0 === g
                                  ? void 0
                                  : g.hardfork) && void 0 !== v
                              ? v
                              : null == e
                              ? void 0
                              : e.hardfork) && void 0 !== b
                          ? b
                          : t.defaultHardfork,
                      R =
                        null !==
                          (A =
                            null !==
                              (E =
                                null === (w = e.common) || void 0 === w
                                  ? void 0
                                  : w.baseChain) && void 0 !== E
                              ? E
                              : e.chain) && void 0 !== A
                          ? A
                          : t.defaultChain;
                    n &&
                      a &&
                      r &&
                      (_ = o.Common.custom(
                        {
                          name: r,
                          chainId: n,
                          networkId: a,
                          defaultHardfork: T,
                        },
                        { baseChain: R },
                      ));
                  }
                  return { common: _ };
                })(f, t),
              )
            );
          });
      },
      9249: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__awaiter) ||
          function (e, t, r, n) {
            return new (r || (r = Promise))(function (i, s) {
              function o(e) {
                try {
                  c(n.next(e));
                } catch (e) {
                  s(e);
                }
              }
              function a(e) {
                try {
                  c(n.throw(e));
                } catch (e) {
                  s(e);
                }
              }
              function c(e) {
                var t;
                e.done
                  ? i(e.value)
                  : ((t = e.value),
                    t instanceof r
                      ? t
                      : new r(function (e) {
                          e(t);
                        })).then(o, a);
              }
              c((n = n.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.rejectIfBlockTimeout = void 0);
        const i = r(9150),
          s = r(3087),
          o = r(1929),
          a = r(8829);
        function c(e, t, r) {
          const c = e.transactionPollingInterval,
            [d, u] = (0, i.rejectIfConditionAtInterval)(
              () =>
                n(this, void 0, void 0, function* () {
                  let n;
                  try {
                    n = yield (0, a.getBlockNumber)(e, o.NUMBER_DATA_FORMAT);
                  } catch (e) {
                    return void console.warn(
                      "An error happen while trying to get the block number",
                      e,
                    );
                  }
                  const i = n - t;
                  if (i >= e.transactionBlockTimeout)
                    return new s.TransactionBlockTimeoutError({
                      starterBlockNumber: t,
                      numberOfBlocks: i,
                      transactionHash: r,
                    });
                }),
              c,
            );
          return [
            u,
            {
              clean: () => {
                clearInterval(d);
              },
            },
          ];
        }
        t.rejectIfBlockTimeout = function (e, t) {
          var r, i;
          return n(this, void 0, void 0, function* () {
            const { provider: d } = e.requestManager;
            let u;
            const l = yield (0, a.getBlockNumber)(e, o.NUMBER_DATA_FORMAT);
            return (
              (u =
                (null === (i = (r = d).supportsSubscriptions) || void 0 === i
                  ? void 0
                  : i.call(r)) &&
                e.enableExperimentalFeatures
                  .useSubscriptionWhenCheckingBlockTimeout
                  ? yield (function (e, t, r) {
                      var i;
                      return n(this, void 0, void 0, function* () {
                        let n,
                          o,
                          a = !0;
                        function d(n, i) {
                          i &&
                            console.warn(
                              "error happened at subscription. So revert to polling...",
                              i,
                            ),
                            o.clean(),
                            (a = !1);
                          const [s, d] = c(e, t, r);
                          (o.clean = d.clean), s.catch((e) => n(e));
                        }
                        try {
                          (n = yield null === (i = e.subscriptionManager) ||
                          void 0 === i
                            ? void 0
                            : i.subscribe("newHeads")),
                            (o = {
                              clean: () => {
                                var t;
                                n.id &&
                                  (null === (t = e.subscriptionManager) ||
                                    void 0 === t ||
                                    t
                                      .removeSubscription(n)
                                      .then(() => {})
                                      .catch(() => {}));
                              },
                            });
                        } catch (n) {
                          return c(e, t, r);
                        }
                        return [
                          new Promise((i, o) => {
                            try {
                              n.on("data", (n) => {
                                if (
                                  ((a = !1), !(null == n ? void 0 : n.number))
                                )
                                  return;
                                const i = Number(BigInt(n.number) - BigInt(t));
                                i >= e.transactionBlockTimeout &&
                                  o(
                                    new s.TransactionBlockTimeoutError({
                                      starterBlockNumber: t,
                                      numberOfBlocks: i,
                                      transactionHash: r,
                                    }),
                                  );
                              }),
                                n.on("error", (e) => {
                                  d(o, e);
                                });
                            } catch (e) {
                              d(o, e);
                            }
                            setTimeout(() => {
                              a && d(o);
                            }, 1e3 * e.blockHeaderTimeout);
                          }),
                          o,
                        ];
                      });
                    })(e, l, t)
                  : c(e, l, t)),
              u
            );
          });
        };
      },
      5228: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__awaiter) ||
          function (e, t, r, n) {
            return new (r || (r = Promise))(function (i, s) {
              function o(e) {
                try {
                  c(n.next(e));
                } catch (e) {
                  s(e);
                }
              }
              function a(e) {
                try {
                  c(n.throw(e));
                } catch (e) {
                  s(e);
                }
              }
              function c(e) {
                var t;
                e.done
                  ? i(e.value)
                  : ((t = e.value),
                    t instanceof r
                      ? t
                      : new r(function (e) {
                          e(t);
                        })).then(o, a);
              }
              c((n = n.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.transactionBuilder =
            t.defaultTransactionBuilder =
            t.getTransactionType =
            t.getTransactionNonce =
            t.getTransactionFromOrToAttr =
              void 0);
        const i = r(2823),
          s = r(4464),
          o = r(6714),
          a = r(8840),
          c = r(3087),
          d = r(9150),
          u = r(1929),
          l = r(8829),
          h = r(6484),
          f = r(5127),
          p = r(4022);
        function m(e) {
          var r, s;
          return n(this, void 0, void 0, function* () {
            let n = (0, d.format)(
              f.transactionSchema,
              e.transaction,
              i.DEFAULT_RETURN_FORMAT,
            );
            if (
              ((0, a.isNullish)(n.from) &&
                (n.from = (0, t.getTransactionFromOrToAttr)(
                  "from",
                  e.web3Context,
                  void 0,
                  e.privateKey,
                )),
              (0, a.isNullish)(n.nonce) &&
                (n.nonce = yield (0, t.getTransactionNonce)(
                  e.web3Context,
                  n.from,
                  i.ETH_DATA_FORMAT,
                )),
              (0, a.isNullish)(n.value) && (n.value = "0x"),
              (0, a.isNullish)(n.data))
            )
              (0, a.isNullish)(n.input)
                ? (n.input = "0x")
                : n.input.startsWith("0x") || (n.input = `0x${n.input}`);
            else {
              if (!(0, a.isNullish)(n.input) && n.data !== n.input)
                throw new c.TransactionDataAndInputError({
                  data: (0, d.bytesToHex)(n.data),
                  input: (0, d.bytesToHex)(n.input),
                });
              n.data.startsWith("0x") || (n.data = `0x${n.data}`);
            }
            if ((0, a.isNullish)(n.common)) {
              if (e.web3Context.defaultCommon) {
                const t = e.web3Context.defaultCommon,
                  r = t.customChain.chainId,
                  i = t.customChain.networkId,
                  s = t.customChain.name;
                n.common = Object.assign(Object.assign({}, t), {
                  customChain: { chainId: r, networkId: i, name: s },
                });
              }
              (0, a.isNullish)(n.chain) &&
                (n.chain = e.web3Context.defaultChain),
                (0, a.isNullish)(n.hardfork) &&
                  (n.hardfork = e.web3Context.defaultHardfork);
            }
            if (
              ((0, a.isNullish)(n.chainId) &&
                (0, a.isNullish)(
                  null === (r = n.common) || void 0 === r
                    ? void 0
                    : r.customChain.chainId,
                ) &&
                (n.chainId = yield (0, l.getChainId)(
                  e.web3Context,
                  i.ETH_DATA_FORMAT,
                )),
              (0, a.isNullish)(n.networkId) &&
                (n.networkId =
                  null !== (s = e.web3Context.defaultNetworkId) && void 0 !== s
                    ? s
                    : yield (0, o.getId)(e.web3Context, i.ETH_DATA_FORMAT)),
              (0, a.isNullish)(n.gasLimit) &&
                !(0, a.isNullish)(n.gas) &&
                (n.gasLimit = n.gas),
              (n.type = (0, t.getTransactionType)(n, e.web3Context)),
              !(0, a.isNullish)(n.accessList) ||
                ("0x1" !== n.type && "0x2" !== n.type) ||
                (n.accessList = []),
              e.fillGasPrice &&
                (n = Object.assign(
                  Object.assign({}, n),
                  yield (0, p.getTransactionGasPricing)(
                    n,
                    e.web3Context,
                    i.ETH_DATA_FORMAT,
                  ),
                )),
              (0, a.isNullish)(n.gas) &&
                (0, a.isNullish)(n.gasLimit) &&
                e.fillGasLimit)
            ) {
              const t = yield (0, l.estimateGas)(
                e.web3Context,
                n,
                "latest",
                i.ETH_DATA_FORMAT,
              );
              n = Object.assign(Object.assign({}, n), {
                gas: (0, d.format)({ format: "uint" }, t, i.ETH_DATA_FORMAT),
              });
            }
            return n;
          });
        }
        (t.getTransactionFromOrToAttr = (e, t, r, n) => {
          if (void 0 !== r && e in r && void 0 !== r[e]) {
            if ("string" == typeof r[e] && (0, a.isAddress)(r[e])) return r[e];
            if (!(0, a.isHexStrict)(r[e]) && (0, a.isNumber)(r[e])) {
              if (t.wallet) {
                const n = t.wallet.get(
                  (0, d.format)({ format: "uint" }, r[e], u.NUMBER_DATA_FORMAT),
                );
                if (!(0, a.isNullish)(n)) return n.address;
                throw new c.LocalWalletNotAvailableError();
              }
              throw new c.LocalWalletNotAvailableError();
            }
            throw "from" === e
              ? new c.InvalidTransactionWithSender(r.from)
              : new c.InvalidTransactionWithReceiver(r.to);
          }
          if ("from" === e) {
            if (!(0, a.isNullish)(n)) return (0, s.privateKeyToAddress)(n);
            if (!(0, a.isNullish)(t.defaultAccount)) return t.defaultAccount;
          }
        }),
          (t.getTransactionNonce = (e, t, r = i.DEFAULT_RETURN_FORMAT) =>
            n(void 0, void 0, void 0, function* () {
              if ((0, a.isNullish)(t)) throw new c.UnableToPopulateNonceError();
              return (0, l.getTransactionCount)(e, t, e.defaultBlock, r);
            })),
          (t.getTransactionType = (e, t) => {
            const r = (0, h.detectTransactionType)(e, t);
            return (0, a.isNullish)(r)
              ? (0, a.isNullish)(t.defaultTransactionType)
                ? void 0
                : (0, d.format)(
                    { format: "uint" },
                    t.defaultTransactionType,
                    i.ETH_DATA_FORMAT,
                  )
              : r;
          }),
          (t.defaultTransactionBuilder = m),
          (t.transactionBuilder = (e) =>
            n(void 0, void 0, void 0, function* () {
              var t;
              return (
                null !== (t = e.web3Context.transactionBuilder) && void 0 !== t
                  ? t
                  : m
              )(
                Object.assign(Object.assign({}, e), {
                  transaction: e.transaction,
                }),
              );
            }));
      },
      3540: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__awaiter) ||
          function (e, t, r, n) {
            return new (r || (r = Promise))(function (i, s) {
              function o(e) {
                try {
                  c(n.next(e));
                } catch (e) {
                  s(e);
                }
              }
              function a(e) {
                try {
                  c(n.throw(e));
                } catch (e) {
                  s(e);
                }
              }
              function c(e) {
                var t;
                e.done
                  ? i(e.value)
                  : ((t = e.value),
                    t instanceof r
                      ? t
                      : new r(function (e) {
                          e(t);
                        })).then(o, a);
              }
              c((n = n.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.trySendTransaction = void 0);
        const i = r(9150),
          s = r(3087),
          o = r(9249);
        t.trySendTransaction = function (e, t, r) {
          return n(this, void 0, void 0, function* () {
            const [n, a] = (0, i.rejectIfTimeout)(
                e.transactionSendTimeout,
                new s.TransactionSendTimeoutError({
                  numberOfSeconds: e.transactionSendTimeout / 1e3,
                  transactionHash: r,
                }),
              ),
              [c, d] = yield (0, o.rejectIfBlockTimeout)(e, r);
            try {
              return yield Promise.race([t(), a, c]);
            } finally {
              clearTimeout(n), d.clean();
            }
          });
        };
      },
      3907: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__awaiter) ||
          function (e, t, r, n) {
            return new (r || (r = Promise))(function (i, s) {
              function o(e) {
                try {
                  c(n.next(e));
                } catch (e) {
                  s(e);
                }
              }
              function a(e) {
                try {
                  c(n.throw(e));
                } catch (e) {
                  s(e);
                }
              }
              function c(e) {
                var t;
                e.done
                  ? i(e.value)
                  : ((t = e.value),
                    t instanceof r
                      ? t
                      : new r(function (e) {
                          e(t);
                        })).then(o, a);
              }
              c((n = n.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.waitForTransactionReceipt = void 0);
        const i = r(3087),
          s = r(9150),
          o = r(9249),
          a = r(8829);
        t.waitForTransactionReceipt = function (e, t, r) {
          var c;
          return n(this, void 0, void 0, function* () {
            const d =
                null !== (c = e.transactionReceiptPollingInterval) &&
                void 0 !== c
                  ? c
                  : e.transactionPollingInterval,
              u = (0, s.pollTillDefined)(
                () =>
                  n(this, void 0, void 0, function* () {
                    try {
                      return (0, a.getTransactionReceipt)(e, t, r);
                    } catch (e) {
                      return void console.warn(
                        "An error happen while trying to get the transaction receipt",
                        e,
                      );
                    }
                  }),
                d,
              ),
              [l, h] = (0, s.rejectIfTimeout)(
                e.transactionPollingTimeout,
                new i.TransactionPollingTimeoutError({
                  numberOfSeconds: e.transactionPollingTimeout / 1e3,
                  transactionHash: t,
                }),
              ),
              [f, p] = yield (0, o.rejectIfBlockTimeout)(e, t);
            try {
              return yield Promise.race([u, h, f]);
            } finally {
              clearTimeout(l), p.clean();
            }
          });
        };
      },
      4455: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__awaiter) ||
          function (e, t, r, n) {
            return new (r || (r = Promise))(function (i, s) {
              function o(e) {
                try {
                  c(n.next(e));
                } catch (e) {
                  s(e);
                }
              }
              function a(e) {
                try {
                  c(n.throw(e));
                } catch (e) {
                  s(e);
                }
              }
              function c(e) {
                var t;
                e.done
                  ? i(e.value)
                  : ((t = e.value),
                    t instanceof r
                      ? t
                      : new r(function (e) {
                          e(t);
                        })).then(o, a);
              }
              c((n = n.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.watchTransactionByPolling = void 0);
        const i = r(9150),
          s = r(100),
          o = r(5127);
        t.watchTransactionByPolling = ({
          web3Context: e,
          transactionReceipt: t,
          transactionPromiEvent: r,
          returnFormat: a,
        }) => {
          var c;
          let d = 1;
          const u = setInterval(
            () => {
              n(void 0, void 0, void 0, function* () {
                d >= e.transactionConfirmationBlocks && clearInterval(u);
                const n = yield s.ethRpcMethods.getBlockByNumber(
                  e.requestManager,
                  (0, i.numberToHex)(BigInt(t.blockNumber) + BigInt(d)),
                  !1,
                );
                (null == n ? void 0 : n.hash) &&
                  ((d += 1),
                  r.emit("confirmation", {
                    confirmations: (0, i.format)({ format: "uint" }, d, a),
                    receipt: (0, i.format)(o.transactionReceiptSchema, t, a),
                    latestBlockHash: (0, i.format)(
                      { format: "bytes32" },
                      n.hash,
                      a,
                    ),
                  }));
              });
            },
            null !== (c = e.transactionReceiptPollingInterval) && void 0 !== c
              ? c
              : e.transactionPollingInterval,
          );
        };
      },
      3036: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__awaiter) ||
          function (e, t, r, n) {
            return new (r || (r = Promise))(function (i, s) {
              function o(e) {
                try {
                  c(n.next(e));
                } catch (e) {
                  s(e);
                }
              }
              function a(e) {
                try {
                  c(n.throw(e));
                } catch (e) {
                  s(e);
                }
              }
              function c(e) {
                var t;
                e.done
                  ? i(e.value)
                  : ((t = e.value),
                    t instanceof r
                      ? t
                      : new r(function (e) {
                          e(t);
                        })).then(o, a);
              }
              c((n = n.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.watchTransactionBySubscription = void 0);
        const i = r(9150),
          s = r(5127),
          o = r(4455);
        t.watchTransactionBySubscription = ({
          web3Context: e,
          transactionReceipt: t,
          transactionPromiEvent: r,
          returnFormat: a,
        }) => {
          let c,
            d = !0;
          setImmediate(() => {
            var u;
            null === (u = e.subscriptionManager) ||
              void 0 === u ||
              u
                .subscribe("newHeads")
                .then((u) => {
                  u.on("data", (o) =>
                    n(void 0, void 0, void 0, function* () {
                      var n;
                      if (
                        ((d = !1),
                        !(null == o ? void 0 : o.number) ||
                          c === (null == o ? void 0 : o.parentHash))
                      )
                        return;
                      c = null == o ? void 0 : o.parentHash;
                      const l =
                        BigInt(o.number) - BigInt(t.blockNumber) + BigInt(1);
                      r.emit("confirmation", {
                        confirmations: (0, i.format)({ format: "uint" }, l, a),
                        receipt: (0, i.format)(
                          s.transactionReceiptSchema,
                          t,
                          a,
                        ),
                        latestBlockHash: (0, i.format)(
                          { format: "bytes32" },
                          o.parentHash,
                          a,
                        ),
                      }),
                        l >= e.transactionConfirmationBlocks &&
                          (yield null === (n = e.subscriptionManager) ||
                          void 0 === n
                            ? void 0
                            : n.removeSubscription(u));
                    }),
                  ),
                    u.on("error", () =>
                      n(void 0, void 0, void 0, function* () {
                        var n;
                        yield null === (n = e.subscriptionManager) ||
                        void 0 === n
                          ? void 0
                          : n.removeSubscription(u),
                          (d = !1),
                          (0, o.watchTransactionByPolling)({
                            web3Context: e,
                            transactionReceipt: t,
                            transactionPromiEvent: r,
                            returnFormat: a,
                          });
                      }),
                    );
                })
                .catch(() => {
                  (d = !1),
                    (0, o.watchTransactionByPolling)({
                      web3Context: e,
                      transactionReceipt: t,
                      transactionPromiEvent: r,
                      returnFormat: a,
                    });
                });
          }),
            setTimeout(() => {
              d &&
                (0, o.watchTransactionByPolling)({
                  web3Context: e,
                  transactionReceipt: t,
                  transactionPromiEvent: r,
                  returnFormat: a,
                });
            }, 1e3 * e.blockHeaderTimeout);
        };
      },
      98: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.watchTransactionForConfirmations = void 0);
        const n = r(9150),
          i = r(8840),
          s = r(3087),
          o = r(5127),
          a = r(4455),
          c = r(3036);
        t.watchTransactionForConfirmations = function (e, t, r, d, u) {
          if ((0, i.isNullish)(r) || (0, i.isNullish)(r.blockHash))
            throw new s.TransactionMissingReceiptOrBlockHashError({
              receipt: r,
              blockHash: (0, n.format)(
                { format: "bytes32" },
                null == r ? void 0 : r.blockHash,
                u,
              ),
              transactionHash: (0, n.format)({ format: "bytes32" }, d, u),
            });
          if (!r.blockNumber)
            throw new s.TransactionReceiptMissingBlockNumberError({
              receipt: r,
            });
          t.emit("confirmation", {
            confirmations: (0, n.format)({ format: "uint" }, 1, u),
            receipt: (0, n.format)(o.transactionReceiptSchema, r, u),
            latestBlockHash: (0, n.format)(
              { format: "bytes32" },
              r.blockHash,
              u,
            ),
          }),
            e.requestManager.provider.supportsSubscriptions()
              ? (0, c.watchTransactionBySubscription)({
                  web3Context: e,
                  transactionReceipt: r,
                  transactionPromiEvent: t,
                  returnFormat: u,
                })
              : (0, a.watchTransactionByPolling)({
                  web3Context: e,
                  transactionReceipt: r,
                  transactionPromiEvent: t,
                  returnFormat: u,
                });
        };
      },
      4027: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.validateTransactionForSigning =
            t.validateGas =
            t.validateFeeMarketGas =
            t.validateLegacyGas =
            t.validateHardfork =
            t.validateBaseChain =
            t.validateChainInfo =
            t.validateCustomChainInfo =
            t.validateTransactionCall =
            t.isTransactionCall =
            t.validateTransactionWithSender =
            t.isTransactionWithSender =
            t.isTransactionLegacyUnsigned =
            t.isTransaction2930Unsigned =
            t.isTransaction1559Unsigned =
            t.isAccessList =
            t.isAccessListEntry =
            t.isBaseTransaction =
              void 0);
        const n = r(2823),
          i = r(8840),
          s = r(3087),
          o = r(7588);
        function a(e) {
          return !(
            (!(0, i.isNullish)(e.to) && !(0, i.isAddress)(e.to)) ||
            (!(0, i.isHexStrict)(e.type) &&
              !(0, i.isNullish)(e.type) &&
              2 !== e.type.length) ||
            !(0, i.isHexStrict)(e.nonce) ||
            !(0, i.isHexStrict)(e.gas) ||
            !(0, i.isHexStrict)(e.value) ||
            !(0, i.isHexStrict)(e.input) ||
            (e.chainId && !(0, i.isHexStrict)(e.chainId))
          );
        }
        function c(e) {
          return !(
            (!(0, i.isNullish)(e.address) && !(0, i.isAddress)(e.address)) ||
            (!(0, i.isNullish)(e.storageKeys) &&
              !e.storageKeys.every((e) => (0, i.isHexString32Bytes)(e)))
          );
        }
        function d(e) {
          return !(!Array.isArray(e) || !e.every((e) => c(e)));
        }
        function u(e) {
          return !!(
            a(e) &&
            (0, i.isHexStrict)(e.maxFeePerGas) &&
            (0, i.isHexStrict)(e.maxPriorityFeePerGas) &&
            d(e.accessList)
          );
        }
        function l(e) {
          return (
            !!a(e) && !!(0, i.isHexStrict)(e.gasPrice) && !!d(e.accessList)
          );
        }
        function h(e) {
          return !!a(e) && !!(0, i.isHexStrict)(e.gasPrice);
        }
        function f(e) {
          return (
            !!(0, i.isAddress)(e.from) && !!a(e) && !!(u(e) || l(e) || h(e))
          );
        }
        function p(e) {
          return !(
            (!(0, i.isNullish)(e.from) && !(0, i.isAddress)(e.from)) ||
            !(0, i.isAddress)(e.to) ||
            (!(0, i.isNullish)(e.gas) && !(0, i.isHexStrict)(e.gas)) ||
            (!(0, i.isNullish)(e.gasPrice) &&
              !(0, i.isHexStrict)(e.gasPrice)) ||
            (!(0, i.isNullish)(e.value) && !(0, i.isHexStrict)(e.value)) ||
            (!(0, i.isNullish)(e.data) && !(0, i.isHexStrict)(e.data)) ||
            (!(0, i.isNullish)(e.input) && !(0, i.isHexStrict)(e.input)) ||
            !(0, i.isNullish)(e.type) ||
            u(e) ||
            l(e)
          );
        }
        (t.isBaseTransaction = a),
          (t.isAccessListEntry = c),
          (t.isAccessList = d),
          (t.isTransaction1559Unsigned = u),
          (t.isTransaction2930Unsigned = l),
          (t.isTransactionLegacyUnsigned = h),
          (t.isTransactionWithSender = f),
          (t.validateTransactionWithSender = function (e) {
            if (!f(e)) throw new s.InvalidTransactionWithSender(e);
          }),
          (t.isTransactionCall = p),
          (t.validateTransactionCall = function (e) {
            if (!p(e)) throw new s.InvalidTransactionCall(e);
          }),
          (t.validateCustomChainInfo = (e) => {
            if (!(0, i.isNullish)(e.common)) {
              if ((0, i.isNullish)(e.common.customChain))
                throw new s.MissingCustomChainError();
              if ((0, i.isNullish)(e.common.customChain.chainId))
                throw new s.MissingCustomChainIdError();
              if (
                !(0, i.isNullish)(e.chainId) &&
                e.chainId !== e.common.customChain.chainId
              )
                throw new s.ChainIdMismatchError({
                  txChainId: e.chainId,
                  customChainId: e.common.customChain.chainId,
                });
            }
          }),
          (t.validateChainInfo = (e) => {
            if (
              !(0, i.isNullish)(e.common) &&
              !(0, i.isNullish)(e.chain) &&
              !(0, i.isNullish)(e.hardfork)
            )
              throw new s.CommonOrChainAndHardforkError();
            if (
              (!(0, i.isNullish)(e.chain) && (0, i.isNullish)(e.hardfork)) ||
              (!(0, i.isNullish)(e.hardfork) && (0, i.isNullish)(e.chain))
            )
              throw new s.MissingChainOrHardforkError({
                chain: e.chain,
                hardfork: e.hardfork,
              });
          }),
          (t.validateBaseChain = (e) => {
            if (
              !(0, i.isNullish)(e.common) &&
              !(0, i.isNullish)(e.common.baseChain) &&
              !(0, i.isNullish)(e.chain) &&
              e.chain !== e.common.baseChain
            )
              throw new s.ChainMismatchError({
                txChain: e.chain,
                baseChain: e.common.baseChain,
              });
          }),
          (t.validateHardfork = (e) => {
            if (
              !(0, i.isNullish)(e.common) &&
              !(0, i.isNullish)(e.common.hardfork) &&
              !(0, i.isNullish)(e.hardfork) &&
              e.hardfork !== e.common.hardfork
            )
              throw new s.HardforkMismatchError({
                txHardfork: e.hardfork,
                commonHardfork: e.common.hardfork,
              });
          }),
          (t.validateLegacyGas = (e) => {
            if (
              (0, i.isNullish)(e.gas) ||
              !(0, i.isUInt)(e.gas) ||
              (0, i.isNullish)(e.gasPrice) ||
              !(0, i.isUInt)(e.gasPrice)
            )
              throw new s.InvalidGasOrGasPrice({
                gas: e.gas,
                gasPrice: e.gasPrice,
              });
            if (
              !(0, i.isNullish)(e.maxFeePerGas) ||
              !(0, i.isNullish)(e.maxPriorityFeePerGas)
            )
              throw new s.UnsupportedFeeMarketError({
                maxFeePerGas: e.maxFeePerGas,
                maxPriorityFeePerGas: e.maxPriorityFeePerGas,
              });
          }),
          (t.validateFeeMarketGas = (e) => {
            if (!(0, i.isNullish)(e.gasPrice) && "0x2" === e.type)
              throw new s.Eip1559GasPriceError(e.gasPrice);
            if ("0x0" === e.type || "0x1" === e.type)
              throw new s.UnsupportedFeeMarketError({
                maxFeePerGas: e.maxFeePerGas,
                maxPriorityFeePerGas: e.maxPriorityFeePerGas,
              });
            if (
              (0, i.isNullish)(e.maxFeePerGas) ||
              !(0, i.isUInt)(e.maxFeePerGas) ||
              (0, i.isNullish)(e.maxPriorityFeePerGas) ||
              !(0, i.isUInt)(e.maxPriorityFeePerGas)
            )
              throw new s.InvalidMaxPriorityFeePerGasOrMaxFeePerGas({
                maxPriorityFeePerGas: e.maxPriorityFeePerGas,
                maxFeePerGas: e.maxFeePerGas,
              });
          }),
          (t.validateGas = (e) => {
            const r = !(0, i.isNullish)(e.gas) || !(0, i.isNullish)(e.gasLimit),
              n = r && !(0, i.isNullish)(e.gasPrice),
              o =
                r &&
                !(0, i.isNullish)(e.maxPriorityFeePerGas) &&
                !(0, i.isNullish)(e.maxFeePerGas);
            if (!n && !o)
              throw new s.MissingGasError({
                gas: e.gas,
                gasPrice: e.gasPrice,
                maxPriorityFeePerGas: e.maxPriorityFeePerGas,
                maxFeePerGas: e.maxFeePerGas,
              });
            if (n && o)
              throw new s.TransactionGasMismatchError({
                gas: e.gas,
                gasPrice: e.gasPrice,
                maxPriorityFeePerGas: e.maxPriorityFeePerGas,
                maxFeePerGas: e.maxFeePerGas,
              });
            (n ? t.validateLegacyGas : t.validateFeeMarketGas)(e),
              (!(0, i.isNullish)(e.type) && e.type > "0x1"
                ? t.validateFeeMarketGas
                : t.validateLegacyGas)(e);
          }),
          (t.validateTransactionForSigning = (e, r) => {
            if (!(0, i.isNullish)(r)) return void r(e);
            if ("object" != typeof e || (0, i.isNullish)(e))
              throw new s.InvalidTransactionObjectError(e);
            (0, t.validateCustomChainInfo)(e),
              (0, t.validateChainInfo)(e),
              (0, t.validateBaseChain)(e),
              (0, t.validateHardfork)(e);
            const a = (0, o.formatTransaction)(e, n.ETH_DATA_FORMAT);
            if (
              ((0, t.validateGas)(a),
              (0, i.isNullish)(a.nonce) ||
                (0, i.isNullish)(a.chainId) ||
                a.nonce.startsWith("-") ||
                a.chainId.startsWith("-"))
            )
              throw new s.InvalidNonceOrChainIdError({
                nonce: e.nonce,
                chainId: e.chainId,
              });
          });
      },
      6160: function (e, t, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (e, t, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(t, r);
                  (i &&
                    !("get" in i
                      ? !t.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return t[r];
                      },
                    }),
                    Object.defineProperty(e, n, i);
                }
              : function (e, t, r, n) {
                  void 0 === n && (n = r), (e[n] = t[r]);
                }),
          i =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (e, t) {
                  Object.defineProperty(e, "default", {
                    enumerable: !0,
                    value: t,
                  });
                }
              : function (e, t) {
                  e.default = t;
                }),
          s =
            (this && this.__importStar) ||
            function (e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(e, r) &&
                    n(t, e, r);
              return i(t, e), t;
            },
          o =
            (this && this.__awaiter) ||
            function (e, t, r, n) {
              return new (r || (r = Promise))(function (i, s) {
                function o(e) {
                  try {
                    c(n.next(e));
                  } catch (e) {
                    s(e);
                  }
                }
                function a(e) {
                  try {
                    c(n.throw(e));
                  } catch (e) {
                    s(e);
                  }
                }
                function c(e) {
                  var t;
                  e.done
                    ? i(e.value)
                    : ((t = e.value),
                      t instanceof r
                        ? t
                        : new r(function (e) {
                            e(t);
                          })).then(o, a);
                }
                c((n = n.apply(e, t || [])).next());
              });
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Web3Eth = t.registeredSubscriptions = void 0);
        const a = r(2823),
          c = r(8557),
          d = r(3087),
          u = r(9150),
          l = r(100),
          h = s(r(8829)),
          f = r(4156);
        t.registeredSubscriptions = {
          logs: f.LogsSubscription,
          newPendingTransactions: f.NewPendingTransactionsSubscription,
          newHeads: f.NewHeadsSubscription,
          syncing: f.SyncingSubscription,
          pendingTransactions: f.NewPendingTransactionsSubscription,
          newBlockHeaders: f.NewHeadsSubscription,
        };
        class p extends c.Web3Context {
          constructor(e) {
            "string" == typeof e || (0, c.isSupportedProvider)(e)
              ? super({
                  provider: e,
                  registeredSubscriptions: t.registeredSubscriptions,
                })
              : e.registeredSubscriptions
              ? super(e)
              : super(
                  Object.assign(Object.assign({}, e), {
                    registeredSubscriptions: t.registeredSubscriptions,
                  }),
                );
          }
          getProtocolVersion() {
            return o(this, void 0, void 0, function* () {
              return l.ethRpcMethods.getProtocolVersion(this.requestManager);
            });
          }
          isSyncing() {
            return o(this, void 0, void 0, function* () {
              return l.ethRpcMethods.getSyncing(this.requestManager);
            });
          }
          getCoinbase() {
            return o(this, void 0, void 0, function* () {
              return l.ethRpcMethods.getCoinbase(this.requestManager);
            });
          }
          isMining() {
            return o(this, void 0, void 0, function* () {
              return l.ethRpcMethods.getMining(this.requestManager);
            });
          }
          getHashrate(e = a.DEFAULT_RETURN_FORMAT) {
            return o(this, void 0, void 0, function* () {
              return this.getHashRate(e);
            });
          }
          getHashRate(e = a.DEFAULT_RETURN_FORMAT) {
            return o(this, void 0, void 0, function* () {
              return h.getHashRate(this, e);
            });
          }
          getGasPrice(e = a.DEFAULT_RETURN_FORMAT) {
            return o(this, void 0, void 0, function* () {
              return h.getGasPrice(this, e);
            });
          }
          getAccounts() {
            var e;
            return o(this, void 0, void 0, function* () {
              return (
                null !==
                  (e = yield l.ethRpcMethods.getAccounts(
                    this.requestManager,
                  )) && void 0 !== e
                  ? e
                  : []
              ).map((e) => (0, u.toChecksumAddress)(e));
            });
          }
          getBlockNumber(e = a.DEFAULT_RETURN_FORMAT) {
            return o(this, void 0, void 0, function* () {
              return h.getBlockNumber(this, e);
            });
          }
          getBalance(e, t = this.defaultBlock, r = a.DEFAULT_RETURN_FORMAT) {
            return o(this, void 0, void 0, function* () {
              return h.getBalance(this, e, t, r);
            });
          }
          getStorageAt(
            e,
            t,
            r = this.defaultBlock,
            n = a.DEFAULT_RETURN_FORMAT,
          ) {
            return o(this, void 0, void 0, function* () {
              return h.getStorageAt(this, e, t, r, n);
            });
          }
          getCode(e, t = this.defaultBlock, r = a.DEFAULT_RETURN_FORMAT) {
            return o(this, void 0, void 0, function* () {
              return h.getCode(this, e, t, r);
            });
          }
          getBlock(e = this.defaultBlock, t = !1, r = a.DEFAULT_RETURN_FORMAT) {
            return o(this, void 0, void 0, function* () {
              return h.getBlock(this, e, t, r);
            });
          }
          getBlockTransactionCount(
            e = this.defaultBlock,
            t = a.DEFAULT_RETURN_FORMAT,
          ) {
            return o(this, void 0, void 0, function* () {
              return h.getBlockTransactionCount(this, e, t);
            });
          }
          getBlockUncleCount(
            e = this.defaultBlock,
            t = a.DEFAULT_RETURN_FORMAT,
          ) {
            return o(this, void 0, void 0, function* () {
              return h.getBlockUncleCount(this, e, t);
            });
          }
          getUncle(e = this.defaultBlock, t, r = a.DEFAULT_RETURN_FORMAT) {
            return o(this, void 0, void 0, function* () {
              return h.getUncle(this, e, t, r);
            });
          }
          getTransaction(e, t = a.DEFAULT_RETURN_FORMAT) {
            return o(this, void 0, void 0, function* () {
              const r = yield h.getTransaction(this, e, t);
              if (!r) throw new d.TransactionNotFound();
              return r;
            });
          }
          getPendingTransactions(e = a.DEFAULT_RETURN_FORMAT) {
            return o(this, void 0, void 0, function* () {
              return h.getPendingTransactions(this, e);
            });
          }
          getTransactionFromBlock(
            e = this.defaultBlock,
            t,
            r = a.DEFAULT_RETURN_FORMAT,
          ) {
            return o(this, void 0, void 0, function* () {
              return h.getTransactionFromBlock(this, e, t, r);
            });
          }
          getTransactionReceipt(e, t = a.DEFAULT_RETURN_FORMAT) {
            return o(this, void 0, void 0, function* () {
              const r = yield h.getTransactionReceipt(this, e, t);
              if (!r) throw new d.TransactionNotFound();
              return r;
            });
          }
          getTransactionCount(
            e,
            t = this.defaultBlock,
            r = a.DEFAULT_RETURN_FORMAT,
          ) {
            return o(this, void 0, void 0, function* () {
              return h.getTransactionCount(this, e, t, r);
            });
          }
          sendTransaction(e, t = a.DEFAULT_RETURN_FORMAT, r) {
            return h.sendTransaction(this, e, t, r);
          }
          sendSignedTransaction(e, t = a.DEFAULT_RETURN_FORMAT, r) {
            return h.sendSignedTransaction(this, e, t, r);
          }
          sign(e, t, r = a.DEFAULT_RETURN_FORMAT) {
            return o(this, void 0, void 0, function* () {
              return h.sign(this, e, t, r);
            });
          }
          signTransaction(e, t = a.DEFAULT_RETURN_FORMAT) {
            return o(this, void 0, void 0, function* () {
              return h.signTransaction(this, e, t);
            });
          }
          call(e, t = this.defaultBlock, r = a.DEFAULT_RETURN_FORMAT) {
            return o(this, void 0, void 0, function* () {
              return h.call(this, e, t, r);
            });
          }
          estimateGas(e, t = this.defaultBlock, r = a.DEFAULT_RETURN_FORMAT) {
            return o(this, void 0, void 0, function* () {
              return h.estimateGas(this, e, t, r);
            });
          }
          getPastLogs(e, t = a.DEFAULT_RETURN_FORMAT) {
            return o(this, void 0, void 0, function* () {
              return h.getLogs(this, e, t);
            });
          }
          getWork() {
            return o(this, void 0, void 0, function* () {
              return l.ethRpcMethods.getWork(this.requestManager);
            });
          }
          submitWork(e, t, r) {
            return o(this, void 0, void 0, function* () {
              return l.ethRpcMethods.submitWork(this.requestManager, e, t, r);
            });
          }
          requestAccounts() {
            return o(this, void 0, void 0, function* () {
              return l.ethRpcMethods.requestAccounts(this.requestManager);
            });
          }
          getChainId(e = a.DEFAULT_RETURN_FORMAT) {
            return o(this, void 0, void 0, function* () {
              return h.getChainId(this, e);
            });
          }
          getNodeInfo() {
            return o(this, void 0, void 0, function* () {
              return l.ethRpcMethods.getNodeInfo(this.requestManager);
            });
          }
          getProof(e, t, r = this.defaultBlock, n = a.DEFAULT_RETURN_FORMAT) {
            return o(this, void 0, void 0, function* () {
              return h.getProof(this, e, t, r, n);
            });
          }
          getFeeHistory(
            e,
            t = this.defaultBlock,
            r,
            n = a.DEFAULT_RETURN_FORMAT,
          ) {
            return o(this, void 0, void 0, function* () {
              return h.getFeeHistory(this, e, t, r, n);
            });
          }
          createAccessList(
            e,
            t = this.defaultBlock,
            r = a.DEFAULT_RETURN_FORMAT,
          ) {
            return o(this, void 0, void 0, function* () {
              return h.createAccessList(this, e, t, r);
            });
          }
          signTypedData(e, t, r = !1, n = a.DEFAULT_RETURN_FORMAT) {
            return o(this, void 0, void 0, function* () {
              return h.signTypedData(this, e, t, r, n);
            });
          }
          subscribe(e, t, r = a.DEFAULT_RETURN_FORMAT) {
            var n;
            return o(this, void 0, void 0, function* () {
              const i = yield null === (n = this.subscriptionManager) ||
              void 0 === n
                ? void 0
                : n.subscribe(e, t, r);
              return (
                i instanceof f.LogsSubscription &&
                  "logs" === e &&
                  "object" == typeof t &&
                  !(0, u.isNullish)(t.fromBlock) &&
                  Number.isFinite(Number(t.fromBlock)) &&
                  setImmediate(() => {
                    this.getPastLogs(t)
                      .then((e) => {
                        for (const t of e) i._processSubscriptionResult(t);
                      })
                      .catch((e) => {
                        i._processSubscriptionError(e);
                      });
                  }),
                i
              );
            });
          }
          static shouldClearSubscription({ sub: e }) {
            return !(e instanceof f.SyncingSubscription);
          }
          clearSubscriptions(e = !1) {
            var t;
            return null === (t = this.subscriptionManager) || void 0 === t
              ? void 0
              : t.unsubscribe(e ? p.shouldClearSubscription : void 0);
          }
        }
        t.Web3Eth = p;
      },
      4156: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SyncingSubscription =
            t.NewHeadsSubscription =
            t.NewPendingTransactionsSubscription =
            t.LogsSubscription =
              void 0);
        const n = r(9150),
          i = r(8557),
          s = r(5127);
        class o extends i.Web3Subscription {
          _buildSubscriptionParams() {
            return ["logs", this.args];
          }
          formatSubscriptionResult(e) {
            return (0, n.format)(s.logSchema, e, super.returnFormat);
          }
        }
        t.LogsSubscription = o;
        class a extends i.Web3Subscription {
          _buildSubscriptionParams() {
            return ["newPendingTransactions"];
          }
          formatSubscriptionResult(e) {
            return (0, n.format)({ format: "string" }, e, super.returnFormat);
          }
        }
        t.NewPendingTransactionsSubscription = a;
        class c extends i.Web3Subscription {
          _buildSubscriptionParams() {
            return ["newHeads"];
          }
          formatSubscriptionResult(e) {
            return (0, n.format)(s.blockHeaderSchema, e, super.returnFormat);
          }
        }
        t.NewHeadsSubscription = c;
        class d extends i.Web3Subscription {
          _buildSubscriptionParams() {
            return ["syncing"];
          }
          _processSubscriptionResult(e) {
            if ("boolean" == typeof e) this.emit("changed", e);
            else {
              const t = Object.fromEntries(
                Object.entries(e.status).map(([e, t]) => [
                  e.charAt(0).toLowerCase() + e.substring(1),
                  t,
                ]),
              );
              this.emit("changed", e.syncing),
                this.emit(
                  "data",
                  (0, n.format)(s.syncSchema, t, super.returnFormat),
                );
            }
          }
        }
        t.SyncingSubscription = d;
      },
      6714: function (e, t, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (e, t, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(t, r);
                  (i &&
                    !("get" in i
                      ? !t.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return t[r];
                      },
                    }),
                    Object.defineProperty(e, n, i);
                }
              : function (e, t, r, n) {
                  void 0 === n && (n = r), (e[n] = t[r]);
                }),
          i =
            (this && this.__exportStar) ||
            function (e, t) {
              for (var r in e)
                "default" === r ||
                  Object.prototype.hasOwnProperty.call(t, r) ||
                  n(t, e, r);
            };
        Object.defineProperty(t, "__esModule", { value: !0 });
        const s = r(4913);
        i(r(4913), t), i(r(5923), t), (t.default = s.Net);
      },
      4913: function (e, t, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (e, t, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(t, r);
                  (i &&
                    !("get" in i
                      ? !t.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return t[r];
                      },
                    }),
                    Object.defineProperty(e, n, i);
                }
              : function (e, t, r, n) {
                  void 0 === n && (n = r), (e[n] = t[r]);
                }),
          i =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (e, t) {
                  Object.defineProperty(e, "default", {
                    enumerable: !0,
                    value: t,
                  });
                }
              : function (e, t) {
                  e.default = t;
                }),
          s =
            (this && this.__importStar) ||
            function (e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(e, r) &&
                    n(t, e, r);
              return i(t, e), t;
            },
          o =
            (this && this.__awaiter) ||
            function (e, t, r, n) {
              return new (r || (r = Promise))(function (i, s) {
                function o(e) {
                  try {
                    c(n.next(e));
                  } catch (e) {
                    s(e);
                  }
                }
                function a(e) {
                  try {
                    c(n.throw(e));
                  } catch (e) {
                    s(e);
                  }
                }
                function c(e) {
                  var t;
                  e.done
                    ? i(e.value)
                    : ((t = e.value),
                      t instanceof r
                        ? t
                        : new r(function (e) {
                            e(t);
                          })).then(o, a);
                }
                c((n = n.apply(e, t || [])).next());
              });
            };
        Object.defineProperty(t, "__esModule", { value: !0 }), (t.Net = void 0);
        const a = r(8557),
          c = r(2823),
          d = s(r(5923));
        class u extends a.Web3Context {
          getId(e = c.DEFAULT_RETURN_FORMAT) {
            return o(this, void 0, void 0, function* () {
              return d.getId(this, e);
            });
          }
          getPeerCount(e = c.DEFAULT_RETURN_FORMAT) {
            return o(this, void 0, void 0, function* () {
              return d.getPeerCount(this, e);
            });
          }
          isListening() {
            return o(this, void 0, void 0, function* () {
              return d.isListening(this);
            });
          }
        }
        t.Net = u;
      },
      5923: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__awaiter) ||
          function (e, t, r, n) {
            return new (r || (r = Promise))(function (i, s) {
              function o(e) {
                try {
                  c(n.next(e));
                } catch (e) {
                  s(e);
                }
              }
              function a(e) {
                try {
                  c(n.throw(e));
                } catch (e) {
                  s(e);
                }
              }
              function c(e) {
                var t;
                e.done
                  ? i(e.value)
                  : ((t = e.value),
                    t instanceof r
                      ? t
                      : new r(function (e) {
                          e(t);
                        })).then(o, a);
              }
              c((n = n.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.isListening = t.getPeerCount = t.getId = void 0);
        const i = r(9150),
          s = r(100);
        (t.getId = function (e, t) {
          return n(this, void 0, void 0, function* () {
            const r = yield s.netRpcMethods.getId(e.requestManager);
            return (0, i.format)({ format: "uint" }, r, t);
          });
        }),
          (t.getPeerCount = function (e, t) {
            return n(this, void 0, void 0, function* () {
              const r = yield s.netRpcMethods.getPeerCount(e.requestManager);
              return (0, i.format)({ format: "uint" }, r, t);
            });
          }),
          (t.isListening = (e) =>
            n(void 0, void 0, void 0, function* () {
              return s.netRpcMethods.isListening(e.requestManager);
            }));
      },
      9701: function (e, t, r) {
        "use strict";
        var n =
            (this && this.__awaiter) ||
            function (e, t, r, n) {
              return new (r || (r = Promise))(function (i, s) {
                function o(e) {
                  try {
                    c(n.next(e));
                  } catch (e) {
                    s(e);
                  }
                }
                function a(e) {
                  try {
                    c(n.throw(e));
                  } catch (e) {
                    s(e);
                  }
                }
                function c(e) {
                  var t;
                  e.done
                    ? i(e.value)
                    : ((t = e.value),
                      t instanceof r
                        ? t
                        : new r(function (e) {
                            e(t);
                          })).then(o, a);
                }
                c((n = n.apply(e, t || [])).next());
              });
            },
          i =
            (this && this.__importDefault) ||
            function (e) {
              return e && e.__esModule ? e : { default: e };
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.HttpProvider = void 0);
        const s = i(r(4098)),
          o = r(2823),
          a = r(3087);
        class c extends o.Web3BaseProvider {
          constructor(e, t) {
            if ((super(), !c.validateClientUrl(e)))
              throw new a.InvalidClientError(e);
            (this.clientUrl = e), (this.httpProviderOptions = t);
          }
          static validateClientUrl(e) {
            return "string" == typeof e && /^http(s)?:\/\//i.test(e);
          }
          getStatus() {
            throw new a.MethodNotImplementedError();
          }
          supportsSubscriptions() {
            return !1;
          }
          request(e, t) {
            var r;
            return n(this, void 0, void 0, function* () {
              const n = Object.assign(
                  Object.assign(
                    {},
                    null === (r = this.httpProviderOptions) || void 0 === r
                      ? void 0
                      : r.providerOptions,
                  ),
                  t,
                ),
                i = yield (0, s.default)(
                  this.clientUrl,
                  Object.assign(Object.assign({}, n), {
                    method: "POST",
                    headers: Object.assign(Object.assign({}, n.headers), {
                      "Content-Type": "application/json",
                    }),
                    body: JSON.stringify(e),
                  }),
                );
              if (!i.ok) throw new a.ResponseError(yield i.json());
              return yield i.json();
            });
          }
          on() {
            throw new a.MethodNotImplementedError();
          }
          removeListener() {
            throw new a.MethodNotImplementedError();
          }
          once() {
            throw new a.MethodNotImplementedError();
          }
          removeAllListeners() {
            throw new a.MethodNotImplementedError();
          }
          connect() {
            throw new a.MethodNotImplementedError();
          }
          disconnect() {
            throw new a.MethodNotImplementedError();
          }
          reset() {
            throw new a.MethodNotImplementedError();
          }
          reconnect() {
            throw new a.MethodNotImplementedError();
          }
        }
        (t.default = c), (t.HttpProvider = c);
      },
      4417: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__importDefault) ||
          function (e) {
            return e && e.__esModule ? e : { default: e };
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.WebSocketProvider = void 0);
        const i = n(r(8923)),
          s = r(9150),
          o = r(3087);
        class a extends s.SocketProvider {
          constructor(e, t, r) {
            super(e, t, r);
          }
          _validateProviderPath(e) {
            return "string" == typeof e && /^ws(s)?:\/\//i.test(e);
          }
          getStatus() {
            if (
              this._socketConnection &&
              !(0, s.isNullish)(this._socketConnection)
            )
              switch (this._socketConnection.readyState) {
                case this._socketConnection.CONNECTING:
                  return "connecting";
                case this._socketConnection.OPEN:
                  return "connected";
                default:
                  return "disconnected";
              }
            return "disconnected";
          }
          _openSocketConnection() {
            this._socketConnection = new i.default(
              this._socketPath,
              void 0,
              this._socketOptions &&
              0 === Object.keys(this._socketOptions).length
                ? void 0
                : this._socketOptions,
            );
          }
          _closeSocketConnection(e, t) {
            var r;
            null === (r = this._socketConnection) ||
              void 0 === r ||
              r.close(e, t);
          }
          _sendToSocket(e) {
            var t;
            if ("disconnected" === this.getStatus())
              throw new o.ConnectionNotOpenError();
            null === (t = this._socketConnection) ||
              void 0 === t ||
              t.send(JSON.stringify(e));
          }
          _parseResponses(e) {
            return this.chunkResponseParser.parseResponse(e.data);
          }
          _addSocketListeners() {
            var e, t, r, n;
            null === (e = this._socketConnection) ||
              void 0 === e ||
              e.addEventListener("open", this._onOpenHandler),
              null === (t = this._socketConnection) ||
                void 0 === t ||
                t.addEventListener("message", this._onMessageHandler),
              null === (r = this._socketConnection) ||
                void 0 === r ||
                r.addEventListener("close", (e) => this._onCloseHandler(e)),
              null === (n = this._socketConnection) ||
                void 0 === n ||
                n.addEventListener("error", this._onErrorHandler);
          }
          _removeSocketListeners() {
            var e, t, r;
            null === (e = this._socketConnection) ||
              void 0 === e ||
              e.removeEventListener("message", this._onMessageHandler),
              null === (t = this._socketConnection) ||
                void 0 === t ||
                t.removeEventListener("open", this._onOpenHandler),
              null === (r = this._socketConnection) ||
                void 0 === r ||
                r.removeEventListener("close", this._onCloseHandler);
          }
          _onCloseEvent(e) {
            var t;
            !this._reconnectOptions.autoReconnect ||
            ([1e3, 1001].includes(e.code) && e.wasClean)
              ? (this._clearQueues(e),
                this._removeSocketListeners(),
                this._onDisconnect(e.code, e.reason),
                null === (t = this._socketConnection) ||
                  void 0 === t ||
                  t.removeEventListener("error", this._onErrorHandler))
              : this._reconnect();
          }
        }
        (t.default = a), (t.WebSocketProvider = a);
      },
      7211: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__awaiter) ||
          function (e, t, r, n) {
            return new (r || (r = Promise))(function (i, s) {
              function o(e) {
                try {
                  c(n.next(e));
                } catch (e) {
                  s(e);
                }
              }
              function a(e) {
                try {
                  c(n.throw(e));
                } catch (e) {
                  s(e);
                }
              }
              function c(e) {
                var t;
                e.done
                  ? i(e.value)
                  : ((t = e.value),
                    t instanceof r
                      ? t
                      : new r(function (e) {
                          e(t);
                        })).then(o, a);
              }
              c((n = n.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getNodeInfo =
            t.getProof =
            t.getChainId =
            t.requestAccounts =
            t.getPendingTransactions =
            t.getFeeHistory =
            t.submitHashrate =
            t.submitWork =
            t.getWork =
            t.getLogs =
            t.getFilterLogs =
            t.getFilterChanges =
            t.uninstallFilter =
            t.newPendingTransactionFilter =
            t.newBlockFilter =
            t.newFilter =
            t.compileSerpent =
            t.compileLLL =
            t.compileSolidity =
            t.getCompilers =
            t.getUncleByBlockNumberAndIndex =
            t.getUncleByBlockHashAndIndex =
            t.getTransactionReceipt =
            t.getTransactionByBlockNumberAndIndex =
            t.getTransactionByBlockHashAndIndex =
            t.getTransactionByHash =
            t.getBlockByNumber =
            t.getBlockByHash =
            t.estimateGas =
            t.call =
            t.sendRawTransaction =
            t.sendTransaction =
            t.signTransaction =
            t.sign =
            t.getCode =
            t.getUncleCountByBlockNumber =
            t.getUncleCountByBlockHash =
            t.getBlockTransactionCountByNumber =
            t.getBlockTransactionCountByHash =
            t.getTransactionCount =
            t.getStorageAt =
            t.getBalance =
            t.getBlockNumber =
            t.getAccounts =
            t.getGasPrice =
            t.getHashRate =
            t.getMining =
            t.getCoinbase =
            t.getSyncing =
            t.getProtocolVersion =
              void 0),
          (t.signTypedData = t.createAccessList = void 0);
        const i = r(8840);
        (t.getProtocolVersion = function (e) {
          return n(this, void 0, void 0, function* () {
            return e.send({ method: "eth_protocolVersion", params: [] });
          });
        }),
          (t.getSyncing = function (e) {
            return n(this, void 0, void 0, function* () {
              return e.send({ method: "eth_syncing", params: [] });
            });
          }),
          (t.getCoinbase = function (e) {
            return n(this, void 0, void 0, function* () {
              return e.send({ method: "eth_coinbase", params: [] });
            });
          }),
          (t.getMining = function (e) {
            return n(this, void 0, void 0, function* () {
              return e.send({ method: "eth_mining", params: [] });
            });
          }),
          (t.getHashRate = function (e) {
            return n(this, void 0, void 0, function* () {
              return e.send({ method: "eth_hashrate", params: [] });
            });
          }),
          (t.getGasPrice = function (e) {
            return n(this, void 0, void 0, function* () {
              return e.send({ method: "eth_gasPrice", params: [] });
            });
          }),
          (t.getAccounts = function (e) {
            return n(this, void 0, void 0, function* () {
              return e.send({ method: "eth_accounts", params: [] });
            });
          }),
          (t.getBlockNumber = function (e) {
            return n(this, void 0, void 0, function* () {
              return e.send({ method: "eth_blockNumber", params: [] });
            });
          }),
          (t.getBalance = function (e, t, r) {
            return n(this, void 0, void 0, function* () {
              return (
                i.validator.validate(["address", "blockNumberOrTag"], [t, r]),
                e.send({ method: "eth_getBalance", params: [t, r] })
              );
            });
          }),
          (t.getStorageAt = function (e, t, r, s) {
            return n(this, void 0, void 0, function* () {
              return (
                i.validator.validate(
                  ["address", "hex", "blockNumberOrTag"],
                  [t, r, s],
                ),
                e.send({ method: "eth_getStorageAt", params: [t, r, s] })
              );
            });
          }),
          (t.getTransactionCount = function (e, t, r) {
            return n(this, void 0, void 0, function* () {
              return (
                i.validator.validate(["address", "blockNumberOrTag"], [t, r]),
                e.send({ method: "eth_getTransactionCount", params: [t, r] })
              );
            });
          }),
          (t.getBlockTransactionCountByHash = function (e, t) {
            return n(this, void 0, void 0, function* () {
              return (
                i.validator.validate(["bytes32"], [t]),
                e.send({
                  method: "eth_getBlockTransactionCountByHash",
                  params: [t],
                })
              );
            });
          }),
          (t.getBlockTransactionCountByNumber = function (e, t) {
            return n(this, void 0, void 0, function* () {
              return (
                i.validator.validate(["blockNumberOrTag"], [t]),
                e.send({
                  method: "eth_getBlockTransactionCountByNumber",
                  params: [t],
                })
              );
            });
          }),
          (t.getUncleCountByBlockHash = function (e, t) {
            return n(this, void 0, void 0, function* () {
              return (
                i.validator.validate(["bytes32"], [t]),
                e.send({ method: "eth_getUncleCountByBlockHash", params: [t] })
              );
            });
          }),
          (t.getUncleCountByBlockNumber = function (e, t) {
            return n(this, void 0, void 0, function* () {
              return (
                i.validator.validate(["blockNumberOrTag"], [t]),
                e.send({
                  method: "eth_getUncleCountByBlockNumber",
                  params: [t],
                })
              );
            });
          }),
          (t.getCode = function (e, t, r) {
            return n(this, void 0, void 0, function* () {
              return (
                i.validator.validate(["address", "blockNumberOrTag"], [t, r]),
                e.send({ method: "eth_getCode", params: [t, r] })
              );
            });
          }),
          (t.sign = function (e, t, r) {
            return n(this, void 0, void 0, function* () {
              return (
                i.validator.validate(["address", "hex"], [t, r]),
                e.send({ method: "eth_sign", params: [t, r] })
              );
            });
          }),
          (t.signTransaction = function (e, t) {
            return n(this, void 0, void 0, function* () {
              return e.send({ method: "eth_signTransaction", params: [t] });
            });
          }),
          (t.sendTransaction = function (e, t) {
            return n(this, void 0, void 0, function* () {
              return e.send({ method: "eth_sendTransaction", params: [t] });
            });
          }),
          (t.sendRawTransaction = function (e, t) {
            return n(this, void 0, void 0, function* () {
              return (
                i.validator.validate(["hex"], [t]),
                e.send({ method: "eth_sendRawTransaction", params: [t] })
              );
            });
          }),
          (t.call = function (e, t, r) {
            return n(this, void 0, void 0, function* () {
              return (
                i.validator.validate(["blockNumberOrTag"], [r]),
                e.send({ method: "eth_call", params: [t, r] })
              );
            });
          }),
          (t.estimateGas = function (e, t, r) {
            return n(this, void 0, void 0, function* () {
              return (
                i.validator.validate(["blockNumberOrTag"], [r]),
                e.send({ method: "eth_estimateGas", params: [t, r] })
              );
            });
          }),
          (t.getBlockByHash = function (e, t, r) {
            return n(this, void 0, void 0, function* () {
              return (
                i.validator.validate(["bytes32", "bool"], [t, r]),
                e.send({ method: "eth_getBlockByHash", params: [t, r] })
              );
            });
          }),
          (t.getBlockByNumber = function (e, t, r) {
            return n(this, void 0, void 0, function* () {
              return (
                i.validator.validate(["blockNumberOrTag", "bool"], [t, r]),
                e.send({ method: "eth_getBlockByNumber", params: [t, r] })
              );
            });
          }),
          (t.getTransactionByHash = function (e, t) {
            return n(this, void 0, void 0, function* () {
              return (
                i.validator.validate(["bytes32"], [t]),
                e.send({ method: "eth_getTransactionByHash", params: [t] })
              );
            });
          }),
          (t.getTransactionByBlockHashAndIndex = function (e, t, r) {
            return n(this, void 0, void 0, function* () {
              return (
                i.validator.validate(["bytes32", "hex"], [t, r]),
                e.send({
                  method: "eth_getTransactionByBlockHashAndIndex",
                  params: [t, r],
                })
              );
            });
          }),
          (t.getTransactionByBlockNumberAndIndex = function (e, t, r) {
            return n(this, void 0, void 0, function* () {
              return (
                i.validator.validate(["blockNumberOrTag", "hex"], [t, r]),
                e.send({
                  method: "eth_getTransactionByBlockNumberAndIndex",
                  params: [t, r],
                })
              );
            });
          }),
          (t.getTransactionReceipt = function (e, t) {
            return n(this, void 0, void 0, function* () {
              return (
                i.validator.validate(["bytes32"], [t]),
                e.send({ method: "eth_getTransactionReceipt", params: [t] })
              );
            });
          }),
          (t.getUncleByBlockHashAndIndex = function (e, t, r) {
            return n(this, void 0, void 0, function* () {
              return (
                i.validator.validate(["bytes32", "hex"], [t, r]),
                e.send({
                  method: "eth_getUncleByBlockHashAndIndex",
                  params: [t, r],
                })
              );
            });
          }),
          (t.getUncleByBlockNumberAndIndex = function (e, t, r) {
            return n(this, void 0, void 0, function* () {
              return (
                i.validator.validate(["blockNumberOrTag", "hex"], [t, r]),
                e.send({
                  method: "eth_getUncleByBlockNumberAndIndex",
                  params: [t, r],
                })
              );
            });
          }),
          (t.getCompilers = function (e) {
            return n(this, void 0, void 0, function* () {
              return e.send({ method: "eth_getCompilers", params: [] });
            });
          }),
          (t.compileSolidity = function (e, t) {
            return n(this, void 0, void 0, function* () {
              return (
                i.validator.validate(["string"], [t]),
                e.send({ method: "eth_compileSolidity", params: [t] })
              );
            });
          }),
          (t.compileLLL = function (e, t) {
            return n(this, void 0, void 0, function* () {
              return (
                i.validator.validate(["string"], [t]),
                e.send({ method: "eth_compileLLL", params: [t] })
              );
            });
          }),
          (t.compileSerpent = function (e, t) {
            return n(this, void 0, void 0, function* () {
              return (
                i.validator.validate(["string"], [t]),
                e.send({ method: "eth_compileSerpent", params: [t] })
              );
            });
          }),
          (t.newFilter = function (e, t) {
            return n(this, void 0, void 0, function* () {
              return (
                i.validator.validate(["filter"], [t]),
                e.send({ method: "eth_newFilter", params: [t] })
              );
            });
          }),
          (t.newBlockFilter = function (e) {
            return n(this, void 0, void 0, function* () {
              return e.send({ method: "eth_newBlockFilter", params: [] });
            });
          }),
          (t.newPendingTransactionFilter = function (e) {
            return n(this, void 0, void 0, function* () {
              return e.send({
                method: "eth_newPendingTransactionFilter",
                params: [],
              });
            });
          }),
          (t.uninstallFilter = function (e, t) {
            return n(this, void 0, void 0, function* () {
              return (
                i.validator.validate(["hex"], [t]),
                e.send({ method: "eth_uninstallFilter", params: [t] })
              );
            });
          }),
          (t.getFilterChanges = function (e, t) {
            return n(this, void 0, void 0, function* () {
              return (
                i.validator.validate(["hex"], [t]),
                e.send({ method: "eth_getFilterChanges", params: [t] })
              );
            });
          }),
          (t.getFilterLogs = function (e, t) {
            return n(this, void 0, void 0, function* () {
              return (
                i.validator.validate(["hex"], [t]),
                e.send({ method: "eth_getFilterLogs", params: [t] })
              );
            });
          }),
          (t.getLogs = function (e, t) {
            return n(this, void 0, void 0, function* () {
              return (
                i.validator.validate(["filter"], [t]),
                e.send({ method: "eth_getLogs", params: [t] })
              );
            });
          }),
          (t.getWork = function (e) {
            return n(this, void 0, void 0, function* () {
              return e.send({ method: "eth_getWork", params: [] });
            });
          }),
          (t.submitWork = function (e, t, r, s) {
            return n(this, void 0, void 0, function* () {
              return (
                i.validator.validate(
                  ["bytes8", "bytes32", "bytes32"],
                  [t, r, s],
                ),
                e.send({ method: "eth_submitWork", params: [t, r, s] })
              );
            });
          }),
          (t.submitHashrate = function (e, t, r) {
            return n(this, void 0, void 0, function* () {
              return (
                i.validator.validate(["bytes32", "bytes32"], [t, r]),
                e.send({ method: "eth_submitHashrate", params: [t, r] })
              );
            });
          }),
          (t.getFeeHistory = function (e, t, r, s) {
            return n(this, void 0, void 0, function* () {
              i.validator.validate(["hex", "blockNumberOrTag"], [t, r]);
              for (const e of s) i.validator.validate(["number"], [e]);
              return e.send({ method: "eth_feeHistory", params: [t, r, s] });
            });
          }),
          (t.getPendingTransactions = function (e) {
            return n(this, void 0, void 0, function* () {
              return e.send({ method: "eth_pendingTransactions", params: [] });
            });
          }),
          (t.requestAccounts = function (e) {
            return n(this, void 0, void 0, function* () {
              return e.send({ method: "eth_requestAccounts", params: [] });
            });
          }),
          (t.getChainId = function (e) {
            return n(this, void 0, void 0, function* () {
              return e.send({ method: "eth_chainId", params: [] });
            });
          }),
          (t.getProof = function (e, t, r, s) {
            return n(this, void 0, void 0, function* () {
              return (
                i.validator.validate(
                  ["address", "bytes32[]", "blockNumberOrTag"],
                  [t, r, s],
                ),
                e.send({ method: "eth_getProof", params: [t, r, s] })
              );
            });
          }),
          (t.getNodeInfo = function (e) {
            return n(this, void 0, void 0, function* () {
              return e.send({ method: "web3_clientVersion", params: [] });
            });
          }),
          (t.createAccessList = function (e, t, r) {
            return n(this, void 0, void 0, function* () {
              return (
                i.validator.validate(["blockNumberOrTag"], [r]),
                e.send({ method: "eth_createAccessList", params: [t, r] })
              );
            });
          }),
          (t.signTypedData = function (e, t, r, s = !1) {
            return n(this, void 0, void 0, function* () {
              return (
                i.validator.validate(["address"], [t]),
                e.send({
                  method: "eth_signTypedData" + (s ? "" : "_v4"),
                  params: [t, r],
                })
              );
            });
          });
      },
      100: function (e, t, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (e, t, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(t, r);
                  (i &&
                    !("get" in i
                      ? !t.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return t[r];
                      },
                    }),
                    Object.defineProperty(e, n, i);
                }
              : function (e, t, r, n) {
                  void 0 === n && (n = r), (e[n] = t[r]);
                }),
          i =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (e, t) {
                  Object.defineProperty(e, "default", {
                    enumerable: !0,
                    value: t,
                  });
                }
              : function (e, t) {
                  e.default = t;
                }),
          s =
            (this && this.__importStar) ||
            function (e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(e, r) &&
                    n(t, e, r);
              return i(t, e), t;
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.personalRpcMethods = t.netRpcMethods = t.ethRpcMethods = void 0);
        const o = s(r(7211));
        t.ethRpcMethods = o;
        const a = s(r(9509));
        t.netRpcMethods = a;
        const c = s(r(4309));
        t.personalRpcMethods = c;
      },
      9509: function (e, t) {
        "use strict";
        var r =
          (this && this.__awaiter) ||
          function (e, t, r, n) {
            return new (r || (r = Promise))(function (i, s) {
              function o(e) {
                try {
                  c(n.next(e));
                } catch (e) {
                  s(e);
                }
              }
              function a(e) {
                try {
                  c(n.throw(e));
                } catch (e) {
                  s(e);
                }
              }
              function c(e) {
                var t;
                e.done
                  ? i(e.value)
                  : ((t = e.value),
                    t instanceof r
                      ? t
                      : new r(function (e) {
                          e(t);
                        })).then(o, a);
              }
              c((n = n.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.isListening = t.getPeerCount = t.getId = void 0),
          (t.getId = function (e) {
            return r(this, void 0, void 0, function* () {
              return e.send({ method: "net_version", params: [] });
            });
          }),
          (t.getPeerCount = function (e) {
            return r(this, void 0, void 0, function* () {
              return e.send({ method: "net_peerCount", params: [] });
            });
          }),
          (t.isListening = function (e) {
            return r(this, void 0, void 0, function* () {
              return e.send({ method: "net_listening", params: [] });
            });
          });
      },
      4309: function (e, t) {
        "use strict";
        var r =
          (this && this.__awaiter) ||
          function (e, t, r, n) {
            return new (r || (r = Promise))(function (i, s) {
              function o(e) {
                try {
                  c(n.next(e));
                } catch (e) {
                  s(e);
                }
              }
              function a(e) {
                try {
                  c(n.throw(e));
                } catch (e) {
                  s(e);
                }
              }
              function c(e) {
                var t;
                e.done
                  ? i(e.value)
                  : ((t = e.value),
                    t instanceof r
                      ? t
                      : new r(function (e) {
                          e(t);
                        })).then(o, a);
              }
              c((n = n.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ecRecover =
            t.sign =
            t.signTransaction =
            t.sendTransaction =
            t.importRawKey =
            t.lockAccount =
            t.unlockAccount =
            t.newAccount =
            t.getAccounts =
              void 0),
          (t.getAccounts = (e) =>
            r(void 0, void 0, void 0, function* () {
              return e.send({ method: "personal_listAccounts", params: [] });
            })),
          (t.newAccount = (e, t) =>
            r(void 0, void 0, void 0, function* () {
              return e.send({ method: "personal_newAccount", params: [t] });
            })),
          (t.unlockAccount = (e, t, n, i) =>
            r(void 0, void 0, void 0, function* () {
              return e.send({
                method: "personal_unlockAccount",
                params: [t, n, i],
              });
            })),
          (t.lockAccount = (e, t) =>
            r(void 0, void 0, void 0, function* () {
              return e.send({ method: "personal_lockAccount", params: [t] });
            })),
          (t.importRawKey = (e, t, n) =>
            r(void 0, void 0, void 0, function* () {
              return e.send({
                method: "personal_importRawKey",
                params: [t, n],
              });
            })),
          (t.sendTransaction = (e, t, n) =>
            r(void 0, void 0, void 0, function* () {
              return e.send({
                method: "personal_sendTransaction",
                params: [t, n],
              });
            })),
          (t.signTransaction = (e, t, n) =>
            r(void 0, void 0, void 0, function* () {
              return e.send({
                method: "personal_signTransaction",
                params: [t, n],
              });
            })),
          (t.sign = (e, t, n, i) =>
            r(void 0, void 0, void 0, function* () {
              return e.send({ method: "personal_sign", params: [t, n, i] });
            })),
          (t.ecRecover = (e, t, n) =>
            r(void 0, void 0, void 0, function* () {
              return e.send({ method: "personal_ecRecover", params: [t, n] });
            }));
      },
      9754: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
      },
      1952: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
      },
      1890: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
      },
      9624: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
      },
      4003: (e, t) => {
        "use strict";
        var r, n;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ETH_DATA_FORMAT =
            t.DEFAULT_RETURN_FORMAT =
            t.FMT_BYTES =
            t.FMT_NUMBER =
              void 0),
          (function (e) {
            (e.NUMBER = "NUMBER_NUMBER"),
              (e.HEX = "NUMBER_HEX"),
              (e.STR = "NUMBER_STR"),
              (e.BIGINT = "NUMBER_BIGINT");
          })((r = t.FMT_NUMBER || (t.FMT_NUMBER = {}))),
          (function (e) {
            (e.HEX = "BYTES_HEX"), (e.UINT8ARRAY = "BYTES_UINT8ARRAY");
          })((n = t.FMT_BYTES || (t.FMT_BYTES = {}))),
          (t.DEFAULT_RETURN_FORMAT = { number: r.BIGINT, bytes: n.HEX }),
          (t.ETH_DATA_FORMAT = { number: r.HEX, bytes: n.HEX });
      },
      7234: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
      },
      9914: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
      },
      4790: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
      },
      1488: (e, t) => {
        "use strict";
        var r, n;
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.HardforksOrdered = t.BlockTags = void 0),
          ((n = t.BlockTags || (t.BlockTags = {})).EARLIEST = "earliest"),
          (n.LATEST = "latest"),
          (n.PENDING = "pending"),
          (n.SAFE = "safe"),
          (n.FINALIZED = "finalized"),
          ((r = t.HardforksOrdered || (t.HardforksOrdered = {})).chainstart =
            "chainstart"),
          (r.frontier = "frontier"),
          (r.homestead = "homestead"),
          (r.dao = "dao"),
          (r.tangerineWhistle = "tangerineWhistle"),
          (r.spuriousDragon = "spuriousDragon"),
          (r.byzantium = "byzantium"),
          (r.constantinople = "constantinople"),
          (r.petersburg = "petersburg"),
          (r.istanbul = "istanbul"),
          (r.muirGlacier = "muirGlacier"),
          (r.berlin = "berlin"),
          (r.london = "london"),
          (r.altair = "altair"),
          (r.arrowGlacier = "arrowGlacier"),
          (r.grayGlacier = "grayGlacier"),
          (r.bellatrix = "bellatrix"),
          (r.merge = "merge"),
          (r.capella = "capella"),
          (r.shanghai = "shanghai");
      },
      2823: function (e, t, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (e, t, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(t, r);
                  (i &&
                    !("get" in i
                      ? !t.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return t[r];
                      },
                    }),
                    Object.defineProperty(e, n, i);
                }
              : function (e, t, r, n) {
                  void 0 === n && (n = r), (e[n] = t[r]);
                }),
          i =
            (this && this.__exportStar) ||
            function (e, t) {
              for (var r in e)
                "default" === r ||
                  Object.prototype.hasOwnProperty.call(t, r) ||
                  n(t, e, r);
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          i(r(7234), t),
          i(r(9754), t),
          i(r(1890), t),
          i(r(9624), t),
          i(r(1952), t),
          i(r(4003), t),
          i(r(1488), t),
          i(r(9914), t),
          i(r(4790), t),
          i(r(6301), t),
          i(r(6148), t),
          i(r(4145), t),
          i(r(6077), t),
          i(r(7162), t),
          i(r(8624), t),
          i(r(8447), t);
      },
      6301: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
      },
      6148: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.TypedArray = void 0),
          (t.TypedArray = Object.getPrototypeOf(Uint8Array));
      },
      4145: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
      },
      6077: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
      },
      7162: function (e, t) {
        "use strict";
        var r =
          (this && this.__awaiter) ||
          function (e, t, r, n) {
            return new (r || (r = Promise))(function (i, s) {
              function o(e) {
                try {
                  c(n.next(e));
                } catch (e) {
                  s(e);
                }
              }
              function a(e) {
                try {
                  c(n.throw(e));
                } catch (e) {
                  s(e);
                }
              }
              function c(e) {
                var t;
                e.done
                  ? i(e.value)
                  : ((t = e.value),
                    t instanceof r
                      ? t
                      : new r(function (e) {
                          e(t);
                        })).then(o, a);
              }
              c((n = n.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Web3BaseProvider = void 0);
        const n = Symbol.for("web3/base-provider");
        class i {
          static isWeb3Provider(e) {
            return e instanceof i || Boolean(e && e[n]);
          }
          get [n]() {
            return !0;
          }
          send(e, t) {
            this.request(e)
              .then((e) => {
                t(null, e);
              })
              .catch((e) => {
                t(e);
              });
          }
          sendAsync(e) {
            return r(this, void 0, void 0, function* () {
              return this.request(e);
            });
          }
        }
        t.Web3BaseProvider = i;
      },
      8624: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Web3BaseWallet = void 0),
          (t.Web3BaseWallet = class extends Array {
            constructor(e) {
              super(), (this._accountProvider = e);
            }
          });
      },
      8447: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
      },
      1285: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ChunkResponseParser = void 0);
        const n = r(3087);
        t.ChunkResponseParser = class {
          constructor(e, t) {
            (this.eventEmitter = e), (this.autoReconnect = t);
          }
          clearQueues() {
            "function" == typeof this._clearQueues && this._clearQueues();
          }
          onError(e) {
            this._clearQueues = e;
          }
          parseResponse(e) {
            const t = [];
            return (
              e
                .replace(/\}[\n\r]?\{/g, "}|--|{")
                .replace(/\}\][\n\r]?\[\{/g, "}]|--|[{")
                .replace(/\}[\n\r]?\[\{/g, "}|--|[{")
                .replace(/\}\][\n\r]?\{/g, "}]|--|{")
                .split("|--|")
                .forEach((e) => {
                  let r,
                    i = e;
                  this.lastChunk && (i = this.lastChunk + i);
                  try {
                    r = JSON.parse(i);
                  } catch (e) {
                    return (
                      (this.lastChunk = i),
                      this.lastChunkTimeout &&
                        clearTimeout(this.lastChunkTimeout),
                      void (this.lastChunkTimeout = setTimeout(() => {
                        this.autoReconnect ||
                          (this.clearQueues(),
                          this.eventEmitter.emit(
                            "error",
                            new n.InvalidResponseError({
                              id: 1,
                              jsonrpc: "2.0",
                              error: { code: 2, message: "Chunk timeout" },
                            }),
                          ));
                      }, 15e3))
                    );
                  }
                  clearTimeout(this.lastChunkTimeout),
                    (this.lastChunk = void 0),
                    r && t.push(r);
                }),
              t
            );
          }
        };
      },
      1805: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.toChecksumAddress =
            t.toWei =
            t.fromWei =
            t.toBigInt =
            t.toNumber =
            t.toHex =
            t.toAscii =
            t.hexToAscii =
            t.fromAscii =
            t.asciiToHex =
            t.hexToString =
            t.toUtf8 =
            t.hexToUtf8 =
            t.stringToHex =
            t.fromUtf8 =
            t.utf8ToHex =
            t.hexToNumberString =
            t.fromDecimal =
            t.numberToHex =
            t.toDecimal =
            t.hexToNumber =
            t.hexToBytes =
            t.bytesToHex =
            t.bytesToUint8Array =
            t.ethUnitMap =
              void 0);
        const n = r(2192),
          i = r(8040),
          s = r(8840),
          o = r(3087),
          a = BigInt(10),
          c = (e) => a ** BigInt(e);
        (t.ethUnitMap = {
          noether: BigInt("0"),
          wei: BigInt(1),
          kwei: c(3),
          Kwei: c(3),
          babbage: c(3),
          femtoether: c(3),
          mwei: c(6),
          Mwei: c(6),
          lovelace: c(6),
          picoether: c(6),
          gwei: c(9),
          Gwei: c(9),
          shannon: c(9),
          nanoether: c(9),
          nano: c(9),
          szabo: c(12),
          microether: c(12),
          micro: c(12),
          finney: c(15),
          milliether: c(15),
          milli: c(15),
          ether: c(18),
          kether: c(21),
          grand: c(21),
          mether: c(24),
          gether: c(27),
          tether: c(30),
        }),
          (t.bytesToUint8Array = (e) => {
            if ((s.validator.validate(["bytes"], [e]), e instanceof Uint8Array))
              return e;
            if (Array.isArray(e)) return new Uint8Array(e);
            if ("string" == typeof e) return s.utils.hexToUint8Array(e);
            throw new o.InvalidBytesError(e);
          });
        const { uint8ArrayToHexString: d } = s.utils;
        (t.bytesToHex = (e) => d((0, t.bytesToUint8Array)(e))),
          (t.hexToBytes = (e) =>
            "string" == typeof e && "0x" !== e.slice(0, 2).toLowerCase()
              ? (0, t.bytesToUint8Array)(`0x${e}`)
              : (0, t.bytesToUint8Array)(e)),
          (t.hexToNumber = (e) => (
            s.validator.validate(["hex"], [e]), s.utils.hexToNumber(e)
          )),
          (t.toDecimal = t.hexToNumber),
          (t.numberToHex = (e, t) => {
            "bigint" != typeof e && s.validator.validate(["int"], [e]);
            let r = s.utils.numberToHex(e);
            return (
              t &&
                (r.startsWith("-") || r.length % 2 != 1
                  ? r.length % 2 == 0 &&
                    r.startsWith("-") &&
                    (r = "-0x0".concat(r.slice(3)))
                  : (r = "0x0".concat(r.slice(2)))),
              r
            );
          }),
          (t.fromDecimal = t.numberToHex),
          (t.hexToNumberString = (e) => (0, t.hexToNumber)(e).toString()),
          (t.utf8ToHex = (e) => {
            s.validator.validate(["string"], [e]);
            let r = e.replace(/^(?:\u0000)/, "");
            return (
              (r = r.replace(/(?:\u0000)$/, "")),
              (0, t.bytesToHex)(new TextEncoder().encode(r))
            );
          }),
          (t.fromUtf8 = t.utf8ToHex),
          (t.stringToHex = t.utf8ToHex),
          (t.hexToUtf8 = (e) => (0, i.bytesToUtf8)((0, t.hexToBytes)(e))),
          (t.toUtf8 = (e) =>
            "string" == typeof e
              ? (0, t.hexToUtf8)(e)
              : (s.validator.validate(["bytes"], [e]), (0, i.bytesToUtf8)(e))),
          (t.hexToString = t.hexToUtf8),
          (t.asciiToHex = (e) => {
            s.validator.validate(["string"], [e]);
            let t = "";
            for (let r = 0; r < e.length; r += 1) {
              const n = e.charCodeAt(r).toString(16);
              t += n.length % 2 != 0 ? `0${n}` : n;
            }
            return `0x${t}`;
          }),
          (t.fromAscii = t.asciiToHex),
          (t.hexToAscii = (e) =>
            new TextDecoder("ascii").decode((0, t.hexToBytes)(e))),
          (t.toAscii = t.hexToAscii),
          (t.toHex = (e, r) => {
            if ("string" == typeof e && (0, s.isAddress)(e))
              return r ? "address" : `0x${e.toLowerCase().replace(/^0x/i, "")}`;
            if ("boolean" == typeof e) return r ? "bool" : e ? "0x01" : "0x00";
            if ("number" == typeof e)
              return r ? (e < 0 ? "int256" : "uint256") : (0, t.numberToHex)(e);
            if ("bigint" == typeof e)
              return r ? "bigint" : (0, t.numberToHex)(e);
            if ("object" == typeof e && e)
              return r ? "string" : (0, t.utf8ToHex)(JSON.stringify(e));
            if ("string" == typeof e) {
              if (e.startsWith("-0x") || e.startsWith("-0X"))
                return r ? "int256" : (0, t.numberToHex)(e);
              if ((0, s.isHexStrict)(e)) return r ? "bytes" : e;
              if ((0, s.isHex)(e) && !(0, s.isInt)(e))
                return r ? "bytes" : `0x${e}`;
              if (!Number.isFinite(e))
                return r ? "string" : (0, t.utf8ToHex)(e);
            }
            throw new o.HexProcessingError(e);
          }),
          (t.toNumber = (e) => {
            if ("number" == typeof e) return e;
            if ("bigint" == typeof e)
              return e >= Number.MIN_SAFE_INTEGER &&
                e <= Number.MAX_SAFE_INTEGER
                ? Number(e)
                : e;
            if ("string" == typeof e && (0, s.isHexStrict)(e))
              return (0, t.hexToNumber)(e);
            try {
              return (0, t.toNumber)(BigInt(e));
            } catch (t) {
              throw new o.InvalidNumberError(e);
            }
          }),
          (t.toBigInt = (e) => {
            if ("number" == typeof e) return BigInt(e);
            if ("bigint" == typeof e) return e;
            if ("string" == typeof e && (0, s.isHex)(e)) return BigInt(e);
            throw new o.InvalidNumberError(e);
          }),
          (t.fromWei = (e, r) => {
            const n = t.ethUnitMap[r];
            if (!n) throw new o.InvalidUnitError(r);
            const i = String((0, t.toNumber)(e)),
              s = n.toString().length - 1;
            if (s <= 0) return i.toString();
            const a = i.padStart(s, "0"),
              c = a.slice(0, -s),
              d = a.slice(-s).replace(/\.?0+$/, "");
            return "" === c ? `0.${d}` : "" === d ? c : `${c}.${d}`;
          }),
          (t.toWei = (e, r) => {
            s.validator.validate(["number"], [e]);
            const n = t.ethUnitMap[r];
            if (!n) throw new o.InvalidUnitError(r);
            const [i, a] = String(
                "string" != typeof e || (0, s.isHexStrict)(e)
                  ? (0, t.toNumber)(e)
                  : e,
              )
                .split(".")
                .concat(""),
              c = BigInt(`${i}${a}`) * n,
              d = n.toString().length - 1,
              u = Math.min(a.length, d);
            return 0 === u
              ? c.toString()
              : c.toString().padStart(u, "0").slice(0, -u);
          }),
          (t.toChecksumAddress = (e) => {
            if (!(0, s.isAddress)(e, !1)) throw new o.InvalidAddressError(e);
            const r = e.toLowerCase().replace(/^0x/i, ""),
              a = (0, t.bytesToHex)((0, n.keccak256)((0, i.utf8ToBytes)(r)));
            if (
              (0, s.isNullish)(a) ||
              "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470" ===
                a
            )
              return "";
            let c = "0x";
            const d = a.replace(/^0x/i, "");
            for (let e = 0; e < r.length; e += 1)
              parseInt(d[e], 16) > 7 ? (c += r[e].toUpperCase()) : (c += r[e]);
            return c;
          });
      },
      4255: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.format =
            t.convert =
            t.convertScalarValue =
            t.isDataFormat =
              void 0);
        const n = r(3087),
          i = r(2823),
          s = r(8840),
          o = r(1805),
          a = r(7110),
          c = r(2838),
          d = r(2539),
          { parseBaseType: u } = s.utils;
        t.isDataFormat = (e) =>
          "object" == typeof e &&
          !(0, s.isNullish)(e) &&
          "number" in e &&
          "bytes" in e;
        const l = (e, t, r = []) => {
          let n,
            i = Object.assign({}, e);
          for (const e of t) {
            if (i.oneOf && n) {
              const e = r.find(
                function (e) {
                  return this === e[0];
                },
                null != n ? n : "",
              );
              e && e[0] === n && (i = i.oneOf[e[1]]);
            }
            if (!i.properties && !i.items) return;
            if (i.properties) i = i.properties[e];
            else if (i.items && i.items.properties) {
              const t = i.items.properties;
              if (!t) return;
              i = t[e];
            } else
              i.items && (0, s.isObject)(i.items)
                ? (i = i.items)
                : i.items &&
                  Array.isArray(i.items) &&
                  (i = i.items[parseInt(e, 10)]);
            i && e && (n = e);
          }
          return i;
        };
        (t.convertScalarValue = (e, t, r) => {
          try {
            const { baseType: s, baseTypeSize: a } = u(t);
            if ("int" === s || "uint" === s)
              switch (r.number) {
                case i.FMT_NUMBER.NUMBER:
                  return Number((0, o.toBigInt)(e));
                case i.FMT_NUMBER.HEX:
                  return (0, o.numberToHex)((0, o.toBigInt)(e));
                case i.FMT_NUMBER.STR:
                  return (0, o.toBigInt)(e).toString();
                case i.FMT_NUMBER.BIGINT:
                  return (0, o.toBigInt)(e);
                default:
                  throw new n.FormatterError(
                    `Invalid format: ${String(r.number)}`,
                  );
              }
            if ("bytes" === s) {
              let t;
              switch (
                (a
                  ? "string" == typeof e
                    ? (t = (0, c.padLeft)(e, 2 * a))
                    : e instanceof Uint8Array &&
                      (t = (0, d.uint8ArrayConcat)(
                        new Uint8Array(a - e.length),
                        e,
                      ))
                  : (t = e),
                r.bytes)
              ) {
                case i.FMT_BYTES.HEX:
                  return (0, o.bytesToHex)((0, o.bytesToUint8Array)(t));
                case i.FMT_BYTES.UINT8ARRAY:
                  return (0, o.bytesToUint8Array)(t);
                default:
                  throw new n.FormatterError(
                    `Invalid format: ${String(r.bytes)}`,
                  );
              }
            }
          } catch (t) {
            return e;
          }
          return e;
        }),
          (t.convert = (e, r, n, i, o = []) => {
            var a, c;
            if (!(0, s.isObject)(e) && !Array.isArray(e))
              return (0, t.convertScalarValue)(
                e,
                null == r ? void 0 : r.format,
                i,
              );
            const d = e;
            for (const [e, u] of Object.entries(d)) {
              n.push(e);
              const h = l(r, n, o);
              if ((0, s.isNullish)(h)) delete d[e], n.pop();
              else if ((0, s.isObject)(u)) (0, t.convert)(u, r, n, i), n.pop();
              else {
                if (Array.isArray(u)) {
                  let l = h;
                  if (
                    (void 0 !== (null == h ? void 0 : h.oneOf) &&
                      h.oneOf.forEach((t, r) => {
                        var n, i;
                        !Array.isArray(null == h ? void 0 : h.items) &&
                          (("object" == typeof u[0] &&
                            "object" ===
                              (null === (n = null == t ? void 0 : t.items) ||
                              void 0 === n
                                ? void 0
                                : n.type)) ||
                            ("string" == typeof u[0] &&
                              "object" !==
                                (null === (i = null == t ? void 0 : t.items) ||
                                void 0 === i
                                  ? void 0
                                  : i.type))) &&
                          ((l = t), o.push([e, r]));
                      }),
                    (0, s.isNullish)(null == l ? void 0 : l.items))
                  ) {
                    delete d[e], n.pop();
                    continue;
                  }
                  if (
                    (0, s.isObject)(l.items) &&
                    !(0, s.isNullish)(l.items.format)
                  ) {
                    for (let r = 0; r < u.length; r += 1)
                      d[e][r] = (0, t.convertScalarValue)(
                        u[r],
                        null === (a = null == l ? void 0 : l.items) ||
                          void 0 === a
                          ? void 0
                          : a.format,
                        i,
                      );
                    n.pop();
                    continue;
                  }
                  if (
                    !Array.isArray(null == l ? void 0 : l.items) &&
                    "object" ===
                      (null === (c = null == l ? void 0 : l.items) ||
                      void 0 === c
                        ? void 0
                        : c.type)
                  ) {
                    for (const e of u) (0, t.convert)(e, r, n, i, o);
                    n.pop();
                    continue;
                  }
                  if (Array.isArray(null == l ? void 0 : l.items)) {
                    for (let r = 0; r < u.length; r += 1)
                      d[e][r] = (0, t.convertScalarValue)(
                        u[r],
                        l.items[r].format,
                        i,
                      );
                    n.pop();
                    continue;
                  }
                }
                (d[e] = (0, t.convertScalarValue)(u, h.format, i)), n.pop();
              }
            }
            return d;
          }),
          (t.format = (e, r, i) => {
            let o;
            o = (0, s.isObject)(r)
              ? (0, a.mergeDeep)({}, r)
              : Array.isArray(r)
              ? [...r]
              : r;
            const c = (0, s.isObject)(e) ? e : s.utils.ethAbiToJsonSchema(e);
            if (!c.properties && !c.items && !c.format)
              throw new n.FormatterError("Invalid json schema for formatting");
            return (0, t.convert)(o, c, [], i);
          });
      },
      1070: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.getStorageSlotNumForLongString =
            t.soliditySha3Raw =
            t.soliditySha3 =
            t.encodePacked =
            t.processSolidityEncodePackedArgs =
            t.keccak256 =
            t.keccak256Wrapper =
            t.sha3Raw =
            t.sha3 =
              void 0);
        const n = r(2192),
          i = r(8040),
          s = r(3087),
          o = r(8840),
          a = r(1805),
          c = r(2838),
          d =
            "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
        (t.sha3 = (e) => {
          let t;
          t =
            "string" == typeof e
              ? e.startsWith("0x") && (0, o.isHexStrict)(e)
                ? (0, a.hexToBytes)(e)
                : (0, i.utf8ToBytes)(e)
              : e;
          const r = (0, a.bytesToHex)((0, n.keccak256)(t));
          return r === d ? void 0 : r;
        }),
          (t.sha3Raw = (e) => {
            const r = (0, t.sha3)(e);
            return (0, o.isNullish)(r) ? d : r;
          }),
          (t.keccak256Wrapper = (e) => {
            let t;
            return (
              (t =
                "bigint" == typeof e || "number" == typeof e
                  ? (0, i.utf8ToBytes)(e.toString())
                  : Array.isArray(e)
                  ? new Uint8Array(e)
                  : "string" != typeof e || (0, o.isHexStrict)(e)
                  ? (0, a.bytesToUint8Array)(e)
                  : (0, i.utf8ToBytes)(e)),
              (0, a.bytesToHex)((0, n.keccak256)(t))
            );
          }),
          (t.keccak256 = t.keccak256Wrapper);
        const u = (e, t) => {
            const r = /^(\d+).*$/.exec(e.slice(t));
            return r ? parseInt(r[1], 10) : 0;
          },
          l = (e) => e.toString(2).length,
          h = (e, t) => {
            const r = t.toString();
            if ("string" === e) {
              if ("string" == typeof t) return (0, a.utf8ToHex)(t);
              throw new s.InvalidStringError(t);
            }
            if ("bool" === e || "boolean" === e) {
              if ("boolean" == typeof t) return t ? "01" : "00";
              throw new s.InvalidBooleanError(t);
            }
            if ("address" === e) {
              if (!(0, o.isAddress)(r)) throw new s.InvalidAddressError(r);
              return r;
            }
            const n = ((e) =>
              e.startsWith("int[")
                ? `int256${e.slice(3)}`
                : "int" === e
                ? "int256"
                : e.startsWith("uint[")
                ? `uint256'${e.slice(4)}`
                : "uint" === e
                ? "uint256"
                : e)(e);
            if (e.startsWith("uint")) {
              const e = u(n, 4);
              if (e % 8 || e < 8 || e > 256) throw new s.InvalidSizeError(r);
              const t = (0, a.toNumber)(r);
              if (l(t) > e) throw new s.InvalidLargeValueError(r);
              if (t < BigInt(0)) throw new s.InvalidUnsignedIntegerError(r);
              return e
                ? (0, c.leftPad)(t.toString(16), (e / 8) * 2)
                : t.toString(16);
            }
            if (e.startsWith("int")) {
              const t = u(n, 3);
              if (t % 8 || t < 8 || t > 256) throw new s.InvalidSizeError(e);
              const i = (0, a.toNumber)(r);
              if (l(i) > t) throw new s.InvalidLargeValueError(r);
              return i < BigInt(0)
                ? (0, c.toTwosComplement)(i.toString(), (t / 8) * 2)
                : t
                ? (0, c.leftPad)(i.toString(16), t / 4)
                : i.toString(16);
            }
            if ("bytes" === n) {
              if (r.replace(/^0x/i, "").length % 2 != 0)
                throw new s.InvalidBytesError(r);
              return r;
            }
            if (e.startsWith("bytes")) {
              if (r.replace(/^0x/i, "").length % 2 != 0)
                throw new s.InvalidBytesError(r);
              const t = u(e, 5);
              if (!t || t < 1 || t > 64 || t < r.replace(/^0x/i, "").length / 2)
                throw new s.InvalidBytesError(r);
              return (0, c.rightPad)(r, 2 * t);
            }
            return "";
          };
        (t.processSolidityEncodePackedArgs = (e) => {
          const [t, r] = ((e) => {
            if (Array.isArray(e))
              throw new Error("Autodetection of array types is not supported.");
            let t, r;
            return (
              "object" == typeof e &&
              ("t" in e || "type" in e) &&
              ("v" in e || "value" in e)
                ? ((t = "t" in e ? e.t : e.type),
                  (r = "v" in e ? e.v : e.value))
                : ((t = (0, a.toHex)(e, !0)),
                  (r = (0, a.toHex)(e)),
                  t.startsWith("int") || t.startsWith("uint") || (t = "bytes")),
              (!t.startsWith("int") && !t.startsWith("uint")) ||
                "string" != typeof r ||
                /^(-)?0x/i.test(r) ||
                (r = (0, a.toBigInt)(r)),
              [t, r]
            );
          })(e);
          return Array.isArray(r)
            ? r.map((e) => h(t, e).replace("0x", "")).join("")
            : h(t, r).replace("0x", "");
        }),
          (t.encodePacked = (...e) =>
            `0x${Array.prototype.slice
              .call(e)
              .map(t.processSolidityEncodePackedArgs)
              .join("")
              .toLowerCase()}`),
          (t.soliditySha3 = (...e) => (0, t.sha3)((0, t.encodePacked)(...e))),
          (t.soliditySha3Raw = (...e) =>
            (0, t.sha3Raw)((0, t.encodePacked)(...e))),
          (t.getStorageSlotNumForLongString = (e) =>
            (0, t.sha3)(
              `0x${("number" == typeof e ? e.toString() : e).padStart(
                64,
                "0",
              )}`,
            ));
      },
      9150: function (e, t, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (e, t, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(t, r);
                  (i &&
                    !("get" in i
                      ? !t.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return t[r];
                      },
                    }),
                    Object.defineProperty(e, n, i);
                }
              : function (e, t, r, n) {
                  void 0 === n && (n = r), (e[n] = t[r]);
                }),
          i =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (e, t) {
                  Object.defineProperty(e, "default", {
                    enumerable: !0,
                    value: t,
                  });
                }
              : function (e, t) {
                  e.default = t;
                }),
          s =
            (this && this.__exportStar) ||
            function (e, t) {
              for (var r in e)
                "default" === r ||
                  Object.prototype.hasOwnProperty.call(t, r) ||
                  n(t, e, r);
            },
          o =
            (this && this.__importStar) ||
            function (e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(e, r) &&
                    n(t, e, r);
              return i(t, e), t;
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.jsonRpc = void 0),
          s(r(1805), t),
          s(r(4459), t),
          s(r(4255), t),
          s(r(1070), t),
          s(r(4888), t),
          s(r(2838), t),
          s(r(7110), t),
          s(r(2015), t),
          s(r(1951), t),
          (t.jsonRpc = o(r(1951))),
          s(r(7821), t),
          s(r(1285), t),
          s(r(9103), t),
          s(r(2296), t),
          s(r(8171), t),
          s(r(2539), t);
      },
      1951: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.isBatchRequest =
            t.toBatchPayload =
            t.toPayload =
            t.setRequestIdStart =
            t.isBatchResponse =
            t.isValidResponse =
            t.validateResponse =
            t.isSubscriptionResult =
            t.isResponseWithNotification =
            t.isResponseWithError =
            t.isResponseWithResult =
            t.isResponseRpcError =
              void 0);
        const n = r(8840),
          i = r(3087),
          s = r(9103);
        let o;
        (t.isResponseRpcError = (e) => {
          const t = e.error.code;
          return i.rpcErrorsMap.has(t) || (t >= -32099 && t <= -32e3);
        }),
          (t.isResponseWithResult = (e) =>
            !Array.isArray(e) &&
            !!e &&
            "2.0" === e.jsonrpc &&
            "result" in e &&
            (0, n.isNullish)(e.error) &&
            ("number" == typeof e.id || "string" == typeof e.id)),
          (t.isResponseWithError = (e) =>
            !Array.isArray(e) &&
            "2.0" === e.jsonrpc &&
            !!e &&
            (0, n.isNullish)(e.result) &&
            "error" in e &&
            ("number" == typeof e.id || "string" == typeof e.id)),
          (t.isResponseWithNotification = (e) =>
            !(
              Array.isArray(e) ||
              !e ||
              "2.0" !== e.jsonrpc ||
              (0, n.isNullish)(e.params) ||
              (0, n.isNullish)(e.method)
            )),
          (t.isSubscriptionResult = (e) =>
            !Array.isArray(e) &&
            !!e &&
            "2.0" === e.jsonrpc &&
            "id" in e &&
            "result" in e),
          (t.validateResponse = (e) =>
            (0, t.isResponseWithResult)(e) || (0, t.isResponseWithError)(e)),
          (t.isValidResponse = (e) =>
            Array.isArray(e)
              ? e.every(t.validateResponse)
              : (0, t.validateResponse)(e)),
          (t.isBatchResponse = (e) =>
            Array.isArray(e) && e.length > 0 && (0, t.isValidResponse)(e)),
          (t.setRequestIdStart = (e) => {
            o = e;
          }),
          (t.toPayload = (e) => {
            var t, r, n, i;
            return (
              void 0 !== o && (o += 1),
              {
                jsonrpc: null !== (t = e.jsonrpc) && void 0 !== t ? t : "2.0",
                id:
                  null !== (n = null !== (r = e.id) && void 0 !== r ? r : o) &&
                  void 0 !== n
                    ? n
                    : (0, s.uuidV4)(),
                method: e.method,
                params: null !== (i = e.params) && void 0 !== i ? i : void 0,
              }
            );
          }),
          (t.toBatchPayload = (e) => e.map((e) => (0, t.toPayload)(e))),
          (t.isBatchRequest = (e) => Array.isArray(e) && e.length > 0);
      },
      7110: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.mergeDeep = void 0);
        const n = r(2823),
          i = r(8840),
          s = (e) =>
            !(
              "object" != typeof e ||
              (0, i.isNullish)(e) ||
              Array.isArray(e) ||
              e instanceof n.TypedArray
            );
        t.mergeDeep = (e, ...r) => {
          const o = e;
          if (!s(o)) return o;
          for (const e of r)
            for (const r in e)
              s(e[r])
                ? (o[r] || (o[r] = {}), (0, t.mergeDeep)(o[r], e[r]))
                : !(0, i.isNullish)(e[r]) &&
                  Object.hasOwnProperty.call(e, r) &&
                  (Array.isArray(e[r]) || e[r] instanceof n.TypedArray
                    ? (o[r] = e[r].slice(0))
                    : (o[r] = e[r]));
          return o;
        };
      },
      2015: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__awaiter) ||
          function (e, t, r, n) {
            return new (r || (r = Promise))(function (i, s) {
              function o(e) {
                try {
                  c(n.next(e));
                } catch (e) {
                  s(e);
                }
              }
              function a(e) {
                try {
                  c(n.throw(e));
                } catch (e) {
                  s(e);
                }
              }
              function c(e) {
                var t;
                e.done
                  ? i(e.value)
                  : ((t = e.value),
                    t instanceof r
                      ? t
                      : new r(function (e) {
                          e(t);
                        })).then(o, a);
              }
              c((n = n.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.rejectIfConditionAtInterval =
            t.rejectIfTimeout =
            t.pollTillDefined =
            t.waitWithTimeout =
            t.isPromise =
              void 0);
        const i = r(8840);
        function s(e, t, r) {
          return n(this, void 0, void 0, function* () {
            let n;
            const i = yield Promise.race([
              e instanceof Promise ? e : e(),
              new Promise((e, i) => {
                n = setTimeout(() => (r ? i(r) : e(void 0)), t);
              }),
            ]);
            if ((n && clearTimeout(n), i instanceof Error)) throw i;
            return i;
          });
        }
        (t.isPromise = function (e) {
          return (
            ("object" == typeof e || "function" == typeof e) &&
            "function" == typeof e.then
          );
        }),
          (t.waitWithTimeout = s),
          (t.pollTillDefined = function (e, t) {
            return n(this, void 0, void 0, function* () {
              const r = s(e, t);
              let o;
              const a = new Promise((r, a) => {
                  o = setInterval(() => {
                    (() => {
                      n(this, void 0, void 0, function* () {
                        try {
                          const n = yield s(e, t);
                          (0, i.isNullish)(n) || (clearInterval(o), r(n));
                        } catch (e) {
                          clearInterval(o), a(e);
                        }
                      });
                    })();
                  }, t);
                }),
                c = yield r;
              return (0, i.isNullish)(c) ? a : (o && clearInterval(o), c);
            });
          }),
          (t.rejectIfTimeout = function (e, t) {
            let r;
            const n = new Promise((n, i) => {
              r = setTimeout(() => {
                i(t);
              }, e);
            });
            return [r, n];
          }),
          (t.rejectIfConditionAtInterval = function (e, t) {
            let r;
            const i = new Promise((i, s) => {
              r = setInterval(() => {
                (() => {
                  n(this, void 0, void 0, function* () {
                    const t = yield e();
                    t && (clearInterval(r), s(t));
                  });
                })();
              }, t);
            });
            return [r, i];
          });
      },
      4888: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.randomHex = t.randomBytes = void 0);
        const n = r(472),
          i = r(1805);
        (t.randomBytes = (e) => (0, n.getRandomBytesSync)(e)),
          (t.randomHex = (e) => (0, i.bytesToHex)((0, t.randomBytes)(e)));
      },
      8171: function (e, t, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (e, t, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(t, r);
                  (i &&
                    !("get" in i
                      ? !t.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return t[r];
                      },
                    }),
                    Object.defineProperty(e, n, i);
                }
              : function (e, t, r, n) {
                  void 0 === n && (n = r), (e[n] = t[r]);
                }),
          i =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (e, t) {
                  Object.defineProperty(e, "default", {
                    enumerable: !0,
                    value: t,
                  });
                }
              : function (e, t) {
                  e.default = t;
                }),
          s =
            (this && this.__importStar) ||
            function (e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(e, r) &&
                    n(t, e, r);
              return i(t, e), t;
            },
          o =
            (this && this.__awaiter) ||
            function (e, t, r, n) {
              return new (r || (r = Promise))(function (i, s) {
                function o(e) {
                  try {
                    c(n.next(e));
                  } catch (e) {
                    s(e);
                  }
                }
                function a(e) {
                  try {
                    c(n.throw(e));
                  } catch (e) {
                    s(e);
                  }
                }
                function c(e) {
                  var t;
                  e.done
                    ? i(e.value)
                    : ((t = e.value),
                      t instanceof r
                        ? t
                        : new r(function (e) {
                            e(t);
                          })).then(o, a);
                }
                c((n = n.apply(e, t || [])).next());
              });
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.SocketProvider = void 0);
        const a = r(3087),
          c = r(2296),
          d = r(1285),
          u = r(4459),
          l = r(7821),
          h = s(r(1951)),
          f = { autoReconnect: !0, delay: 5e3, maxAttempts: 5 };
        class p extends c.Eip1193Provider {
          constructor(e, t, r) {
            if (
              (super(),
              (this._connectionStatus = "connecting"),
              (this._onMessageHandler = this._onMessage.bind(this)),
              (this._onOpenHandler = this._onConnect.bind(this)),
              (this._onCloseHandler = this._onCloseEvent.bind(this)),
              (this._onErrorHandler = this._onError.bind(this)),
              !this._validateProviderPath(e))
            )
              throw new a.InvalidClientError(e);
            (this._socketPath = e),
              (this._socketOptions = t),
              (this._reconnectOptions = Object.assign(
                Object.assign({}, f),
                null != r ? r : {},
              )),
              (this._pendingRequestsQueue = new Map()),
              (this._sentRequestsQueue = new Map()),
              this._init(),
              this.connect(),
              (this.chunkResponseParser = new d.ChunkResponseParser(
                this._eventEmitter,
                this._reconnectOptions.autoReconnect,
              )),
              this.chunkResponseParser.onError(() => {
                this._clearQueues();
              }),
              (this.isReconnecting = !1);
          }
          get SocketConnection() {
            return this._socketConnection;
          }
          _init() {
            this._reconnectAttempts = 0;
          }
          connect() {
            try {
              this._openSocketConnection(),
                (this._connectionStatus = "connecting"),
                this._addSocketListeners();
            } catch (e) {
              if (!this.isReconnecting)
                throw (
                  ((this._connectionStatus = "disconnected"),
                  e && e.message
                    ? new a.ConnectionError(
                        `Error while connecting to ${this._socketPath}. Reason: ${e.message}`,
                      )
                    : new a.InvalidClientError(this._socketPath))
                );
              setImmediate(() => {
                this._reconnect();
              });
            }
          }
          _validateProviderPath(e) {
            return !!e;
          }
          supportsSubscriptions() {
            return !0;
          }
          on(e, t) {
            this._eventEmitter.on(e, t);
          }
          once(e, t) {
            this._eventEmitter.once(e, t);
          }
          removeListener(e, t) {
            this._eventEmitter.removeListener(e, t);
          }
          _onDisconnect(e, t) {
            (this._connectionStatus = "disconnected"),
              super._onDisconnect(e, t);
          }
          disconnect(e, t) {
            const r = null != e ? e : 1e3;
            this._removeSocketListeners(),
              "disconnected" !== this.getStatus() &&
                this._closeSocketConnection(r, t),
              this._onDisconnect(r, t);
          }
          removeAllListeners(e) {
            this._eventEmitter.removeAllListeners(e);
          }
          _onError(e) {
            this.isReconnecting
              ? this._reconnect()
              : this._eventEmitter.emit("error", e);
          }
          reset() {
            this._sentRequestsQueue.clear(),
              this._pendingRequestsQueue.clear(),
              this._init(),
              this._removeSocketListeners(),
              this._addSocketListeners();
          }
          _reconnect() {
            this.isReconnecting ||
              ((this.isReconnecting = !0),
              this._sentRequestsQueue.size > 0 &&
                this._sentRequestsQueue.forEach((e, t) => {
                  e.deferredPromise.reject(
                    new a.PendingRequestsOnReconnectingError(),
                  ),
                    this._sentRequestsQueue.delete(t);
                }),
              this._reconnectAttempts < this._reconnectOptions.maxAttempts
                ? ((this._reconnectAttempts += 1),
                  setTimeout(() => {
                    this._removeSocketListeners(),
                      this.connect(),
                      (this.isReconnecting = !1);
                  }, this._reconnectOptions.delay))
                : ((this.isReconnecting = !1),
                  this._clearQueues(),
                  this._removeSocketListeners(),
                  this._eventEmitter.emit(
                    "error",
                    new a.MaxAttemptsReachedOnReconnectingError(
                      this._reconnectOptions.maxAttempts,
                    ),
                  )));
          }
          request(e) {
            return o(this, void 0, void 0, function* () {
              if ((0, u.isNullish)(this._socketConnection))
                throw new Error("Connection is undefined");
              "disconnected" === this.getStatus() && this.connect();
              const t = h.isBatchRequest(e) ? e[0].id : e.id;
              if (!t) throw new a.Web3WSProviderError("Request Id not defined");
              if (this._sentRequestsQueue.has(t))
                throw new a.RequestAlreadySentError(t);
              const r = new l.Web3DeferredPromise();
              r.catch((e) => {
                this._eventEmitter.emit("error", e);
              });
              const n = { payload: e, deferredPromise: r };
              if ("connecting" === this.getStatus())
                return this._pendingRequestsQueue.set(t, n), n.deferredPromise;
              this._sentRequestsQueue.set(t, n);
              try {
                this._sendToSocket(n.payload);
              } catch (e) {
                this._sentRequestsQueue.delete(t),
                  this._eventEmitter.emit("error", e);
              }
              return r;
            });
          }
          _onConnect() {
            (this._connectionStatus = "connected"),
              (this._reconnectAttempts = 0),
              super._onConnect(),
              this._sendPendingRequests();
          }
          _sendPendingRequests() {
            for (const [e, t] of this._pendingRequestsQueue.entries())
              this._sendToSocket(t.payload),
                this._pendingRequestsQueue.delete(e),
                this._sentRequestsQueue.set(e, t);
          }
          _onMessage(e) {
            const t = this._parseResponses(e);
            if (0 !== t.length)
              for (const e of t) {
                if (
                  h.isResponseWithNotification(e) &&
                  e.method.endsWith("_subscription")
                )
                  return void this._eventEmitter.emit("message", e);
                const t = h.isBatchResponse(e) ? e[0].id : e.id,
                  r = this._sentRequestsQueue.get(t);
                if (!r) return;
                (h.isBatchResponse(e) ||
                  h.isResponseWithResult(e) ||
                  h.isResponseWithError(e)) &&
                  (this._eventEmitter.emit("message", e),
                  r.deferredPromise.resolve(e)),
                  this._sentRequestsQueue.delete(t);
              }
            else this._reconnectOptions.autoReconnect && this._reconnect();
          }
          _clearQueues(e) {
            this._pendingRequestsQueue.size > 0 &&
              this._pendingRequestsQueue.forEach((t, r) => {
                t.deferredPromise.reject(new a.ConnectionNotOpenError(e)),
                  this._pendingRequestsQueue.delete(r);
              }),
              this._sentRequestsQueue.size > 0 &&
                this._sentRequestsQueue.forEach((t, r) => {
                  t.deferredPromise.reject(new a.ConnectionNotOpenError(e)),
                    this._sentRequestsQueue.delete(r);
                }),
              this._removeSocketListeners();
          }
        }
        t.SocketProvider = p;
      },
      2838: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.fromTwosComplement =
            t.toTwosComplement =
            t.leftPad =
            t.rightPad =
            t.padRight =
            t.padLeft =
              void 0);
        const n = r(3087),
          i = r(8840),
          s = r(1805);
        (t.padLeft = (e, t, r = "0") =>
          "string" == typeof e
            ? (0, i.isHexStrict)(e)
              ? i.utils.padLeft(e, t, r)
              : e.padStart(t, r)
            : (i.validator.validate(["int"], [e]), i.utils.padLeft(e, t, r))),
          (t.padRight = (e, t, r = "0") => {
            if ("string" == typeof e && !(0, i.isHexStrict)(e))
              return e.padEnd(t, r);
            i.validator.validate(["int"], [e]);
            const n =
                "string" == typeof e && (0, i.isHexStrict)(e)
                  ? e
                  : (0, s.numberToHex)(e),
              o = n.startsWith("-") ? 3 : 2;
            return n.padEnd(t + o, r);
          }),
          (t.rightPad = t.padRight),
          (t.leftPad = t.padLeft),
          (t.toTwosComplement = (e, r = 64) => {
            i.validator.validate(["int"], [e]);
            const o = (0, s.toNumber)(e);
            if (o >= 0) return (0, t.padLeft)((0, s.toHex)(o), r);
            const a = BigInt(2) ** BigInt(4 * r);
            if (-o >= a)
              throw new n.NibbleWidthError(`value: ${e}, nibbleWidth: ${r}`);
            const c = BigInt(o) + a;
            return (0, t.padLeft)((0, s.numberToHex)(c), r);
          }),
          (t.fromTwosComplement = (e, t = 64) => {
            i.validator.validate(["int"], [e]);
            const r = (0, s.toNumber)(e);
            if (r < 0) return r;
            const o = Math.ceil(Math.log(Number(r)) / Math.log(2));
            if (o > 4 * t)
              throw new n.NibbleWidthError(
                `value: "${e}", nibbleWidth: "${t}"`,
              );
            if (4 * t !== o) return r;
            const a = BigInt(2) ** (BigInt(t) * BigInt(4));
            return (0, s.toNumber)(BigInt(r) - a);
          });
      },
      2539: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.uint8ArrayEquals = t.uint8ArrayConcat = void 0),
          (t.uint8ArrayConcat = function (...e) {
            const t = e.reduce((e, t) => e + t.length, 0),
              r = new Uint8Array(t);
            let n = 0;
            for (const t of e) r.set(t, n), (n += t.length);
            return r;
          }),
          (t.uint8ArrayEquals = function (e, t) {
            if (e === t) return !0;
            if (e.byteLength !== t.byteLength) return !1;
            for (let r = 0; r < e.byteLength; r += 1)
              if (e[r] !== t[r]) return !1;
            return !0;
          });
      },
      9103: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.uuidV4 = void 0);
        const n = r(1805),
          i = r(4888);
        t.uuidV4 = () => {
          const e = (0, i.randomBytes)(16);
          (e[6] = (15 & e[6]) | 64), (e[8] = (63 & e[8]) | 128);
          const t = (0, n.bytesToHex)(e);
          return [
            t.substring(2, 10),
            t.substring(10, 14),
            t.substring(14, 18),
            t.substring(18, 22),
            t.substring(22, 34),
          ].join("-");
        };
      },
      4459: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.isNullish =
            t.compareBlockNumbers =
            t.isTopicInBloom =
            t.isTopic =
            t.isContractAddressInBloom =
            t.isUserEthereumAddressInBloom =
            t.isInBloom =
            t.isBloom =
            t.isAddress =
            t.checkAddressCheckSum =
            t.isHex =
            t.isHexStrict =
              void 0);
        const n = r(3087),
          i = r(8840),
          s = r(2823);
        (t.isHexStrict = i.isHexStrict),
          (t.isHex = i.isHex),
          (t.checkAddressCheckSum = i.checkAddressCheckSum),
          (t.isAddress = i.isAddress),
          (t.isBloom = i.isBloom),
          (t.isInBloom = i.isInBloom),
          (t.isUserEthereumAddressInBloom = i.isUserEthereumAddressInBloom),
          (t.isContractAddressInBloom = i.isContractAddressInBloom),
          (t.isTopic = i.isTopic),
          (t.isTopicInBloom = i.isTopicInBloom),
          (t.compareBlockNumbers = (e, t) => {
            const r = "string" == typeof e && (0, i.isBlockTag)(e),
              o = "string" == typeof t && (0, i.isBlockTag)(t);
            if (
              e === t ||
              (("earliest" === e || 0 === e) && ("earliest" === t || 0 === t))
            )
              return 0;
            if ("earliest" === e && t > 0) return -1;
            if ("earliest" === t && e > 0) return 1;
            if (r && o) {
              const r = {
                [s.BlockTags.EARLIEST]: 1,
                [s.BlockTags.FINALIZED]: 2,
                [s.BlockTags.SAFE]: 3,
                [s.BlockTags.LATEST]: 4,
                [s.BlockTags.PENDING]: 5,
              };
              return r[e] < r[t] ? -1 : 1;
            }
            if ((r && !o) || (!r && o))
              throw new n.InvalidBlockError(
                "Cannot compare blocktag with provided non-blocktag input.",
              );
            const a = BigInt(e),
              c = BigInt(t);
            return a < c ? -1 : a === c ? 0 : 1;
          }),
          (t.isNullish = i.isNullish);
      },
      7821: function (e, t, r) {
        "use strict";
        var n,
          i =
            (this && this.__awaiter) ||
            function (e, t, r, n) {
              return new (r || (r = Promise))(function (i, s) {
                function o(e) {
                  try {
                    c(n.next(e));
                  } catch (e) {
                    s(e);
                  }
                }
                function a(e) {
                  try {
                    c(n.throw(e));
                  } catch (e) {
                    s(e);
                  }
                }
                function c(e) {
                  var t;
                  e.done
                    ? i(e.value)
                    : ((t = e.value),
                      t instanceof r
                        ? t
                        : new r(function (e) {
                            e(t);
                          })).then(o, a);
                }
                c((n = n.apply(e, t || [])).next());
              });
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Web3DeferredPromise = void 0);
        const s = r(3087);
        (t.Web3DeferredPromise = class {
          constructor(
            { timeout: e, eagerStart: t, timeoutMessage: r } = {
              timeout: 0,
              eagerStart: !1,
              timeoutMessage: "DeferredPromise timed out",
            },
          ) {
            (this[n] = "Promise"),
              (this._state = "pending"),
              (this._promise = new Promise((e, t) => {
                (this._resolve = e), (this._reject = t);
              })),
              (this._timeoutMessage = r),
              (this._timeoutInterval = e),
              t && this.startTimer();
          }
          get state() {
            return this._state;
          }
          then(e, t) {
            return i(this, void 0, void 0, function* () {
              return this._promise.then(e, t);
            });
          }
          catch(e) {
            return i(this, void 0, void 0, function* () {
              return this._promise.catch(e);
            });
          }
          finally(e) {
            return i(this, void 0, void 0, function* () {
              return this._promise.finally(e);
            });
          }
          resolve(e) {
            this._resolve(e), (this._state = "fulfilled"), this._clearTimeout();
          }
          reject(e) {
            this._reject(e), (this._state = "rejected"), this._clearTimeout();
          }
          startTimer() {
            this._timeoutInterval &&
              this._timeoutInterval > 0 &&
              (this._timeoutId = setTimeout(
                this._checkTimeout.bind(this),
                this._timeoutInterval,
              ));
          }
          _checkTimeout() {
            "pending" === this._state &&
              this._timeoutId &&
              this.reject(new s.OperationTimeoutError(this._timeoutMessage));
          }
          _clearTimeout() {
            this._timeoutId && clearTimeout(this._timeoutId);
          }
        }),
          (n = Symbol.toStringTag);
      },
      2296: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__awaiter) ||
          function (e, t, r, n) {
            return new (r || (r = Promise))(function (i, s) {
              function o(e) {
                try {
                  c(n.next(e));
                } catch (e) {
                  s(e);
                }
              }
              function a(e) {
                try {
                  c(n.throw(e));
                } catch (e) {
                  s(e);
                }
              }
              function c(e) {
                var t;
                e.done
                  ? i(e.value)
                  : ((t = e.value),
                    t instanceof r
                      ? t
                      : new r(function (e) {
                          e(t);
                        })).then(o, a);
              }
              c((n = n.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Eip1193Provider = void 0);
        const i = r(2823),
          s = r(7187),
          o = r(3087),
          a = r(1951);
        class c extends i.Web3BaseProvider {
          constructor() {
            super(...arguments),
              (this._eventEmitter = new s.EventEmitter()),
              (this._chainId = ""),
              (this._accounts = []);
          }
          _getChainId() {
            var e;
            return n(this, void 0, void 0, function* () {
              const t = yield this.request(
                (0, a.toPayload)({ method: "eth_chainId", params: [] }),
              );
              return null !== (e = null == t ? void 0 : t.result) &&
                void 0 !== e
                ? e
                : "";
            });
          }
          _getAccounts() {
            var e;
            return n(this, void 0, void 0, function* () {
              const t = yield this.request(
                (0, a.toPayload)({ method: "eth_accounts", params: [] }),
              );
              return null !== (e = null == t ? void 0 : t.result) &&
                void 0 !== e
                ? e
                : [];
            });
          }
          _onConnect() {
            Promise.all([
              this._getChainId()
                .then((e) => {
                  e !== this._chainId &&
                    ((this._chainId = e),
                    this._eventEmitter.emit("chainChanged", this._chainId));
                })
                .catch((e) => {
                  console.error(e);
                }),
              this._getAccounts()
                .then((e) => {
                  (this._accounts.length === e.length &&
                    e.every((t) => e.includes(t))) ||
                    ((this._accounts = e), this._onAccountsChanged());
                })
                .catch((e) => {
                  console.error(e);
                }),
            ])
              .then(() =>
                this._eventEmitter.emit("connect", { chainId: this._chainId }),
              )
              .catch((e) => {
                console.error(e);
              });
          }
          _onDisconnect(e, t) {
            this._eventEmitter.emit(
              "disconnect",
              new o.EIP1193ProviderRpcError(e, t),
            );
          }
          _onAccountsChanged() {
            this._eventEmitter.emit("accountsChanged", this._accounts);
          }
        }
        t.Eip1193Provider = c;
      },
      5361: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.VALID_ETH_BASE_TYPES = void 0),
          (t.VALID_ETH_BASE_TYPES = [
            "bool",
            "int",
            "uint",
            "bytes",
            "string",
            "address",
            "tuple",
          ]);
      },
      3072: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.validator = void 0);
        const n = r(1286);
        t.validator = new n.Web3Validator();
      },
      680: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Web3ValidatorError = void 0);
        const n = r(3087),
          i = (e) => (e.message ? e.message : "unspecified error");
        class s extends n.BaseWeb3Error {
          constructor(e) {
            super(),
              (this.code = n.ERR_VALIDATION),
              (this.errors = e),
              (super.message = `Web3 validator found ${
                e.length
              } error[s]:\n${this._compileErrors().join("\n")}`);
          }
          _compileErrors() {
            return this.errors.map(i);
          }
        }
        t.Web3ValidatorError = s;
      },
      9186: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
        const n = r(310),
          i = r(4586),
          s = r(3899),
          o = r(8661),
          a = r(7702),
          c = r(9971),
          d = r(3003),
          u = r(9452),
          l = {
            address: (e) => (0, n.isAddress)(e),
            bloom: (e) => (0, s.isBloom)(e),
            blockNumber: (e) => (0, i.isBlockNumber)(e),
            blockTag: (e) => (0, i.isBlockTag)(e),
            blockNumberOrTag: (e) => (0, i.isBlockNumberOrTag)(e),
            bool: (e) => (0, o.isBoolean)(e),
            bytes: (e) => (0, a.isBytes)(e),
            filter: (e) => (0, c.isFilterObject)(e),
            hex: (e) => (0, d.isHexStrict)(e),
            uint: (e) => (0, u.isUInt)(e),
            int: (e) => (0, u.isInt)(e),
            number: (e) => (0, u.isNumber)(e),
            string: (e) => (0, d.isString)(e),
          };
        for (let e = 3; e <= 8; e += 1) {
          const t = 2 ** e;
          (l[`int${t}`] = (e) => (0, u.isInt)(e, { bitSize: t })),
            (l[`uint${t}`] = (e) => (0, u.isUInt)(e, { bitSize: t }));
        }
        for (let e = 1; e <= 32; e += 1)
          l[`bytes${e}`] = (t) => (0, a.isBytes)(t, { size: e });
        (l.bytes256 = l.bytes), (t.default = l);
      },
      8840: function (e, t, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (e, t, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(t, r);
                  (i &&
                    !("get" in i
                      ? !t.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return t[r];
                      },
                    }),
                    Object.defineProperty(e, n, i);
                }
              : function (e, t, r, n) {
                  void 0 === n && (n = r), (e[n] = t[r]);
                }),
          i =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (e, t) {
                  Object.defineProperty(e, "default", {
                    enumerable: !0,
                    value: t,
                  });
                }
              : function (e, t) {
                  e.default = t;
                }),
          s =
            (this && this.__exportStar) ||
            function (e, t) {
              for (var r in e)
                "default" === r ||
                  Object.prototype.hasOwnProperty.call(t, r) ||
                  n(t, e, r);
            },
          o =
            (this && this.__importStar) ||
            function (e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(e, r) &&
                    n(t, e, r);
              return i(t, e), t;
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.utils = void 0),
          s(r(1286), t),
          s(r(3072), t),
          s(r(6842), t),
          (t.utils = o(r(8268))),
          s(r(680), t),
          s(r(5361), t),
          s(r(4414), t);
      },
      6842: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
      },
      8268: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.hexToUint8Array =
            t.uint8ArrayToHexString =
            t.padLeft =
            t.numberToHex =
            t.hexToNumber =
            t.codePointToInt =
            t.transformJsonDataToAbiFormat =
            t.fetchArrayElement =
            t.ethAbiToJsonSchema =
            t.abiSchemaToJsonSchema =
            t.parseBaseType =
              void 0);
        const n = r(3087),
          i = r(5361),
          s = r(993),
          o = r(3003),
          a = r(680),
          c = [
            "hex",
            "number",
            "blockNumber",
            "blockNumberOrTag",
            "filter",
            "bloom",
          ];
        t.parseBaseType = (e) => {
          let t,
            r = e.replace(/ /, ""),
            n = !1,
            s = [];
          if (
            (e.includes("[") &&
              ((r = r.slice(0, r.indexOf("["))),
              (s = [...e.matchAll(/(?:\[(\d*)\])/g)]
                .map((e) => parseInt(e[1], 10))
                .map((e) => (Number.isNaN(e) ? -1 : e))),
              (n = s.length > 0)),
            i.VALID_ETH_BASE_TYPES.includes(r))
          )
            return { baseType: r, isArray: n, baseTypeSize: t, arraySizes: s };
          if (r.startsWith("int"))
            (t = parseInt(r.substring(3), 10)), (r = "int");
          else if (r.startsWith("uint"))
            (t = parseInt(e.substring(4), 10)), (r = "uint");
          else {
            if (!r.startsWith("bytes"))
              return {
                baseType: void 0,
                isArray: !1,
                baseTypeSize: void 0,
                arraySizes: s,
              };
            (t = parseInt(r.substring(5), 10)), (r = "bytes");
          }
          return { baseType: r, isArray: n, baseTypeSize: t, arraySizes: s };
        };
        const d = (e, r = {}) => {
          if (Object.keys(r).includes("type"))
            throw new a.Web3ValidatorError([
              {
                keyword: "eth",
                message: 'Either "eth" or "type" can be presented in schema',
                params: { eth: e },
                instancePath: "",
                schemaPath: "",
              },
            ]);
          const { baseType: n, baseTypeSize: i } = (0, t.parseBaseType)(e);
          if (!n && !c.includes(e))
            throw new a.Web3ValidatorError([
              {
                keyword: "eth",
                message: `Eth data type "${e}" is not valid`,
                params: { eth: e },
                instancePath: "",
                schemaPath: "",
              },
            ]);
          if (n) {
            if ("tuple" === n)
              throw new Error('"tuple" type is not implemented directly.');
            return { format: `${n}${null != i ? i : ""}`, required: !0 };
          }
          return e ? { format: e, required: !0 } : {};
        };
        (t.abiSchemaToJsonSchema = (e, r = "/0") => {
          const n = {
            type: "array",
            items: [],
            maxItems: e.length,
            minItems: e.length,
          };
          for (const [i, o] of e.entries()) {
            let e,
              a,
              c = [];
            (0, s.isAbiParameterSchema)(o)
              ? ((e = o.type), (a = o.name), (c = o.components))
              : "string" == typeof o
              ? ((e = o), (a = `${r}/${i}`))
              : Array.isArray(o) &&
                (o[0] &&
                "string" == typeof o[0] &&
                o[0].startsWith("tuple") &&
                !Array.isArray(o[0]) &&
                o[1] &&
                Array.isArray(o[1])
                  ? ((e = o[0]), (a = `${r}/${i}`), (c = o[1]))
                  : ((e = "tuple"), (a = `${r}/${i}`), (c = o)));
            const {
              baseType: u,
              isArray: l,
              arraySizes: h,
            } = (0, t.parseBaseType)(e);
            let f,
              p = n;
            for (let e = h.length - 1; e > 0; e -= 1)
              (f = {
                type: "array",
                items: [],
                maxItems: h[e],
                minItems: h[e],
              }),
                h[e] < 0 && (delete f.maxItems, delete f.minItems),
                (p.items = f),
                (p = f);
            if ("tuple" !== u || l)
              if ("tuple" === u && l) {
                const e = h[0],
                  r = {
                    $id: a,
                    type: "array",
                    items: (0, t.abiSchemaToJsonSchema)(c, a),
                    maxItems: e,
                    minItems: e,
                  };
                e < 0 && (delete r.maxItems, delete r.minItems),
                  p.items.push(r);
              } else if (l) {
                const e = h[0],
                  t = {
                    type: "array",
                    $id: a,
                    items: d(String(u)),
                    minItems: e,
                    maxItems: e,
                  };
                e < 0 && (delete t.maxItems, delete t.minItems),
                  p.items.push(t);
              } else
                Array.isArray(p.items)
                  ? p.items.push(Object.assign({ $id: a }, d(e)))
                  : p.items.items.push(Object.assign({ $id: a }, d(e)));
            else {
              const e = (0, t.abiSchemaToJsonSchema)(c, a);
              (e.$id = a), p.items.push(e);
            }
          }
          return n;
        }),
          (t.ethAbiToJsonSchema = (e) => (0, t.abiSchemaToJsonSchema)(e)),
          (t.fetchArrayElement = (e, r) =>
            1 === r ? e : (0, t.fetchArrayElement)(e[0], r - 1)),
          (t.transformJsonDataToAbiFormat = (e, r, n) => {
            const i = [];
            for (const [o, a] of e.entries()) {
              let e,
                c,
                d = [];
              (0, s.isAbiParameterSchema)(a)
                ? ((e = a.type), (c = a.name), (d = a.components))
                : "string" == typeof a
                ? (e = a)
                : Array.isArray(a) &&
                  (a[1] && Array.isArray(a[1])
                    ? ((e = a[0]), (d = a[1]))
                    : ((e = "tuple"), (d = a)));
              const {
                  baseType: u,
                  isArray: l,
                  arraySizes: h,
                } = (0, t.parseBaseType)(e),
                f = Array.isArray(r) ? r[o] : r[c];
              if ("tuple" !== u || l)
                if ("tuple" === u && l) {
                  const e = [];
                  for (const r of f)
                    if (h.length > 1) {
                      const i = (0, t.fetchArrayElement)(r, h.length - 1),
                        s = [];
                      for (const e of i)
                        s.push((0, t.transformJsonDataToAbiFormat)(d, e, n));
                      e.push(s);
                    } else e.push((0, t.transformJsonDataToAbiFormat)(d, r, n));
                  i.push(e);
                } else i.push(f);
              else i.push((0, t.transformJsonDataToAbiFormat)(d, f, n));
            }
            return (n = null != n ? n : []).push(...i), n;
          }),
          (t.codePointToInt = (e) => {
            if (e >= 48 && e <= 57) return e - 48;
            if (e >= 65 && e <= 70) return e - 55;
            if (e >= 97 && e <= 102) return e - 87;
            throw new Error(`Invalid code point: ${e}`);
          }),
          (t.hexToNumber = (e) => {
            if (!(0, o.isHexStrict)(e)) throw new Error("Invalid hex string");
            const [t, r] = e.startsWith("-") ? [!0, e.slice(1)] : [!1, e],
              n = BigInt(r);
            return n > Number.MAX_SAFE_INTEGER
              ? t
                ? -n
                : n
              : n < Number.MIN_SAFE_INTEGER
              ? n
              : t
              ? -1 * Number(n)
              : Number(n);
          }),
          (t.numberToHex = (e) => {
            if (("number" == typeof e || "bigint" == typeof e) && e < 0)
              return `-0x${e.toString(16).slice(1)}`;
            if (("number" == typeof e || "bigint" == typeof e) && e >= 0)
              return `0x${e.toString(16)}`;
            if ("string" == typeof e && (0, o.isHexStrict)(e)) {
              const [t, r] = e.startsWith("-") ? [!0, e.slice(1)] : [!1, e];
              return `${t ? "-" : ""}0x${r
                .split(/^(-)?0(x|X)/)
                .slice(-1)[0]
                .replace(/^0+/, "")
                .toLowerCase()}`;
            }
            if ("string" == typeof e && !(0, o.isHexStrict)(e))
              return (0, t.numberToHex)(BigInt(e));
            throw new n.InvalidNumberError(e);
          }),
          (t.padLeft = (e, r, n = "0") => {
            if ("string" == typeof e && !(0, o.isHexStrict)(e))
              return e.padStart(r, n);
            const i =
                "string" == typeof e && (0, o.isHexStrict)(e)
                  ? e
                  : (0, t.numberToHex)(e),
              [s, a] = i.startsWith("-")
                ? ["-0x", i.slice(3)]
                : ["0x", i.slice(2)];
            return `${s}${a.padStart(r, n)}`;
          }),
          (t.uint8ArrayToHexString = function (e) {
            let t = "0x";
            for (const r of e) {
              const e = r.toString(16);
              t += 1 === e.length ? `0${e}` : e;
            }
            return t;
          }),
          (t.hexToUint8Array = function (e) {
            let t;
            if (
              ((t = e.toLowerCase().startsWith("0x") ? e.slice(2) : e),
              t.length % 2 != 0)
            )
              throw new n.InvalidBytesError(`hex string has odd length: ${e}`);
            const r = new Uint8Array(Math.ceil(t.length / 2));
            for (let e = 0; e < r.length; e += 1) {
              const n = parseInt(t.substring(2 * e, 2 * e + 2), 16);
              r[e] = n;
            }
            return r;
          });
      },
      993: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.isAbiParameterSchema = void 0),
          (t.isAbiParameterSchema = (e) =>
            "object" == typeof e && "type" in e && "name" in e);
      },
      310: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.isAddress = t.checkAddressCheckSum = void 0);
        const n = r(2192),
          i = r(8040),
          s = r(8268),
          o = r(3003);
        (t.checkAddressCheckSum = (e) => {
          if (!/^(0x)?[0-9a-f]{40}$/i.test(e)) return !1;
          const t = e.slice(2),
            r = (0, i.utf8ToBytes)(t.toLowerCase()),
            o = (0, s.uint8ArrayToHexString)((0, n.keccak256)(r)).slice(2);
          for (let e = 0; e < 40; e += 1)
            if (
              (parseInt(o[e], 16) > 7 && t[e].toUpperCase() !== t[e]) ||
              (parseInt(o[e], 16) <= 7 && t[e].toLowerCase() !== t[e])
            )
              return !1;
          return !0;
        }),
          (t.isAddress = (e, r = !0) => {
            if ("string" != typeof e && !(e instanceof Uint8Array)) return !1;
            let n;
            return (
              (n =
                e instanceof Uint8Array
                  ? (0, s.uint8ArrayToHexString)(e)
                  : "string" != typeof e ||
                    (0, o.isHexStrict)(e) ||
                    e.toLowerCase().startsWith("0x")
                  ? e
                  : `0x${e}`),
              !!/^(0x)?[0-9a-f]{40}$/i.test(n) &&
                (!(
                  !/^(0x|0X)?[0-9a-f]{40}$/.test(n) &&
                  !/^(0x|0X)?[0-9A-F]{40}$/.test(n)
                ) ||
                  !r ||
                  (0, t.checkAddressCheckSum)(n))
            );
          });
      },
      4586: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.isBlockNumberOrTag = t.isBlockTag = t.isBlockNumber = void 0);
        const n = r(2823),
          i = r(9452);
        (t.isBlockNumber = (e) => (0, i.isUInt)(e)),
          (t.isBlockTag = (e) => Object.values(n.BlockTags).includes(e)),
          (t.isBlockNumberOrTag = (e) =>
            (0, t.isBlockTag)(e) || (0, t.isBlockNumber)(e));
      },
      3899: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.isContractAddressInBloom =
            t.isUserEthereumAddressInBloom =
            t.isInBloom =
            t.isBloom =
              void 0);
        const n = r(2192),
          i = r(8268),
          s = r(310),
          o = r(3003);
        (t.isBloom = (e) =>
          !(
            "string" != typeof e ||
            !/^(0x)?[0-9a-f]{512}$/i.test(e) ||
            (!/^(0x)?[0-9a-f]{512}$/.test(e) && !/^(0x)?[0-9A-F]{512}$/.test(e))
          )),
          (t.isInBloom = (e, r) => {
            if ("string" == typeof r && !(0, o.isHexStrict)(r)) return !1;
            if (!(0, t.isBloom)(e)) return !1;
            const s = "string" == typeof r ? (0, i.hexToUint8Array)(r) : r,
              a = (0, i.uint8ArrayToHexString)((0, n.keccak256)(s)).slice(2);
            for (let t = 0; t < 12; t += 4) {
              const r =
                  ((parseInt(a.slice(t, t + 2), 16) << 8) +
                    parseInt(a.slice(t + 2, t + 4), 16)) &
                  2047,
                n = 1 << r % 4;
              if (
                ((0, i.codePointToInt)(
                  e.charCodeAt(e.length - 1 - Math.floor(r / 4)),
                ) &
                  n) !==
                n
              )
                return !1;
            }
            return !0;
          }),
          (t.isUserEthereumAddressInBloom = (e, r) => {
            if (!(0, t.isBloom)(e)) return !1;
            if (!(0, s.isAddress)(r)) return !1;
            const n = (0, i.padLeft)(r, 64);
            return (0, t.isInBloom)(e, n);
          }),
          (t.isContractAddressInBloom = (e, r) =>
            !!(0, t.isBloom)(e) &&
            !!(0, s.isAddress)(r) &&
            (0, t.isInBloom)(e, r));
      },
      8661: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.isBoolean = void 0);
        const n = r(3003);
        t.isBoolean = (e) =>
          !!["number", "string", "boolean"].includes(typeof e) &&
          ("boolean" == typeof e ||
            ("string" != typeof e || (0, n.isHexStrict)(e)
              ? "string" == typeof e && (0, n.isHexStrict)(e)
                ? "0x1" === e || "0x0" === e
                : 1 === e || 0 === e
              : "1" === e || "0" === e));
      },
      7702: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.isBytes = t.isUint8Array = void 0);
        const n = r(8268),
          i = r(3003);
        (t.isUint8Array = (e) => e instanceof Uint8Array),
          (t.isBytes = (e, t = { abiType: "bytes" }) => {
            if (
              !(
                "string" == typeof e ||
                Array.isArray(e) ||
                e instanceof Uint8Array
              )
            )
              return !1;
            if (
              "string" == typeof e &&
              (0, i.isHexStrict)(e) &&
              e.startsWith("-")
            )
              return !1;
            if ("string" == typeof e && !(0, i.isHexStrict)(e)) return !1;
            let r;
            if ("string" == typeof e) {
              if (e.length % 2 != 0) return !1;
              r = (0, n.hexToUint8Array)(e);
            } else if (Array.isArray(e)) {
              if (e.some((e) => e < 0 || e > 255 || !Number.isInteger(e)))
                return !1;
              r = new Uint8Array(e);
            } else r = e;
            if (null == t ? void 0 : t.abiType) {
              const { baseTypeSize: e } = (0, n.parseBaseType)(t.abiType);
              return !e || r.length === e;
            }
            return (
              !(null == t ? void 0 : t.size) ||
              r.length === (null == t ? void 0 : t.size)
            );
          });
      },
      3052: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.isValidEthBaseType = void 0);
        const n = r(8268);
        t.isValidEthBaseType = (e) => {
          const { baseType: t, baseTypeSize: r } = (0, n.parseBaseType)(e);
          return (
            !!t &&
            (t === e ||
              ((("int" !== t && "uint" !== t) ||
                !r ||
                (r <= 256 && r % 8 == 0)) &&
                ("bytes" !== t || !r || (r >= 1 && r <= 32))))
          );
        };
      },
      9971: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.isFilterObject = void 0);
        const n = r(310),
          i = r(4586),
          s = r(8891),
          o = r(2164);
        t.isFilterObject = (e) => {
          const t = ["fromBlock", "toBlock", "address", "topics", "blockHash"];
          if ((0, s.isNullish)(e) || "object" != typeof e) return !1;
          if (!Object.keys(e).every((e) => t.includes(e))) return !1;
          if (
            (!(0, s.isNullish)(e.fromBlock) &&
              !(0, i.isBlockNumberOrTag)(e.fromBlock)) ||
            (!(0, s.isNullish)(e.toBlock) &&
              !(0, i.isBlockNumberOrTag)(e.toBlock))
          )
            return !1;
          if (!(0, s.isNullish)(e.address))
            if (Array.isArray(e.address)) {
              if (!e.address.every((e) => (0, n.isAddress)(e))) return !1;
            } else if (!(0, n.isAddress)(e.address)) return !1;
          return !(
            !(0, s.isNullish)(e.topics) &&
            !e.topics.every(
              (e) =>
                !!(0, s.isNullish)(e) ||
                (Array.isArray(e)
                  ? e.every((e) => (0, o.isTopic)(e))
                  : !!(0, o.isTopic)(e)),
            )
          );
        };
      },
      4414: function (e, t, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (e, t, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(t, r);
                  (i &&
                    !("get" in i
                      ? !t.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return t[r];
                      },
                    }),
                    Object.defineProperty(e, n, i);
                }
              : function (e, t, r, n) {
                  void 0 === n && (n = r), (e[n] = t[r]);
                }),
          i =
            (this && this.__exportStar) ||
            function (e, t) {
              for (var r in e)
                "default" === r ||
                  Object.prototype.hasOwnProperty.call(t, r) ||
                  n(t, e, r);
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          i(r(310), t),
          i(r(4586), t),
          i(r(3899), t),
          i(r(8661), t),
          i(r(7702), t),
          i(r(3052), t),
          i(r(9971), t),
          i(r(9452), t),
          i(r(3003), t),
          i(r(2164), t),
          i(r(8891), t);
      },
      9452: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.isNumber = t.isInt = t.isUInt = t.isBigInt = void 0);
        const n = r(8268),
          i = r(3003);
        (t.isBigInt = (e) => "bigint" == typeof e),
          (t.isUInt = (e, t = { abiType: "uint" }) => {
            if (
              !["number", "string", "bigint"].includes(typeof e) ||
              ("string" == typeof e && 0 === e.length)
            )
              return !1;
            let r;
            if (null == t ? void 0 : t.abiType) {
              const { baseTypeSize: e } = (0, n.parseBaseType)(t.abiType);
              e && (r = e);
            } else t.bitSize && (r = t.bitSize);
            const s = BigInt(2) ** BigInt(null != r ? r : 256) - BigInt(1);
            try {
              const t =
                "string" == typeof e && (0, i.isHexStrict)(e)
                  ? BigInt((0, n.hexToNumber)(e))
                  : BigInt(e);
              return t >= 0 && t <= s;
            } catch (e) {
              return !1;
            }
          }),
          (t.isInt = (e, t = { abiType: "int" }) => {
            if (!["number", "string", "bigint"].includes(typeof e)) return !1;
            if ("number" == typeof e && e > Number.MAX_SAFE_INTEGER) return !1;
            let r;
            if (null == t ? void 0 : t.abiType) {
              const { baseTypeSize: e, baseType: i } = (0, n.parseBaseType)(
                t.abiType,
              );
              if ("int" !== i) return !1;
              e && (r = e);
            } else t.bitSize && (r = t.bitSize);
            const s = BigInt(2) ** BigInt((null != r ? r : 256) - 1),
              o = BigInt(-1) * BigInt(2) ** BigInt((null != r ? r : 256) - 1);
            try {
              const t =
                "string" == typeof e && (0, i.isHexStrict)(e)
                  ? BigInt((0, n.hexToNumber)(e))
                  : BigInt(e);
              return t >= o && t <= s;
            } catch (e) {
              return !1;
            }
          }),
          (t.isNumber = (e) =>
            !!(0, t.isInt)(e) ||
            !(
              "string" != typeof e ||
              !/[0-9.]/.test(e) ||
              e.indexOf(".") !== e.lastIndexOf(".")
            ) ||
            "number" == typeof e);
      },
      8891: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.isObject = t.isNullish = void 0);
        const n = r(2823);
        (t.isNullish = (e) => null == e),
          (t.isObject = (e) =>
            !(
              "object" != typeof e ||
              (0, t.isNullish)(e) ||
              Array.isArray(e) ||
              e instanceof n.TypedArray
            ));
      },
      3003: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.validateNoLeadingZeroes =
            t.isHexPrefixed =
            t.isHexString32Bytes =
            t.isHexString8Bytes =
            t.isHex =
            t.isHexString =
            t.isHexStrict =
            t.isString =
              void 0),
          (t.isString = (e) => "string" == typeof e),
          (t.isHexStrict = (e) =>
            "string" == typeof e && /^((-)?0x[0-9a-f]+|(0x))$/i.test(e)),
          (t.isHexString = function (e, t) {
            return !(
              "string" != typeof e ||
              !e.match(/^0x[0-9A-Fa-f]*$/) ||
              (void 0 !== t && t > 0 && e.length !== 2 + 2 * t)
            );
          }),
          (t.isHex = (e) =>
            "number" == typeof e ||
            "bigint" == typeof e ||
            ("string" == typeof e && /^((-0x|0x|-)?[0-9a-f]+|(0x))$/i.test(e))),
          (t.isHexString8Bytes = (e, r = !0) =>
            r
              ? (0, t.isHexStrict)(e) && 18 === e.length
              : (0, t.isHex)(e) && 16 === e.length),
          (t.isHexString32Bytes = (e, r = !0) =>
            r
              ? (0, t.isHexStrict)(e) && 66 === e.length
              : (0, t.isHex)(e) && 64 === e.length),
          (t.isHexPrefixed = function (e) {
            if ("string" != typeof e)
              throw new Error(
                "[isHexPrefixed] input must be type 'string', received type " +
                  typeof e,
              );
            return e.startsWith("0x");
          }),
          (t.validateNoLeadingZeroes = function (e) {
            for (const [t, r] of Object.entries(e))
              if (void 0 !== r && r.length > 0 && 0 === r[0])
                throw new Error(
                  `${t} cannot have leading zeroes, received: ${r.toString()}`,
                );
          });
      },
      2164: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.isTopicInBloom = t.isTopic = void 0);
        const n = r(3899);
        (t.isTopic = (e) =>
          !(
            "string" != typeof e ||
            !/^(0x)?[0-9a-f]{64}$/i.test(e) ||
            (!/^(0x)?[0-9a-f]{64}$/.test(e) && !/^(0x)?[0-9A-F]{64}$/.test(e))
          )),
          (t.isTopicInBloom = (e, r) =>
            !!(0, n.isBloom)(e) &&
            !!(0, t.isTopic)(r) &&
            (0, n.isInBloom)(e, r));
      },
      7696: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__importDefault) ||
          function (e) {
            return e && e.__esModule ? e : { default: e };
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Validator = void 0);
        const i = r(8754),
          s = r(680),
          o = n(r(9186)),
          a = (e) => {
            if (
              (!(null == e ? void 0 : e.type) ||
                "object" === (null == e ? void 0 : e.type)) &&
              (null == e ? void 0 : e.properties)
            ) {
              const t = {};
              for (const r of Object.keys(e.properties)) {
                const n = a(e.properties[r]);
                n && (t[r] = n);
              }
              return Array.isArray(e.required)
                ? i.z
                    .object(t)
                    .partial()
                    .required(
                      e.required.reduce(
                        (e, t) =>
                          Object.assign(Object.assign({}, e), { [t]: !0 }),
                        {},
                      ),
                    )
                : i.z.object(t).partial();
            }
            if (
              "array" === (null == e ? void 0 : e.type) &&
              (null == e ? void 0 : e.items)
            ) {
              if (Array.isArray(e.items) && e.items.length > 0) {
                const t = [];
                for (const r of e.items) {
                  const e = a(r);
                  e && t.push(e);
                }
                return i.z.tuple(t);
              }
              return i.z.array(a(e.items));
            }
            return e.oneOf && Array.isArray(e.oneOf)
              ? i.z.union(e.oneOf.map((e) => a(e)))
              : (null == e ? void 0 : e.format)
              ? i.z
                  .any()
                  .refine(o.default[e.format], (t) => ({
                    params: { value: t, format: e.format },
                  }))
              : (null == e ? void 0 : e.type) &&
                "object" !== (null == e ? void 0 : e.type) &&
                "function" == typeof i.z[String(e.type)]
              ? i.z[String(e.type)]()
              : i.z.object({ data: i.z.any() }).partial();
          };
        class c {
          static factory() {
            return (
              c.validatorInstance || (c.validatorInstance = new c()),
              c.validatorInstance
            );
          }
          validate(e, t, r) {
            var n, i;
            const o = a(e).safeParse(t);
            if (!o.success) {
              const e = this.convertErrors(
                null !==
                  (i =
                    null === (n = o.error) || void 0 === n
                      ? void 0
                      : n.issues) && void 0 !== i
                  ? i
                  : [],
              );
              if (e) {
                if (null == r ? void 0 : r.silent) return e;
                throw new s.Web3ValidatorError(e);
              }
            }
          }
          convertErrors(e) {
            if (e && Array.isArray(e) && e.length > 0)
              return e.map((e) => {
                var t;
                let r, n, s, o;
                o = e.path.join("/");
                const a = String(e.path[e.path.length - 1]),
                  c = e.path.join("/");
                if (e.code === i.ZodIssueCode.too_big)
                  (n = "maxItems"),
                    (o = `${c}/maxItems`),
                    (s = { limit: e.maximum }),
                    (r = `must NOT have more than ${e.maximum} items`);
                else if (e.code === i.ZodIssueCode.too_small)
                  (n = "minItems"),
                    (o = `${c}/minItems`),
                    (s = { limit: e.minimum }),
                    (r = `must NOT have fewer than ${e.minimum} items`);
                else if (e.code === i.ZodIssueCode.custom) {
                  const { value: n, format: i } =
                    null !== (t = e.params) && void 0 !== t ? t : {};
                  (r =
                    void 0 === n
                      ? `value at "/${o}" is required`
                      : `value "${
                          "object" == typeof n ? JSON.stringify(n) : n
                        }" at "/${o}" must pass "${i}" validation`),
                    (s = { value: n });
                }
                return {
                  keyword: null != n ? n : a,
                  instancePath: c ? `/${c}` : "",
                  schemaPath: o ? `#${o}` : "#",
                  params: null != s ? s : { value: e.message },
                  message: null != r ? r : e.message,
                };
              });
          }
        }
        t.Validator = c;
      },
      1286: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Web3Validator = void 0);
        const n = r(7696),
          i = r(8268),
          s = r(680);
        t.Web3Validator = class {
          constructor() {
            this._validator = n.Validator.factory();
          }
          validateJSONSchema(e, t, r) {
            return this._validator.validate(e, t, r);
          }
          validate(e, t, r = { silent: !1 }) {
            var n, o;
            const a = (0, i.ethAbiToJsonSchema)(e);
            if (
              !Array.isArray(a.items) ||
              0 !==
                (null === (n = a.items) || void 0 === n ? void 0 : n.length) ||
              0 !== t.length
            ) {
              if (
                Array.isArray(a.items) &&
                0 ===
                  (null === (o = a.items) || void 0 === o
                    ? void 0
                    : o.length) &&
                0 !== t.length
              )
                throw new s.Web3ValidatorError([
                  {
                    instancePath: "/0",
                    schemaPath: "/",
                    keyword: "required",
                    message: "empty schema against data can not be validated",
                    params: t,
                  },
                ]);
              return this._validator.validate(a, t, r);
            }
          }
        };
      },
      4694: (e, t, r) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
        const n = r(3050);
        t.default = {
          encodeEventSignature: n.encodeEventSignature,
          encodeFunctionCall: n.encodeFunctionCall,
          encodeFunctionSignature: n.encodeFunctionSignature,
          encodeParameter: n.encodeParameter,
          encodeParameters: n.encodeParameters,
          decodeParameter: n.decodeParameter,
          decodeParameters: n.decodeParameters,
          decodeLog: n.decodeLog,
        };
      },
      6514: function (e, t, r) {
        "use strict";
        var n =
          (this && this.__awaiter) ||
          function (e, t, r, n) {
            return new (r || (r = Promise))(function (i, s) {
              function o(e) {
                try {
                  c(n.next(e));
                } catch (e) {
                  s(e);
                }
              }
              function a(e) {
                try {
                  c(n.throw(e));
                } catch (e) {
                  s(e);
                }
              }
              function c(e) {
                var t;
                e.done
                  ? i(e.value)
                  : ((t = e.value),
                    t instanceof r
                      ? t
                      : new r(function (e) {
                          e(t);
                        })).then(o, a);
              }
              c((n = n.apply(e, t || [])).next());
            });
          };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.initAccountsForContext = void 0);
        const i = r(2823),
          s = r(9150),
          o = r(6653),
          a = r(4464);
        t.initAccountsForContext = (e) => {
          const t = (t, r) =>
              n(void 0, void 0, void 0, function* () {
                const n = yield (0, o.prepareTransactionForSigning)(t, e),
                  c = (0, s.format)({ format: "bytes" }, r, i.ETH_DATA_FORMAT);
                return (0, a.signTransaction)(n, c);
              }),
            r = (e) => {
              const r = (0, a.privateKeyToAccount)(e);
              return Object.assign(Object.assign({}, r), {
                signTransaction: (e) =>
                  n(void 0, void 0, void 0, function* () {
                    return t(e, r.privateKey);
                  }),
              });
            },
            c = (e, r, i) =>
              n(void 0, void 0, void 0, function* () {
                var s;
                const o = yield (0, a.decrypt)(
                  e,
                  r,
                  null === (s = null == i ? void 0 : i.nonStrict) ||
                    void 0 === s ||
                    s,
                );
                return Object.assign(Object.assign({}, o), {
                  signTransaction: (e) =>
                    n(void 0, void 0, void 0, function* () {
                      return t(e, o.privateKey);
                    }),
                });
              }),
            d = () => {
              const e = (0, a.create)();
              return Object.assign(Object.assign({}, e), {
                signTransaction: (r) =>
                  n(void 0, void 0, void 0, function* () {
                    return t(r, e.privateKey);
                  }),
              });
            },
            u = new a.Wallet({ create: d, privateKeyToAccount: r, decrypt: c });
          return {
            signTransaction: t,
            create: d,
            privateKeyToAccount: r,
            decrypt: c,
            recoverTransaction: a.recoverTransaction,
            hashMessage: a.hashMessage,
            sign: a.sign,
            recover: a.recover,
            encrypt: a.encrypt,
            wallet: u,
          };
        };
      },
      2604: function (e, t, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (e, t, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(t, r);
                  (i &&
                    !("get" in i
                      ? !t.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return t[r];
                      },
                    }),
                    Object.defineProperty(e, n, i);
                }
              : function (e, t, r, n) {
                  void 0 === n && (n = r), (e[n] = t[r]);
                }),
          i =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (e, t) {
                  Object.defineProperty(e, "default", {
                    enumerable: !0,
                    value: t,
                  });
                }
              : function (e, t) {
                  e.default = t;
                }),
          s =
            (this && this.__exportStar) ||
            function (e, t) {
              for (var r in e)
                "default" === r ||
                  Object.prototype.hasOwnProperty.call(t, r) ||
                  n(t, e, r);
            },
          o =
            (this && this.__importStar) ||
            function (e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(e, r) &&
                    n(t, e, r);
              return i(t, e), t;
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.iban =
            t.personal =
            t.ens =
            t.contract =
            t.accounts =
            t.abi =
              void 0),
          s(r(6653), t),
          (t.abi = o(r(3050))),
          (t.accounts = o(r(4464))),
          (t.contract = o(r(2290))),
          (t.ens = o(r(5722))),
          (t.personal = o(r(8898))),
          (t.iban = o(r(2235)));
      },
      1531: function (e, t, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (e, t, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(t, r);
                  (i &&
                    !("get" in i
                      ? !t.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return t[r];
                      },
                    }),
                    Object.defineProperty(e, n, i);
                }
              : function (e, t, r, n) {
                  void 0 === n && (n = r), (e[n] = t[r]);
                }),
          i =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (e, t) {
                  Object.defineProperty(e, "default", {
                    enumerable: !0,
                    value: t,
                  });
                }
              : function (e, t) {
                  e.default = t;
                }),
          s =
            (this && this.__exportStar) ||
            function (e, t) {
              for (var r in e)
                "default" === r ||
                  Object.prototype.hasOwnProperty.call(t, r) ||
                  n(t, e, r);
            },
          o =
            (this && this.__importStar) ||
            function (e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(e, r) &&
                    n(t, e, r);
              return i(t, e), t;
            },
          a =
            (this && this.__importDefault) ||
            function (e) {
              return e && e.__esModule ? e : { default: e };
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.validator =
            t.utils =
            t.types =
            t.rpcMethods =
            t.providers =
            t.net =
            t.eth =
            t.errors =
            t.core =
            t.Web3Validator =
            t.WebSocketProvider =
            t.HttpProvider =
            t.Net =
            t.Personal =
            t.Iban =
            t.Contract =
            t.Web3Eth =
            t.Web3EthPluginBase =
            t.Web3PluginBase =
            t.Web3Context =
            t.Web3 =
              void 0);
        const c = a(r(4662));
        (t.Web3 = c.default), s(r(359), t), (t.default = c.default);
        var d = r(8557);
        Object.defineProperty(t, "Web3Context", {
          enumerable: !0,
          get: function () {
            return d.Web3Context;
          },
        }),
          Object.defineProperty(t, "Web3PluginBase", {
            enumerable: !0,
            get: function () {
              return d.Web3PluginBase;
            },
          }),
          Object.defineProperty(t, "Web3EthPluginBase", {
            enumerable: !0,
            get: function () {
              return d.Web3EthPluginBase;
            },
          });
        var u = r(6653);
        Object.defineProperty(t, "Web3Eth", {
          enumerable: !0,
          get: function () {
            return u.Web3Eth;
          },
        });
        var l = r(2290);
        Object.defineProperty(t, "Contract", {
          enumerable: !0,
          get: function () {
            return l.Contract;
          },
        });
        var h = r(2235);
        Object.defineProperty(t, "Iban", {
          enumerable: !0,
          get: function () {
            return h.Iban;
          },
        });
        var f = r(8898);
        Object.defineProperty(t, "Personal", {
          enumerable: !0,
          get: function () {
            return f.Personal;
          },
        });
        var p = r(6714);
        Object.defineProperty(t, "Net", {
          enumerable: !0,
          get: function () {
            return p.Net;
          },
        });
        var m = r(9701);
        Object.defineProperty(t, "HttpProvider", {
          enumerable: !0,
          get: function () {
            return m.HttpProvider;
          },
        });
        var y = r(4417);
        Object.defineProperty(t, "WebSocketProvider", {
          enumerable: !0,
          get: function () {
            return y.WebSocketProvider;
          },
        });
        var g = r(8840);
        Object.defineProperty(t, "Web3Validator", {
          enumerable: !0,
          get: function () {
            return g.Web3Validator;
          },
        }),
          (t.core = o(r(8557))),
          (t.errors = o(r(3087))),
          (t.eth = o(r(2604))),
          (t.net = o(r(6714))),
          (t.providers = o(r(3116))),
          (t.rpcMethods = o(r(100))),
          (t.types = o(r(2823))),
          (t.utils = o(r(9150))),
          (t.validator = o(r(8840))),
          s(r(3087), t),
          s(r(2823), t);
      },
      3116: function (e, t, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (e, t, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(t, r);
                  (i &&
                    !("get" in i
                      ? !t.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return t[r];
                      },
                    }),
                    Object.defineProperty(e, n, i);
                }
              : function (e, t, r, n) {
                  void 0 === n && (n = r), (e[n] = t[r]);
                }),
          i =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (e, t) {
                  Object.defineProperty(e, "default", {
                    enumerable: !0,
                    value: t,
                  });
                }
              : function (e, t) {
                  e.default = t;
                }),
          s =
            (this && this.__importStar) ||
            function (e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(e, r) &&
                    n(t, e, r);
              return i(t, e), t;
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ws = t.http = t.SocketProvider = t.Eip1193Provider = void 0);
        var o = r(9150);
        Object.defineProperty(t, "Eip1193Provider", {
          enumerable: !0,
          get: function () {
            return o.Eip1193Provider;
          },
        }),
          Object.defineProperty(t, "SocketProvider", {
            enumerable: !0,
            get: function () {
              return o.SocketProvider;
            },
          }),
          (t.http = s(r(9701))),
          (t.ws = s(r(4417)));
      },
      359: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 });
      },
      3872: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Web3PkgInfo = void 0),
          (t.Web3PkgInfo = { version: "4.1.0" });
      },
      4662: function (e, t, r) {
        "use strict";
        var n =
            (this && this.__createBinding) ||
            (Object.create
              ? function (e, t, r, n) {
                  void 0 === n && (n = r);
                  var i = Object.getOwnPropertyDescriptor(t, r);
                  (i &&
                    !("get" in i
                      ? !t.__esModule
                      : i.writable || i.configurable)) ||
                    (i = {
                      enumerable: !0,
                      get: function () {
                        return t[r];
                      },
                    }),
                    Object.defineProperty(e, n, i);
                }
              : function (e, t, r, n) {
                  void 0 === n && (n = r), (e[n] = t[r]);
                }),
          i =
            (this && this.__setModuleDefault) ||
            (Object.create
              ? function (e, t) {
                  Object.defineProperty(e, "default", {
                    enumerable: !0,
                    value: t,
                  });
                }
              : function (e, t) {
                  e.default = t;
                }),
          s =
            (this && this.__importStar) ||
            function (e) {
              if (e && e.__esModule) return e;
              var t = {};
              if (null != e)
                for (var r in e)
                  "default" !== r &&
                    Object.prototype.hasOwnProperty.call(e, r) &&
                    n(t, e, r);
              return i(t, e), t;
            },
          o =
            (this && this.__importDefault) ||
            function (e) {
              return e && e.__esModule ? e : { default: e };
            };
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.Web3 = void 0);
        const a = r(8557),
          c = r(6653),
          d = o(r(2290)),
          u = r(5722),
          l = r(2235),
          h = r(8898),
          f = r(6714),
          p = s(r(9150)),
          m = r(9150),
          y = r(3087),
          g = o(r(4694)),
          v = r(6514),
          b = r(3872);
        class w extends a.Web3Context {
          constructor(e) {
            var t;
            ((0, m.isNullish)(e) ||
              ("string" == typeof e && "" === e.trim()) ||
              (!(0, a.isSupportedProvider)(e) && !e.provider)) &&
              console.warn(
                "NOTE: web3.js is running without provider. You need to pass a provider in order to interact with the network!",
              );
            let r = {};
            "string" == typeof e || (0, a.isSupportedProvider)(e)
              ? (r.provider = e)
              : (r = e || {}),
              (r.registeredSubscriptions = Object.assign(
                Object.assign({}, c.registeredSubscriptions),
                null !== (t = r.registeredSubscriptions) && void 0 !== t
                  ? t
                  : {},
              )),
              super(r);
            const n = (0, v.initAccountsForContext)(this);
            (this._wallet = n.wallet),
              (this._accountProvider = n),
              (this.utils = p);
            const i = this;
            class s extends d.default {
              constructor(e, t, r) {
                if ("object" == typeof t && "object" == typeof r)
                  throw new y.InvalidMethodParamsError(
                    "Should not provide options at both 2nd and 3rd parameters",
                  );
                if ((0, m.isNullish)(t)) super(e, r, i.getContextObject());
                else if ("object" == typeof t)
                  super(e, t, i.getContextObject());
                else {
                  if ("string" != typeof t)
                    throw new y.InvalidMethodParamsError();
                  super(e, t, null != r ? r : {}, i.getContextObject());
                }
                super.subscribeToContextEvents(i);
              }
            }
            const o = i.use(c.Web3Eth);
            this.eth = Object.assign(o, {
              ens: i.use(u.ENS, u.registryAddresses.main),
              Iban: l.Iban,
              net: i.use(f.Net),
              personal: i.use(h.Personal),
              Contract: s,
              abi: g.default,
              accounts: n,
            });
          }
        }
        (t.Web3 = w),
          (w.version = b.Web3PkgInfo.version),
          (w.utils = p),
          (w.modules = {
            Web3Eth: c.Web3Eth,
            Iban: l.Iban,
            Net: f.Net,
            ENS: u.ENS,
            Personal: h.Personal,
          }),
          (t.default = w);
      },
      736: (e) => {
        "use strict";
        e.exports = JSON.parse(
          '[{"inputs":[{"internalType":"string","name":"_name","type":"string"},{"internalType":"string","name":"_symbol","type":"string"},{"internalType":"string","name":"_url","type":"string"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"approved","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"operator","type":"address"},{"indexed":false,"internalType":"bool","name":"approved","type":"bool"}],"name":"ApprovalForAll","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"approve","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"getApproved","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"operator","type":"address"}],"name":"isApprovedForAll","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"ownerOf","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"safeTransferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"safeTransferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"operator","type":"address"},{"internalType":"bool","name":"approved","type":"bool"}],"name":"setApprovalForAll","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"tokenURI","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"transferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"}]',
        );
      },
      2774: (e) => {
        "use strict";
        e.exports = JSON.parse(
          '[{"inputs":[{"internalType":"string","name":"_nick","type":"string"},{"internalType":"string","name":"_pfp","type":"string"}],"name":"createProfile","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_player","type":"address"}],"name":"getProfile","outputs":[{"components":[{"internalType":"string","name":"nick","type":"string"},{"internalType":"string","name":"pfp","type":"string"}],"internalType":"struct PlayerProfile.PlayerState","name":"","type":"tuple"}],"stateMutability":"view","type":"function"}]',
        );
      },
      8296: (e) => {
        "use strict";
        e.exports = JSON.parse(
          '[{"anonymous":false,"inputs":[{"indexed":false,"internalType":"bytes32","name":"gameID","type":"bytes32"}],"name":"CloseGame","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"bytes32","name":"gameID","type":"bytes32"},{"indexed":false,"internalType":"string","name":"title","type":"string"},{"indexed":false,"internalType":"address","name":"bundleAddress","type":"address"}],"name":"CreateGame","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"bytes32","name":"gameID","type":"bytes32"},{"indexed":false,"internalType":"address","name":"player","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"},{"indexed":false,"internalType":"uint16","name":"position","type":"uint16"},{"indexed":false,"internalType":"uint64","name":"accessVersion","type":"uint64"}],"name":"JoinGame","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"nftContract","type":"address"},{"indexed":false,"internalType":"string","name":"name","type":"string"},{"indexed":false,"internalType":"string","name":"symbol","type":"string"},{"indexed":false,"internalType":"string","name":"uri","type":"string"}],"name":"PublishGame","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"serverAddress","type":"address"},{"indexed":false,"internalType":"string","name":"endpoint","type":"string"}],"name":"RegisterServer","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"serverAddress","type":"address"},{"indexed":false,"internalType":"bytes32","name":"gameID","type":"bytes32"}],"name":"ServeGame","type":"event"},{"inputs":[],"name":"MAX_SERVER_NUM","outputs":[{"internalType":"uint16","name":"","type":"uint16"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"NAME_LEN","outputs":[{"internalType":"uint16","name":"","type":"uint16"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32[]","name":"_gameIDs","type":"bytes32[]"}],"name":"batchGetGameState","outputs":[{"components":[{"internalType":"string","name":"title","type":"string"},{"internalType":"address","name":"bundleAddr","type":"address"},{"internalType":"address","name":"token","type":"address"},{"internalType":"address","name":"stakeAddr","type":"address"},{"internalType":"uint16","name":"maxPlayers","type":"uint16"},{"internalType":"uint256","name":"minDeposit","type":"uint256"},{"internalType":"uint256","name":"maxDeposit","type":"uint256"},{"internalType":"bytes","name":"data","type":"bytes"},{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"transactorAddr","type":"address"},{"internalType":"uint64","name":"accessVersion","type":"uint64"},{"internalType":"uint64","name":"settleVersion","type":"uint64"},{"internalType":"uint64","name":"unlockTime","type":"uint64"},{"components":[{"internalType":"address","name":"addr","type":"address"},{"internalType":"uint256","name":"balance","type":"uint256"},{"internalType":"uint16","name":"position","type":"uint16"},{"internalType":"uint64","name":"accessVersion","type":"uint64"},{"internalType":"string","name":"verifyKey","type":"string"}],"internalType":"struct Race.PlayerJoin[]","name":"players","type":"tuple[]"},{"components":[{"internalType":"address","name":"addr","type":"address"},{"internalType":"string","name":"endpoint","type":"string"},{"internalType":"uint64","name":"accessVersion","type":"uint64"},{"internalType":"string","name":"verifyKey","type":"string"}],"internalType":"struct Race.ServerJoin[]","name":"servers","type":"tuple[]"},{"components":[{"internalType":"address","name":"voter","type":"address"},{"internalType":"address","name":"votee","type":"address"},{"internalType":"enum Race.VoteType","name":"voteType","type":"uint8"}],"internalType":"struct Race.Vote[]","name":"votes","type":"tuple[]"},{"internalType":"bytes32","name":"gameID","type":"bytes32"}],"internalType":"struct Race.GameState[]","name":"","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"_gameID","type":"bytes32"}],"name":"closeGame","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_bundleAddr","type":"address"},{"internalType":"address","name":"_tokenAddr","type":"address"},{"internalType":"string","name":"_title","type":"string"},{"internalType":"uint16","name":"_maxPlayers","type":"uint16"},{"internalType":"uint64","name":"_minDeposit","type":"uint64"},{"internalType":"uint64","name":"_maxDeposit","type":"uint64"},{"internalType":"bytes","name":"_data","type":"bytes"}],"name":"createGameState","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"_gameID","type":"bytes32"}],"name":"getGameBaseinfo","outputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"string","name":"title","type":"string"},{"internalType":"address","name":"bundleAddr","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"_gameID","type":"bytes32"}],"name":"getGameState","outputs":[{"components":[{"internalType":"string","name":"title","type":"string"},{"internalType":"address","name":"bundleAddr","type":"address"},{"internalType":"address","name":"token","type":"address"},{"internalType":"address","name":"stakeAddr","type":"address"},{"internalType":"uint16","name":"maxPlayers","type":"uint16"},{"internalType":"uint256","name":"minDeposit","type":"uint256"},{"internalType":"uint256","name":"maxDeposit","type":"uint256"},{"internalType":"bytes","name":"data","type":"bytes"},{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"transactorAddr","type":"address"},{"internalType":"uint64","name":"accessVersion","type":"uint64"},{"internalType":"uint64","name":"settleVersion","type":"uint64"},{"internalType":"uint64","name":"unlockTime","type":"uint64"},{"components":[{"internalType":"address","name":"addr","type":"address"},{"internalType":"uint256","name":"balance","type":"uint256"},{"internalType":"uint16","name":"position","type":"uint16"},{"internalType":"uint64","name":"accessVersion","type":"uint64"},{"internalType":"string","name":"verifyKey","type":"string"}],"internalType":"struct Race.PlayerJoin[]","name":"players","type":"tuple[]"},{"components":[{"internalType":"address","name":"addr","type":"address"},{"internalType":"string","name":"endpoint","type":"string"},{"internalType":"uint64","name":"accessVersion","type":"uint64"},{"internalType":"string","name":"verifyKey","type":"string"}],"internalType":"struct Race.ServerJoin[]","name":"servers","type":"tuple[]"},{"components":[{"internalType":"address","name":"voter","type":"address"},{"internalType":"address","name":"votee","type":"address"},{"internalType":"enum Race.VoteType","name":"voteType","type":"uint8"}],"internalType":"struct Race.Vote[]","name":"votes","type":"tuple[]"},{"internalType":"bytes32","name":"gameID","type":"bytes32"}],"internalType":"struct Race.GameState","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"nftAddress","type":"address"}],"name":"getNFTGameList","outputs":[{"components":[{"internalType":"string","name":"title","type":"string"},{"internalType":"address","name":"bundleAddr","type":"address"},{"internalType":"address","name":"token","type":"address"},{"internalType":"address","name":"stakeAddr","type":"address"},{"internalType":"uint16","name":"maxPlayers","type":"uint16"},{"internalType":"uint256","name":"minDeposit","type":"uint256"},{"internalType":"uint256","name":"maxDeposit","type":"uint256"},{"internalType":"bytes","name":"data","type":"bytes"},{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"transactorAddr","type":"address"},{"internalType":"uint64","name":"accessVersion","type":"uint64"},{"internalType":"uint64","name":"settleVersion","type":"uint64"},{"internalType":"uint64","name":"unlockTime","type":"uint64"},{"components":[{"internalType":"address","name":"addr","type":"address"},{"internalType":"uint256","name":"balance","type":"uint256"},{"internalType":"uint16","name":"position","type":"uint16"},{"internalType":"uint64","name":"accessVersion","type":"uint64"},{"internalType":"string","name":"verifyKey","type":"string"}],"internalType":"struct Race.PlayerJoin[]","name":"players","type":"tuple[]"},{"components":[{"internalType":"address","name":"addr","type":"address"},{"internalType":"string","name":"endpoint","type":"string"},{"internalType":"uint64","name":"accessVersion","type":"uint64"},{"internalType":"string","name":"verifyKey","type":"string"}],"internalType":"struct Race.ServerJoin[]","name":"servers","type":"tuple[]"},{"components":[{"internalType":"address","name":"voter","type":"address"},{"internalType":"address","name":"votee","type":"address"},{"internalType":"enum Race.VoteType","name":"voteType","type":"uint8"}],"internalType":"struct Race.Vote[]","name":"votes","type":"tuple[]"},{"internalType":"bytes32","name":"gameID","type":"bytes32"}],"internalType":"struct Race.GameState[]","name":"","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract NFTTemplate","name":"_nftContract","type":"address"}],"name":"getNFTInfo","outputs":[{"internalType":"string","name":"","type":"string"},{"internalType":"string","name":"","type":"string"},{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_owner","type":"address"}],"name":"getOwnerNFTList","outputs":[{"components":[{"internalType":"address","name":"contractAddress","type":"address"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"},{"internalType":"string","name":"uri","type":"string"}],"internalType":"struct Race.NFTInfo[]","name":"","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"serverAddr","type":"address"}],"name":"getServer","outputs":[{"components":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"string","name":"endpoint","type":"string"}],"internalType":"struct Race.ServerState","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"_gameID","type":"bytes32"},{"internalType":"uint256","name":"_amount","type":"uint256"},{"internalType":"uint64","name":"_accessVersion","type":"uint64"},{"internalType":"uint16","name":"_position","type":"uint16"},{"internalType":"string","name":"_verifyKey","type":"string"}],"name":"join","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"string","name":"_name","type":"string"},{"internalType":"string","name":"_symbol","type":"string"},{"internalType":"string","name":"_url","type":"string"}],"name":"publishGame","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"string","name":"endpoint","type":"string"}],"name":"registerServer","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"_gameID","type":"bytes32"},{"internalType":"string","name":"_verifyKey","type":"string"}],"name":"serve","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"_gameID","type":"bytes32"},{"components":[{"internalType":"address","name":"player","type":"address"},{"internalType":"enum Race.SettleOp","name":"operator","type":"uint8"},{"internalType":"uint256","name":"amount","type":"uint256"}],"internalType":"struct Race.SettleParams[]","name":"params","type":"tuple[]"}],"name":"settle","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"_gameID","type":"bytes32"}],"name":"unServe","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"_gameID","type":"bytes32"},{"internalType":"address","name":"_voteeAddr","type":"address"},{"internalType":"enum Race.VoteType","name":"_voteType","type":"uint8"}],"name":"vote","outputs":[],"stateMutability":"nonpayable","type":"function"}]',
        );
      },
      8438: (e) => {
        "use strict";
        e.exports = JSON.parse(
          '[{"inputs":[{"internalType":"address","name":"_race","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"registryAddr","type":"address"},{"indexed":false,"internalType":"address","name":"owner","type":"address"}],"name":"CreateRegistry","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"registryAddr","type":"address"},{"indexed":false,"internalType":"bytes32","name":"gameID","type":"bytes32"}],"name":"RegisterGame","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"registryAddr","type":"address"},{"indexed":false,"internalType":"bytes32","name":"gameID","type":"bytes32"}],"name":"UnRegisterGame","type":"event"},{"inputs":[{"internalType":"bool","name":"_isPrivate","type":"bool"},{"internalType":"uint16","name":"_size","type":"uint16"}],"name":"createRegistry","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_registryAddr","type":"address"}],"name":"getGameList","outputs":[{"components":[{"internalType":"bytes32","name":"addr","type":"bytes32"},{"internalType":"string","name":"title","type":"string"},{"internalType":"address","name":"bundleAddr","type":"address"},{"internalType":"uint256","name":"regTime","type":"uint256"}],"internalType":"struct Registry.GameRegistration[]","name":"","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_registryAddr","type":"address"}],"name":"getRegistry","outputs":[{"components":[{"internalType":"bool","name":"isPrivate","type":"bool"},{"internalType":"uint16","name":"size","type":"uint16"},{"internalType":"address","name":"owner","type":"address"},{"components":[{"internalType":"bytes32","name":"addr","type":"bytes32"},{"internalType":"string","name":"title","type":"string"},{"internalType":"address","name":"bundleAddr","type":"address"},{"internalType":"uint256","name":"regTime","type":"uint256"}],"internalType":"struct Registry.GameRegistration[]","name":"games","type":"tuple[]"}],"internalType":"struct Registry.RegistryState","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"race","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_registryAddr","type":"address"},{"internalType":"bytes32","name":"_gameID","type":"bytes32"}],"name":"registerGame","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"registries","outputs":[{"internalType":"bool","name":"isPrivate","type":"bool"},{"internalType":"uint16","name":"size","type":"uint16"},{"internalType":"address","name":"owner","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_raceContract","type":"address"}],"name":"setRace","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_registryAddr","type":"address"},{"internalType":"bytes32","name":"_gameID","type":"bytes32"}],"name":"unregisterGame","outputs":[],"stateMutability":"nonpayable","type":"function"}]',
        );
      },
      9634: (e) => {
        "use strict";
        e.exports = JSON.parse(
          '[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint8","name":"version","type":"uint8"}],"name":"Initialized","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"subtractedValue","type":"uint256"}],"name":"decreaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"addedValue","type":"uint256"}],"name":"increaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"}]',
        );
      },
    },
    t = {};
  function r(n) {
    var i = t[n];
    if (void 0 !== i) return i.exports;
    var s = (t[n] = { id: n, loaded: !1, exports: {} });
    return e[n].call(s.exports, s, s.exports, r), (s.loaded = !0), s.exports;
  }
  (r.amdO = {}),
    (r.n = (e) => {
      var t = e && e.__esModule ? () => e.default : () => e;
      return r.d(t, { a: t }), t;
    }),
    (r.d = (e, t) => {
      for (var n in t)
        r.o(t, n) &&
          !r.o(e, n) &&
          Object.defineProperty(e, n, { enumerable: !0, get: t[n] });
    }),
    (r.g = (function () {
      if ("object" == typeof globalThis) return globalThis;
      try {
        return this || new Function("return this")();
      } catch (e) {
        if ("object" == typeof window) return window;
      }
    })()),
    (r.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t)),
    (r.r = (e) => {
      "undefined" != typeof Symbol &&
        Symbol.toStringTag &&
        Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }),
        Object.defineProperty(e, "__esModule", { value: !0 });
    }),
    (r.nmd = (e) => ((e.paths = []), e.children || (e.children = []), e)),
    (() => {
      "use strict";
      var e = r(214),
        t = r(6123),
        n = r(3169),
        i = r(672),
        s = r(195);
      (window.Borsh = e),
        (window.RaceSdkCore = t),
        (window.RaceTransport = n),
        (window.RaceWaller = i),
        (window.WalletConnect = s);
    })();
})();
